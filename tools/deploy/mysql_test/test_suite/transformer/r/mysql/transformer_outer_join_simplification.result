explain_protocol: 2
result_format: 4
set autocommit=0;

##case arithmatic and basic compare
EXPLAIN select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |3        |85  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | SORT           |    |6        |43  |
|3 |  TABLE SCAN    |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter([(T_OP_NOT_BTW, cast(t1.c2, DECIMAL(11, 0)), ?, ?)], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2);
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
+----+------+------+----+------+
EXPLAIN select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |3        |86  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | SORT           |    |6        |44  |
|3 |  SUBPLAN SCAN  |v   |6        |38  |
|4 |   TABLE SCAN   |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([(T_OP_NOT_BTW, cast(v.c2, DECIMAL(11, 0)), ?, ?)], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  3 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2);
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
+----+------+------+----+------+
EXPLAIN insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |3        |86  |
|1 | SUBPLAN SCAN     |VIEW1|3        |85  |
|2 |  MERGE OUTER JOIN|     |3        |85  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   SORT           |     |6        |43  |
|5 |    TABLE SCAN    |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter([(T_OP_NOT_BTW, cast(t1.c2, DECIMAL(11, 0)), ?, ?)], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2));

rollback;
EXPLAIN insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |3        |87  |
|1 | SUBPLAN SCAN     |VIEW1|3        |86  |
|2 |  MERGE OUTER JOIN|     |3        |86  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   SORT           |     |6        |44  |
|5 |    SUBPLAN SCAN  |v    |6        |38  |
|6 |     TABLE SCAN   |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([(T_OP_NOT_BTW, cast(v.c2, DECIMAL(11, 0)), ?, ?)], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  5 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2));

rollback;
EXPLAIN update t1 set c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |129 |
|1 | SUBPLAN FILTER   |    |6        |123 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |3        |85  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |43  |
|6 |    TABLE SCAN    |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter([(T_OP_NOT_BTW, cast(t1.c2, DECIMAL(11, 0)), ?, ?)], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |129 |
|1 | SUBPLAN FILTER   |    |6        |123 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |3        |86  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |44  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([v.c1]), filter([(T_OP_NOT_BTW, cast(v.c2, DECIMAL(11, 0)), ?, ?)], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |123 |
|1 | SUBPLAN FILTER   |    |1        |122 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |3        |85  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |43  |
|6 |    TABLE SCAN    |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter([(T_OP_NOT_BTW, cast(t1.c2, DECIMAL(11, 0)), ?, ?)], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |124 |
|1 | SUBPLAN FILTER   |    |1        |123 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |3        |86  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |44  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([v.c1]), filter([(T_OP_NOT_BTW, cast(v.c2, DECIMAL(11, 0)), ?, ?)], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 not between 1 and 2));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

##case arithmatic and basic compare
EXPLAIN select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |0        |85  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | SORT           |    |6        |43  |
|3 |  TABLE SCAN    |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter([t1.c2 <=> NULL], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null);
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
|  3 |    5 | b    | NULL | NULL |
+----+------+------+----+------+
EXPLAIN select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |0        |86  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | SORT           |    |6        |44  |
|3 |  SUBPLAN SCAN  |v   |6        |38  |
|4 |   TABLE SCAN   |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([v.c2 <=> NULL], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  3 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null);
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
|  3 |    5 | b    | NULL | NULL |
+----+------+------+----+------+
EXPLAIN insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |0        |85  |
|1 | SUBPLAN SCAN     |VIEW1|0        |85  |
|2 |  MERGE OUTER JOIN|     |0        |85  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   SORT           |     |6        |43  |
|5 |    TABLE SCAN    |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter([t1.c2 <=> NULL], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null));

rollback;
EXPLAIN insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |0        |86  |
|1 | SUBPLAN SCAN     |VIEW1|0        |86  |
|2 |  MERGE OUTER JOIN|     |0        |86  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   SORT           |     |6        |44  |
|5 |    SUBPLAN SCAN  |v    |6        |38  |
|6 |     TABLE SCAN   |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([v.c2 <=> NULL], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  5 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null));

rollback;
EXPLAIN update t1 set c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |129 |
|1 | SUBPLAN FILTER   |    |6        |123 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |0        |85  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |43  |
|6 |    TABLE SCAN    |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter([t1.c2 <=> NULL], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |129 |
|1 | SUBPLAN FILTER   |    |6        |123 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |0        |86  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |44  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([v.c1]), filter([v.c2 <=> NULL], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |123 |
|1 | SUBPLAN FILTER   |    |1        |122 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |0        |85  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |43  |
|6 |    TABLE SCAN    |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter([t1.c2 <=> NULL], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |124 |
|1 | SUBPLAN FILTER   |    |1        |123 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |0        |86  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |44  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([v.c1]), filter([v.c2 <=> NULL], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (v.c2 <=> null));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

##case arithmatic and basic compare
EXPLAIN select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |0        |38  |
|1 | TABLE SCAN     |t1  |0        |38  |
|2 | TABLE GET      |t2  |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c2])
  1 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [t1.c2 + 2 > 1 + 2 < 0]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0);
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
+----+------+------+----+------+
EXPLAIN select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |2        |86  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | SORT           |    |6        |44  |
|3 |  SUBPLAN SCAN  |v   |6        |38  |
|4 |   TABLE SCAN   |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([v.c2 + 2 > 1 + 2 < 0], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  3 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0);
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
+----+------+------+----+------+
EXPLAIN insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |0        |38  |
|1 | SUBPLAN SCAN     |VIEW1|0        |38  |
|2 |  NESTED-LOOP JOIN|     |0        |38  |
|3 |   TABLE SCAN     |t1   |0        |38  |
|4 |   TABLE GET      |t2   |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c2])
  3 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [t1.c2 + 2 > 1 + 2 < 0]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0));

rollback;
EXPLAIN insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |2        |86  |
|1 | SUBPLAN SCAN     |VIEW1|2        |86  |
|2 |  MERGE OUTER JOIN|     |2        |86  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   SORT           |     |6        |44  |
|5 |    SUBPLAN SCAN  |v    |6        |38  |
|6 |     TABLE SCAN   |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([v.c2 + 2 > 1 + 2 < 0], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  5 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0));

rollback;
EXPLAIN update t1 set c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |82  |
|1 | SUBPLAN FILTER   |    |6        |76  |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  NESTED-LOOP JOIN|    |0        |38  |
|4 |   TABLE SCAN     |t1  |0        |38  |
|5 |   TABLE GET      |t2  |1        |36  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c2])
  4 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [t1.c2 + 2 > 1 + 2 < 0]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |129 |
|1 | SUBPLAN FILTER   |    |6        |123 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |2        |86  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |44  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([v.c1]), filter([v.c2 + 2 > 1 + 2 < 0], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |77  |
|1 | SUBPLAN FILTER   |    |1        |76  |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  NESTED-LOOP JOIN|    |0        |38  |
|4 |   TABLE SCAN     |t1  |0        |38  |
|5 |   TABLE GET      |t2  |1        |36  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c2])
  4 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [t1.c2 + 2 > 1 + 2 < 0]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |124 |
|1 | SUBPLAN FILTER   |    |1        |123 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |2        |86  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |44  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([v.c1]), filter([v.c2 + 2 > 1 + 2 < 0], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and ((v.c2 + 2 > 1) + 2 < 0));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

##case should not be eliminated
EXPLAIN select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |5        |85  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | SORT           |    |6        |43  |
|3 |  TABLE SCAN    |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [(T_OP_NOT, t1.c2) OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false));
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
|  3 |    5 | b    | NULL | NULL |
+----+------+------+----+------+
EXPLAIN select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |5        |86  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | SORT           |    |6        |44  |
|3 |  SUBPLAN SCAN  |v   |6        |38  |
|4 |   TABLE SCAN   |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([(T_OP_IS, v.c2, NULL, 0)], [(T_OP_NOT, v.c2) OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  3 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false));
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
|  3 |    5 | b    | NULL | NULL |
+----+------+------+----+------+
EXPLAIN insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false)));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |5        |86  |
|1 | SUBPLAN SCAN     |VIEW1|5        |86  |
|2 |  MERGE OUTER JOIN|     |5        |85  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   SORT           |     |6        |43  |
|5 |    TABLE SCAN    |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [(T_OP_NOT, t1.c2) OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false)));

rollback;
EXPLAIN insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false)));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |5        |87  |
|1 | SUBPLAN SCAN     |VIEW1|5        |87  |
|2 |  MERGE OUTER JOIN|     |5        |86  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   SORT           |     |6        |44  |
|5 |    SUBPLAN SCAN  |v    |6        |38  |
|6 |     TABLE SCAN   |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([(T_OP_IS, v.c2, NULL, 0)], [(T_OP_NOT, v.c2) OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  5 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false)));

rollback;
EXPLAIN update t1 set c2 = (select t2.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |127 |
|1 | SUBPLAN FILTER   |    |6        |121 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |5        |84  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |42  |
|6 |    TABLE SCAN    |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter([(T_OP_IS, t1.c2, NULL, 0)], [(T_OP_NOT, t1.c2) OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

update t1 set c2 = (select t2.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |128 |
|1 | SUBPLAN FILTER   |    |6        |122 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |5        |85  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |43  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter([(T_OP_IS, v.c2, NULL, 0)], [(T_OP_NOT, v.c2) OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2]), filter(nil), 
      access([v.c2])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t2.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |122 |
|1 | SUBPLAN FILTER   |    |1        |121 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |5        |84  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |42  |
|6 |    TABLE SCAN    |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter([(T_OP_IS, t1.c2, NULL, 0)], [(T_OP_NOT, t1.c2) OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

delete from t1 where c2 = (select t2.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |123 |
|1 | SUBPLAN FILTER   |    |1        |122 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |5        |85  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |43  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter([(T_OP_IS, v.c2, NULL, 0)], [(T_OP_NOT, v.c2) OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2]), filter(nil), 
      access([v.c2])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not(v.c2 and false)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

##case should not be eliminated
EXPLAIN select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |5        |85  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | SORT           |    |6        |43  |
|3 |  TABLE SCAN    |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [? <= t1.c2 OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false));
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
|  3 |    5 | b    | NULL | NULL |
+----+------+------+----+------+
EXPLAIN select /*+ NO_REWRITE */* from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |5        |86  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | SORT           |    |6        |44  |
|3 |  SUBPLAN SCAN  |v   |6        |38  |
|4 |   TABLE SCAN   |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([(T_OP_IS, v.c2, NULL, 0)], [? <= v.c2 OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  3 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false));
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
|  3 |    5 | b    | NULL | NULL |
+----+------+------+----+------+
EXPLAIN insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false)));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |5        |86  |
|1 | SUBPLAN SCAN     |VIEW1|5        |86  |
|2 |  MERGE OUTER JOIN|     |5        |85  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   SORT           |     |6        |43  |
|5 |    TABLE SCAN    |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [? <= t1.c2 OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false)));

rollback;
EXPLAIN insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false)));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |5        |87  |
|1 | SUBPLAN SCAN     |VIEW1|5        |87  |
|2 |  MERGE OUTER JOIN|     |5        |86  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   SORT           |     |6        |44  |
|5 |    SUBPLAN SCAN  |v    |6        |38  |
|6 |     TABLE SCAN   |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([(T_OP_IS, v.c2, NULL, 0)], [? <= v.c2 OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  5 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false)));

rollback;
EXPLAIN update t1 set c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |129 |
|1 | SUBPLAN FILTER   |    |6        |123 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |5        |85  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |43  |
|6 |    TABLE SCAN    |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter([(T_OP_IS, t1.c2, NULL, 0)], [? <= t1.c2 OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |129 |
|1 | SUBPLAN FILTER   |    |6        |123 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |5        |86  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |44  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([v.c1]), filter([(T_OP_IS, v.c2, NULL, 0)], [? <= v.c2 OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |123 |
|1 | SUBPLAN FILTER   |    |1        |122 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |5        |85  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |43  |
|6 |    TABLE SCAN    |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter([(T_OP_IS, t1.c2, NULL, 0)], [? <= t1.c2 OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |124 |
|1 | SUBPLAN FILTER   |    |1        |123 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |5        |86  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |44  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([v.c1]), filter([(T_OP_IS, v.c2, NULL, 0)], [? <= v.c2 OR (T_OP_NOT, ?)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (not((1 + 2 > v.c2) and false)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

##case should not be eliminated
EXPLAIN select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |2        |85  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | SORT           |    |6        |43  |
|3 |  TABLE SCAN    |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter([? > t1.c2 AND ? + 2 > -2], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2);
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
|  3 |    5 | b    | NULL | NULL |
+----+------+------+----+------+
EXPLAIN select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |2        |86  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | SORT           |    |6        |44  |
|3 |  SUBPLAN SCAN  |v   |6        |38  |
|4 |   TABLE SCAN   |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([? > v.c2 AND ? + 2 > -2], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  3 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2);
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
|  3 |    5 | b    | NULL | NULL |
+----+------+------+----+------+
EXPLAIN insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |2        |86  |
|1 | SUBPLAN SCAN     |VIEW1|2        |85  |
|2 |  MERGE OUTER JOIN|     |2        |85  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   SORT           |     |6        |43  |
|5 |    TABLE SCAN    |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter([? > t1.c2 AND ? + 2 > -2], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2));

rollback;
EXPLAIN insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |2        |86  |
|1 | SUBPLAN SCAN     |VIEW1|2        |86  |
|2 |  MERGE OUTER JOIN|     |2        |86  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   SORT           |     |6        |44  |
|5 |    SUBPLAN SCAN  |v    |6        |38  |
|6 |     TABLE SCAN   |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([? > v.c2 AND ? + 2 > -2], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  5 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2));

rollback;
EXPLAIN update t1 set c2 = (select t2.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |127 |
|1 | SUBPLAN FILTER   |    |6        |121 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |2        |84  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |42  |
|6 |    TABLE SCAN    |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter([? > t1.c2 AND ? + 2 > -2], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

update t1 set c2 = (select t2.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |128 |
|1 | SUBPLAN FILTER   |    |6        |122 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |2        |85  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |43  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter([? > v.c2 AND ? + 2 > -2], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2]), filter(nil), 
      access([v.c2])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t2.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |122 |
|1 | SUBPLAN FILTER   |    |1        |121 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |2        |84  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |42  |
|6 |    TABLE SCAN    |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter([? > t1.c2 AND ? + 2 > -2], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

delete from t1 where c2 = (select t2.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |123 |
|1 | SUBPLAN FILTER   |    |1        |122 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |2        |85  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |43  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter([? > v.c2 AND ? + 2 > -2], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2]), filter(nil), 
      access([v.c2])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (((1 + 2 > v.c2) and false) + 2 > -2));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

##case arithmatic operator
EXPLAIN select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |0        |39  |
|1 | TABLE SCAN     |t1  |0        |39  |
|2 | TABLE GET      |t2  |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c2])
  1 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [? > t1.c2]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2);
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
+----+------+------+----+------+
EXPLAIN select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |3        |86  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | SORT           |    |6        |44  |
|3 |  SUBPLAN SCAN  |v   |6        |38  |
|4 |   TABLE SCAN   |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([? > v.c2], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  3 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2);
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
+----+------+------+----+------+
EXPLAIN insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |0        |39  |
|1 | SUBPLAN SCAN     |VIEW1|0        |39  |
|2 |  NESTED-LOOP JOIN|     |0        |39  |
|3 |   TABLE SCAN     |t1   |0        |39  |
|4 |   TABLE GET      |t2   |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c2])
  3 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [? > t1.c2]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2));

rollback;
EXPLAIN insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |3        |87  |
|1 | SUBPLAN SCAN     |VIEW1|3        |86  |
|2 |  MERGE OUTER JOIN|     |3        |86  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   SORT           |     |6        |44  |
|5 |    SUBPLAN SCAN  |v    |6        |38  |
|6 |     TABLE SCAN   |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([? > v.c2], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  5 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2));

rollback;
EXPLAIN update t1 set c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |83  |
|1 | SUBPLAN FILTER   |    |6        |77  |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  NESTED-LOOP JOIN|    |0        |39  |
|4 |   TABLE SCAN     |t1  |0        |39  |
|5 |   TABLE GET      |t2  |1        |36  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c2])
  4 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [? > t1.c2]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |129 |
|1 | SUBPLAN FILTER   |    |6        |123 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |3        |86  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |44  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([v.c1]), filter([? > v.c2], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |77  |
|1 | SUBPLAN FILTER   |    |1        |76  |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  NESTED-LOOP JOIN|    |0        |39  |
|4 |   TABLE SCAN     |t1  |0        |39  |
|5 |   TABLE GET      |t2  |1        |36  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c2])
  4 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [? > t1.c2]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |124 |
|1 | SUBPLAN FILTER   |    |1        |123 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |3        |86  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |44  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([v.c1]), filter([? > v.c2], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > v.c2));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

##case
EXPLAIN select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |2        |85  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | SORT           |    |6        |43  |
|3 |  TABLE SCAN    |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter([? > (T_OP_IS_NOT, t1.c2, NULL, 0)], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null));
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
|  3 |    5 | b    | NULL | NULL |
+----+------+------+----+------+
EXPLAIN select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |2        |86  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | SORT           |    |6        |44  |
|3 |  SUBPLAN SCAN  |v   |6        |38  |
|4 |   TABLE SCAN   |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([? > (T_OP_IS_NOT, v.c2, NULL, 0)], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  3 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null));
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
|  3 |    5 | b    | NULL | NULL |
+----+------+------+----+------+
EXPLAIN insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null)));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |2        |86  |
|1 | SUBPLAN SCAN     |VIEW1|2        |85  |
|2 |  MERGE OUTER JOIN|     |2        |85  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   SORT           |     |6        |43  |
|5 |    TABLE SCAN    |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter([? > (T_OP_IS_NOT, t1.c2, NULL, 0)], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null)));

rollback;
EXPLAIN insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null)));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |2        |86  |
|1 | SUBPLAN SCAN     |VIEW1|2        |86  |
|2 |  MERGE OUTER JOIN|     |2        |86  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   SORT           |     |6        |44  |
|5 |    SUBPLAN SCAN  |v    |6        |38  |
|6 |     TABLE SCAN   |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([? > (T_OP_IS_NOT, v.c2, NULL, 0)], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  5 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null)));

rollback;
EXPLAIN update t1 set c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |129 |
|1 | SUBPLAN FILTER   |    |6        |123 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |2        |85  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |43  |
|6 |    TABLE SCAN    |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter([? > (T_OP_IS_NOT, t1.c2, NULL, 0)], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |129 |
|1 | SUBPLAN FILTER   |    |6        |123 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |2        |86  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |44  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([v.c1]), filter([? > (T_OP_IS_NOT, v.c2, NULL, 0)], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |123 |
|1 | SUBPLAN FILTER   |    |1        |122 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |2        |85  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |43  |
|6 |    TABLE SCAN    |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter([? > (T_OP_IS_NOT, t1.c2, NULL, 0)], [(T_OP_IS, t1.c2, NULL, 0)]), 
      equal_conds([t2.c1 = t1.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select v.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |124 |
|1 | SUBPLAN FILTER   |    |1        |123 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |2        |86  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |44  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([v.c1]), filter([? > (T_OP_IS_NOT, v.c2, NULL, 0)], [(T_OP_IS, v.c2, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */v.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

##case
EXPLAIN select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |0        |39  |
|1 | TABLE SCAN     |t1  |0        |39  |
|2 | TABLE GET      |t2  |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c2])
  1 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [? > (T_OP_IS_NOT, t1.c2, NULL, 0)]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null));
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
+----+------+------+----+------+
EXPLAIN select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |2        |86  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | SORT           |    |6        |44  |
|3 |  SUBPLAN SCAN  |v   |6        |38  |
|4 |   TABLE SCAN   |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([? > (T_OP_IS_NOT, v.c2, NULL, 0)], [(T_OP_IS, v.c2, NULL, 0)], [(T_OP_IS_NOT, v.c1, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  3 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null));
+----+------+------+----+------+
| c1 | c2   | c3   | c1 | c2   |
+----+------+------+----+------+
+----+------+------+----+------+
EXPLAIN insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null)));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |0        |39  |
|1 | SUBPLAN SCAN     |VIEW1|0        |39  |
|2 |  NESTED-LOOP JOIN|     |0        |39  |
|3 |   TABLE SCAN     |t1   |0        |39  |
|4 |   TABLE GET      |t2   |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c2])
  3 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [? > (T_OP_IS_NOT, t1.c2, NULL, 0)]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t1_temp (select * from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null)));

rollback;
EXPLAIN insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null)));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |2        |86  |
|1 | SUBPLAN SCAN     |VIEW1|2        |86  |
|2 |  MERGE OUTER JOIN|     |2        |86  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   SORT           |     |6        |44  |
|5 |    SUBPLAN SCAN  |v    |6        |38  |
|6 |     TABLE SCAN   |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2]), filter([? > (T_OP_IS_NOT, v.c2, NULL, 0)], [(T_OP_IS, v.c2, NULL, 0)], [(T_OP_IS_NOT, v.c1, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  5 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select /*+ NO_REWRITE */* from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null)));

rollback;
EXPLAIN update t1 set c2 = (select t2.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |83  |
|1 | SUBPLAN FILTER   |    |6        |77  |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  NESTED-LOOP JOIN|    |0        |39  |
|4 |   TABLE SCAN     |t1  |0        |39  |
|5 |   TABLE GET      |t2  |1        |36  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c2])
  4 - output([t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [? > (T_OP_IS_NOT, t1.c2, NULL, 0)]), 
      access([t1.c2]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t2.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |129 |
|1 | SUBPLAN FILTER   |    |6        |123 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |2        |86  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |44  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter([? > (T_OP_IS_NOT, v.c2, NULL, 0)], [(T_OP_IS, v.c2, NULL, 0)], [(T_OP_IS_NOT, v.c1, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c2], [v.c1]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t2.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |77  |
|1 | SUBPLAN FILTER   |    |1        |76  |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  NESTED-LOOP JOIN|    |0        |39  |
|4 |   TABLE SCAN     |t1  |0        |39  |
|5 |   TABLE GET      |t2  |1        |36  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c2])
  4 - output([t1.c2]), filter([(T_OP_IS, t1.c2, NULL, 0)], [? > (T_OP_IS_NOT, t1.c2, NULL, 0)]), 
      access([t1.c2]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t2.c1 from t2 left join (select * from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null)));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |124 |
|1 | SUBPLAN FILTER   |    |1        |123 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |2        |86  |
|4 |   TABLE SCAN     |t2  |6        |37  |
|5 |   SORT           |    |6        |44  |
|6 |    SUBPLAN SCAN  |v   |6        |38  |
|7 |     TABLE SCAN   |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter([? > (T_OP_IS_NOT, v.c2, NULL, 0)], [(T_OP_IS, v.c2, NULL, 0)], [(T_OP_IS_NOT, v.c1, NULL, 0)]), 
      equal_conds([t2.c1 = v.c2]), other_conds(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([v.c2], [v.c1]), filter(nil), sort_keys([v.c2, ASC])
  6 - output([v.c2], [v.c1]), filter(nil), 
      access([v.c2], [v.c1])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join (select /*+ NO_REWRITE */* from t1) as v  on t2.c1 = v.c2 where (v.c2 is null) and (1 + 2 > (v.c2 is not null) and (v.c1 is not null)));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

##case
EXPLAIN select * from t1 left join t2 using(c1) where (t2.c1 is not null)=0;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |1        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0) = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 using(c1) where (t2.c1 is not null)=0;
+----+------+------+------+
| c1 | c2   | c2   | c3   |
+----+------+------+------+
+----+------+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 is not null)=0;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |1        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0) = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 is not null)=0;
+----+------+------+------+
| c1 | c2   | c2   | c3   |
+----+------+------+------+
+----+------+------+------+
EXPLAIN insert into t3_temp (select * from t1 left join t2 using(c1) where (t2.c1 is not null)=0);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |1        |80  |
|1 | SUBPLAN SCAN     |VIEW1|1        |80  |
|2 |  MERGE OUTER JOIN|     |1        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t3_temp: ({t3_temp: (t3_temp.__pk_increment, t3_temp.a, t3_temp.b, t3_temp.c, t3_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0) = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t3_temp (select * from t1 left join t2 using(c1) where (t2.c1 is not null)=0);

rollback;
EXPLAIN insert into t3_temp (select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 is not null)=0);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |1        |80  |
|1 | SUBPLAN SCAN     |VIEW1|1        |80  |
|2 |  MERGE OUTER JOIN|     |1        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t3_temp: ({t3_temp: (t3_temp.__pk_increment, t3_temp.a, t3_temp.b, t3_temp.c, t3_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0) = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t3_temp (select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 is not null)=0);

rollback;
EXPLAIN update t1 set c2 = (select t2.c1 from t1 left join t2 using(c1) where (t2.c1 is not null)=0);
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |123 |
|1 | SUBPLAN FILTER   |    |6        |117 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |1        |79  |
|4 |   TABLE SCAN     |t1  |6        |37  |
|5 |   TABLE SCAN     |t2  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0) = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t2.c1 from t1 left join t2 using(c1) where (t2.c1 is not null)=0);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t2.c1 from t1 left join t2 using(c1) where (t2.c1 is not null)=0);
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |123 |
|1 | SUBPLAN FILTER   |    |6        |117 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |1        |79  |
|4 |   TABLE SCAN     |t1  |6        |37  |
|5 |   TABLE SCAN     |t2  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0) = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t2.c1 from t1 left join t2 using(c1) where (t2.c1 is not null)=0);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t2.c1 from t1 left join t2 using(c1) where (t2.c1 is not null)=0);
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |118 |
|1 | SUBPLAN FILTER   |    |1        |117 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |1        |79  |
|4 |   TABLE SCAN     |t1  |6        |37  |
|5 |   TABLE SCAN     |t2  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0) = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t2.c1 from t1 left join t2 using(c1) where (t2.c1 is not null)=0);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t1 left join t2 using(c1) where (t2.c1 is not null)=0);
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |118 |
|1 | SUBPLAN FILTER   |    |1        |117 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |1        |79  |
|4 |   TABLE SCAN     |t1  |6        |37  |
|5 |   TABLE SCAN     |t2  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0) = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t1 left join t2 using(c1) where (t2.c1 is not null)=0);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

##case:
EXPLAIN select * from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |36       |102 |
|1 | TABLE SCAN               |t2  |6        |37  |
|2 | MATERIAL                 |    |6        |40  |
|3 |  TABLE SCAN              |t1  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null);
+----+------+------+------+
| c1 | c2   | c2   | c3   |
+----+------+------+------+
+----+------+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |5        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null);
+----+------+------+------+
| c1 | c2   | c2   | c3   |
+----+------+------+------+
+----+------+------+------+
EXPLAIN insert into t3_temp (select * from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null));
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |36       |112 |
|1 | SUBPLAN SCAN               |VIEW1|36       |107 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |36       |102 |
|3 |   TABLE SCAN               |t2   |6        |37  |
|4 |   MATERIAL                 |     |6        |40  |
|5 |    TABLE SCAN              |t1   |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t3_temp: ({t3_temp: (t3_temp.__pk_increment, t3_temp.a, t3_temp.b, t3_temp.c, t3_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t3_temp (select * from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null));

rollback;
EXPLAIN insert into t3_temp (select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |5        |81  |
|1 | SUBPLAN SCAN     |VIEW1|5        |80  |
|2 |  MERGE OUTER JOIN|     |5        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t3_temp: ({t3_temp: (t3_temp.__pk_increment, t3_temp.a, t3_temp.b, t3_temp.c, t3_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t3_temp (select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null));
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |UPDATE                      |    |6        |144 |
|1 | SUBPLAN FILTER             |    |6        |138 |
|2 |  TABLE SCAN                |t1  |6        |37  |
|3 |  NESTED-LOOP JOIN CARTESIAN|    |36       |100 |
|4 |   TABLE SCAN               |t1  |6        |37  |
|5 |   MATERIAL                 |    |6        |38  |
|6 |    TABLE SCAN              |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([1]), filter(nil)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |123 |
|1 | SUBPLAN FILTER   |    |6        |117 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |5        |79  |
|4 |   TABLE SCAN     |t1  |6        |37  |
|5 |   TABLE SCAN     |t2  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t2.c1 from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null));
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |DELETE                      |    |1        |139 |
|1 | SUBPLAN FILTER             |    |1        |138 |
|2 |  TABLE SCAN                |t1  |1        |38  |
|3 |  NESTED-LOOP JOIN CARTESIAN|    |36       |100 |
|4 |   TABLE SCAN               |t1  |6        |37  |
|5 |   MATERIAL                 |    |6        |38  |
|6 |    TABLE SCAN              |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  4 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t2.c1 from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |118 |
|1 | SUBPLAN FILTER   |    |1        |117 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |5        |79  |
|4 |   TABLE SCAN     |t1  |6        |37  |
|5 |   TABLE SCAN     |t2  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t1 left join t2 using(c1) where (t2.c1 is not null) and (t2.c1 is null));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

##case
EXPLAIN select * from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |36       |102 |
|1 | TABLE SCAN               |t2  |6        |37  |
|2 | MATERIAL                 |    |6        |40  |
|3 |  TABLE SCAN              |t1  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0);
+----+------+------+------+
| c1 | c2   | c2   | c3   |
+----+------+------+------+
+----+------+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |1        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter([t2.c1 > 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0);
+----+------+------+------+
| c1 | c2   | c2   | c3   |
+----+------+------+------+
+----+------+------+------+
EXPLAIN insert into t3_temp (select * from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0));
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |36       |112 |
|1 | SUBPLAN SCAN               |VIEW1|36       |107 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |36       |102 |
|3 |   TABLE SCAN               |t2   |6        |37  |
|4 |   MATERIAL                 |     |6        |40  |
|5 |    TABLE SCAN              |t1   |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t3_temp: ({t3_temp: (t3_temp.__pk_increment, t3_temp.a, t3_temp.b, t3_temp.c, t3_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t3_temp (select * from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0));

rollback;
EXPLAIN insert into t3_temp (select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |1        |80  |
|1 | SUBPLAN SCAN     |VIEW1|1        |80  |
|2 |  MERGE OUTER JOIN|     |1        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t3_temp: ({t3_temp: (t3_temp.__pk_increment, t3_temp.a, t3_temp.b, t3_temp.c, t3_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter([t2.c1 > 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t3_temp (select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0));
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |UPDATE                      |    |6        |144 |
|1 | SUBPLAN FILTER             |    |6        |138 |
|2 |  TABLE SCAN                |t1  |6        |37  |
|3 |  NESTED-LOOP JOIN CARTESIAN|    |36       |100 |
|4 |   TABLE SCAN               |t1  |6        |37  |
|5 |   MATERIAL                 |    |6        |38  |
|6 |    TABLE SCAN              |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([1]), filter(nil)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE            |    |6        |123 |
|1 | SUBPLAN FILTER   |    |6        |117 |
|2 |  TABLE SCAN      |t1  |6        |37  |
|3 |  MERGE OUTER JOIN|    |1        |79  |
|4 |   TABLE SCAN     |t1  |6        |37  |
|5 |   TABLE SCAN     |t2  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter([t2.c1 > 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0));
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |DELETE                      |    |1        |139 |
|1 | SUBPLAN FILTER             |    |1        |138 |
|2 |  TABLE SCAN                |t1  |1        |38  |
|3 |  NESTED-LOOP JOIN CARTESIAN|    |36       |100 |
|4 |   TABLE SCAN               |t1  |6        |37  |
|5 |   MATERIAL                 |    |6        |38  |
|6 |    TABLE SCAN              |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([1]), filter(nil)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0));
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |DELETE            |    |1        |118 |
|1 | SUBPLAN FILTER   |    |1        |117 |
|2 |  TABLE SCAN      |t1  |1        |38  |
|3 |  MERGE OUTER JOIN|    |1        |79  |
|4 |   TABLE SCAN     |t1  |6        |37  |
|5 |   TABLE SCAN     |t2  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter([t2.c1 > 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 using(c1) where (t2.c1 is null) and (t2.c1 > 0));
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

##case null and false     and parent is not and
EXPLAIN select * from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |2        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter([t2.c1 AND ? < ?]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1;
+----+------+------+------+
| c1 | c2   | c2   | c3   |
+----+------+------+------+
|  1 |    1 |    1 | o    |
|  2 |    5 |    5 | c    |
|  3 |    2 |    5 | b    |
|  4 |    6 |    6 | o    |
|  5 |    4 |    7 | d    |
|  6 |    7 |    8 | c    |
+----+------+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |2        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter([t2.c1 AND ? < ?]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1;
+----+------+------+------+
| c1 | c2   | c2   | c3   |
+----+------+------+------+
|  1 |    1 |    1 | o    |
|  2 |    5 |    5 | c    |
|  3 |    2 |    5 | b    |
|  4 |    6 |    6 | o    |
|  5 |    4 |    7 | d    |
|  6 |    7 |    8 | c    |
+----+------+------+------+
EXPLAIN insert into t3_temp (select * from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |2        |80  |
|1 | SUBPLAN SCAN     |VIEW1|2        |80  |
|2 |  MERGE OUTER JOIN|     |2        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t3_temp: ({t3_temp: (t3_temp.__pk_increment, t3_temp.a, t3_temp.b, t3_temp.c, t3_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter([t2.c1 AND ? < ?]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t3_temp (select * from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1);

rollback;
EXPLAIN insert into t3_temp (select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |2        |80  |
|1 | SUBPLAN SCAN     |VIEW1|2        |80  |
|2 |  MERGE OUTER JOIN|     |2        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t3_temp: ({t3_temp: (t3_temp.__pk_increment, t3_temp.a, t3_temp.b, t3_temp.c, t3_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter([t2.c1 AND ? < ?]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t3_temp (select /*+ NO_REWRITE */* from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |120 |
|1 | SUBPLAN FILTER    |    |6        |114 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |76  |
|4 |   MERGE OUTER JOIN|    |1        |76  |
|5 |    TABLE SCAN     |t1  |5        |37  |
|6 |    TABLE SCAN     |t2  |5        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 AND ? < ?]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |120 |
|1 | SUBPLAN FILTER    |    |6        |114 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |76  |
|4 |   MERGE OUTER JOIN|    |1        |76  |
|5 |    TABLE SCAN     |t1  |5        |37  |
|6 |    TABLE SCAN     |t2  |5        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 AND ? < ?]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |115 |
|1 | SUBPLAN FILTER    |    |1        |114 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |76  |
|4 |   MERGE OUTER JOIN|    |1        |76  |
|5 |    TABLE SCAN     |t1  |5        |37  |
|6 |    TABLE SCAN     |t2  |5        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 AND ? < ?]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |115 |
|1 | SUBPLAN FILTER    |    |1        |114 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |76  |
|4 |   MERGE OUTER JOIN|    |1        |76  |
|5 |    TABLE SCAN     |t1  |5        |37  |
|6 |    TABLE SCAN     |t2  |5        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 AND ? < ?]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 using(c1) where (t2.c1 and false) < 1 + 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

##case
EXPLAIN select * from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |6        |263 |
|1 | TABLE SCAN           |t1  |6        |37  |
|2 | TABLE SCAN           |t2  |2        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([lnnvl(cast(t2.c2, TINYINT(-1, 0)))]), 
      conds(nil), nl_params_([t1.c1])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 | NULL | NULL | NULL |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |6        |263 |
|1 | TABLE SCAN           |t1  |6        |37  |
|2 | TABLE SCAN           |t2  |2        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([lnnvl(cast(t2.c2, TINYINT(-1, 0)))]), startup_filter([1]), 
      conds(nil), nl_params_([t1.c1])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 | NULL | NULL | NULL |
+----+------+----+------+------+
EXPLAIN insert into t1_temp (select * from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |6        |265 |
|1 | SUBPLAN SCAN           |VIEW1|6        |264 |
|2 |  NESTED-LOOP OUTER JOIN|     |6        |263 |
|3 |   TABLE SCAN           |t1   |6        |37  |
|4 |   TABLE SCAN           |t2   |2        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,cast(VIEW1.c1, VARCHAR(1048576)))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,cast(VIEW1.c3, INT(-1, 0)))]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([lnnvl(cast(t2.c2, TINYINT(-1, 0)))]), 
      conds(nil), nl_params_([t1.c1])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t1_temp (select * from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0);

rollback;
EXPLAIN insert into t1_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |6        |265 |
|1 | SUBPLAN SCAN           |VIEW1|6        |264 |
|2 |  NESTED-LOOP OUTER JOIN|     |6        |263 |
|3 |   TABLE SCAN           |t1   |6        |37  |
|4 |   TABLE SCAN           |t2   |2        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,cast(VIEW1.c1, VARCHAR(1048576)))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,cast(VIEW1.c3, INT(-1, 0)))]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([1]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([lnnvl(cast(t2.c2, TINYINT(-1, 0)))]), 
      conds(nil), nl_params_([t1.c1])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t1_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |6        |306 |
|1 | SUBPLAN FILTER         |    |6        |300 |
|2 |  TABLE SCAN            |t1  |6        |37  |
|3 |  NESTED-LOOP OUTER JOIN|    |6        |262 |
|4 |   TABLE SCAN           |t1  |6        |37  |
|5 |   TABLE SCAN           |t2  |2        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter([lnnvl(cast(t2.c2, TINYINT(-1, 0)))]), 
      conds(nil), nl_params_([t1.c1])
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |6        |306 |
|1 | SUBPLAN FILTER         |    |6        |300 |
|2 |  TABLE SCAN            |t1  |6        |37  |
|3 |  NESTED-LOOP OUTER JOIN|    |6        |262 |
|4 |   TABLE SCAN           |t1  |6        |37  |
|5 |   TABLE SCAN           |t2  |2        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter([lnnvl(cast(t2.c2, TINYINT(-1, 0)))]), startup_filter([1]), 
      conds(nil), nl_params_([t1.c1])
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t2.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |301 |
|1 | SUBPLAN FILTER         |    |1        |300 |
|2 |  TABLE SCAN            |t1  |1        |38  |
|3 |  NESTED-LOOP OUTER JOIN|    |6        |262 |
|4 |   TABLE SCAN           |t1  |6        |37  |
|5 |   TABLE SCAN           |t2  |2        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter([lnnvl(cast(t2.c2, TINYINT(-1, 0)))]), 
      conds(nil), nl_params_([t1.c1])
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select t2.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |301 |
|1 | SUBPLAN FILTER         |    |1        |300 |
|2 |  TABLE SCAN            |t1  |1        |38  |
|3 |  NESTED-LOOP OUTER JOIN|    |6        |262 |
|4 |   TABLE SCAN           |t1  |6        |37  |
|5 |   TABLE SCAN           |t2  |2        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter([lnnvl(cast(t2.c2, TINYINT(-1, 0)))]), startup_filter([1]), 
      conds(nil), nl_params_([t1.c1])
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2) and 1 > 0);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

##case
EXPLAIN select * from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |6        |263 |
|1 | TABLE SCAN           |t1  |6        |37  |
|2 | TABLE SCAN           |t2  |2        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([lnnvl(cast(t2.c2 + 2 - 1, TINYINT(-1, 0)))]), 
      conds(nil), nl_params_([t1.c1])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 | NULL | NULL | NULL |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |6        |263 |
|1 | TABLE SCAN           |t1  |6        |37  |
|2 | TABLE SCAN           |t2  |2        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([lnnvl(cast(t2.c2 + 2 - 1, TINYINT(-1, 0)))]), startup_filter([1]), 
      conds(nil), nl_params_([t1.c1])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 | NULL | NULL | NULL |
+----+------+----+------+------+
EXPLAIN insert into t1_temp (select * from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |6        |265 |
|1 | SUBPLAN SCAN           |VIEW1|6        |264 |
|2 |  NESTED-LOOP OUTER JOIN|     |6        |263 |
|3 |   TABLE SCAN           |t1   |6        |37  |
|4 |   TABLE SCAN           |t2   |2        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,cast(VIEW1.c1, VARCHAR(1048576)))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,cast(VIEW1.c3, INT(-1, 0)))]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([lnnvl(cast(t2.c2 + 2 - 1, TINYINT(-1, 0)))]), 
      conds(nil), nl_params_([t1.c1])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t1_temp (select * from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0);

rollback;
EXPLAIN insert into t1_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |6        |265 |
|1 | SUBPLAN SCAN           |VIEW1|6        |264 |
|2 |  NESTED-LOOP OUTER JOIN|     |6        |263 |
|3 |   TABLE SCAN           |t1   |6        |37  |
|4 |   TABLE SCAN           |t2   |2        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,cast(VIEW1.c1, VARCHAR(1048576)))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,cast(VIEW1.c3, INT(-1, 0)))]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.c, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([1]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([lnnvl(cast(t2.c2 + 2 - 1, TINYINT(-1, 0)))]), 
      conds(nil), nl_params_([t1.c1])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t1_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |6        |306 |
|1 | SUBPLAN FILTER         |    |6        |300 |
|2 |  TABLE SCAN            |t1  |6        |37  |
|3 |  NESTED-LOOP OUTER JOIN|    |6        |262 |
|4 |   TABLE SCAN           |t1  |6        |37  |
|5 |   TABLE SCAN           |t2  |2        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter([lnnvl(cast(t2.c2 + 2 - 1, TINYINT(-1, 0)))]), 
      conds(nil), nl_params_([t1.c1])
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |6        |306 |
|1 | SUBPLAN FILTER         |    |6        |300 |
|2 |  TABLE SCAN            |t1  |6        |37  |
|3 |  NESTED-LOOP OUTER JOIN|    |6        |262 |
|4 |   TABLE SCAN           |t1  |6        |37  |
|5 |   TABLE SCAN           |t2  |2        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter([lnnvl(cast(t2.c2 + 2 - 1, TINYINT(-1, 0)))]), startup_filter([1]), 
      conds(nil), nl_params_([t1.c1])
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |301 |
|1 | SUBPLAN FILTER         |    |1        |300 |
|2 |  TABLE SCAN            |t1  |1        |38  |
|3 |  NESTED-LOOP OUTER JOIN|    |6        |262 |
|4 |   TABLE SCAN           |t1  |6        |37  |
|5 |   TABLE SCAN           |t2  |2        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter([lnnvl(cast(t2.c2 + 2 - 1, TINYINT(-1, 0)))]), 
      conds(nil), nl_params_([t1.c1])
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |301 |
|1 | SUBPLAN FILTER         |    |1        |300 |
|2 |  TABLE SCAN            |t1  |1        |38  |
|3 |  NESTED-LOOP OUTER JOIN|    |6        |262 |
|4 |   TABLE SCAN           |t1  |6        |37  |
|5 |   TABLE SCAN           |t2  |2        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter([lnnvl(cast(t2.c2 + 2 - 1, TINYINT(-1, 0)))]), startup_filter([1]), 
      conds(nil), nl_params_([t1.c1])
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where lnnvl(t2.c2 + 2 - 1) and 1 > 0);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

##case
EXPLAIN select * from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select c1 from t3 group by c2);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |NESTED-LOOP ANTI JOIN  |     |4        |332 |
|1 | NESTED-LOOP OUTER JOIN|     |12       |263 |
|2 |  TABLE SCAN           |t1   |6        |37  |
|3 |  TABLE SCAN           |t2   |2        |37  |
|4 | MATERIAL              |     |6        |46  |
|5 |  SUBPLAN SCAN         |VIEW1|6        |44  |
|6 |   HASH GROUP BY       |     |6        |44  |
|7 |    TABLE SCAN         |t3   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t2.c1 + 1 <= VIEW1.c1 OR (T_OP_IS, t2.c1 + 1, NULL, 0)]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([VIEW1.c1]), filter(nil)
  5 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  6 - output([t3.c1]), filter(nil), 
      group([t3.c2]), agg_func(nil)
  7 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select c1 from t3 group by c2);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  4 |    6 |  3 |    5 | b    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select /*+ NO_REWRITE */c1 from t3 group by c2);
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |SUBPLAN FILTER         |    |6        |326 |
|1 | NESTED-LOOP OUTER JOIN|    |12       |263 |
|2 |  TABLE SCAN           |t1  |6        |37  |
|3 |  TABLE SCAN           |t2  |2        |37  |
|4 | HASH GROUP BY         |    |6        |44  |
|5 |  TABLE SCAN           |t3  |6        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c1 + 1 > ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1]), filter(nil), 
      group([t3.c2]), agg_func(nil)
  5 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select /*+ NO_REWRITE */c1 from t3 group by c2);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  4 |    6 |  3 |    5 | b    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select c1 from t3 group by c2));
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |4        |333 |
|1 | SUBPLAN SCAN            |VIEW1|4        |333 |
|2 |  NESTED-LOOP ANTI JOIN  |     |4        |332 |
|3 |   NESTED-LOOP OUTER JOIN|     |12       |263 |
|4 |    TABLE SCAN           |t1   |6        |37  |
|5 |    TABLE SCAN           |t2   |2        |37  |
|6 |   MATERIAL              |     |6        |46  |
|7 |    SUBPLAN SCAN         |VIEW2|6        |44  |
|8 |     HASH GROUP BY       |     |6        |44  |
|9 |      TABLE SCAN         |t3   |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t2.c1 + 1 <= VIEW2.c1 OR (T_OP_IS, t2.c1 + 1, NULL, 0)]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([VIEW2.c1]), filter(nil)
  7 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  8 - output([t3.c1]), filter(nil), 
      group([t3.c2]), agg_func(nil)
  9 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select c1 from t3 group by c2));

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select /*+ NO_REWRITE */c1 from t3 group by c2));
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |6        |327 |
|1 | SUBPLAN SCAN            |VIEW1|6        |327 |
|2 |  SUBPLAN FILTER         |     |6        |326 |
|3 |   NESTED-LOOP OUTER JOIN|     |12       |263 |
|4 |    TABLE SCAN           |t1   |6        |37  |
|5 |    TABLE SCAN           |t2   |2        |37  |
|6 |   HASH GROUP BY         |     |6        |44  |
|7 |    TABLE SCAN           |t3   |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c1 + 1 > ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1]), filter(nil), 
      group([t3.c2]), agg_func(nil)
  7 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select /*+ NO_REWRITE */c1 from t3 group by c2));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select c1 from t3 group by c2) and t2.c1=1);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                      |     |6        |155 |
|1 | SUBPLAN FILTER             |     |6        |149 |
|2 |  TABLE SCAN                |t1   |6        |37  |
|3 |  NESTED-LOOP JOIN CARTESIAN|     |2        |111 |
|4 |   NESTED-LOOP ANTI JOIN    |     |1        |98  |
|5 |    TABLE GET               |t2   |1        |52  |
|6 |    SUBPLAN SCAN            |VIEW1|6        |44  |
|7 |     HASH GROUP BY          |     |6        |44  |
|8 |      TABLE SCAN            |t3   |6        |37  |
|9 |   TABLE SCAN               |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([1]), filter(nil), 
      conds([t2.c1 + 1 <= VIEW1.c1 OR (T_OP_IS, t2.c1 + 1, NULL, 0)]), nl_params_(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  7 - output([t3.c1]), filter(nil), 
      group([t3.c2]), agg_func(nil)
  8 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select c1 from t3 group by c2) and t2.c1=1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select /*+ NO_REWRITE */c1 from t3 group by c2) and t2.c1=1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |355 |
|1 | SUBPLAN FILTER          |    |6        |349 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  SUBPLAN FILTER         |    |1        |311 |
|4 |   NESTED-LOOP OUTER JOIN|    |2        |262 |
|5 |    TABLE SCAN           |t1  |6        |37  |
|6 |    TABLE SCAN           |t2  |2        |37  |
|7 |   HASH GROUP BY         |    |6        |44  |
|8 |    TABLE SCAN           |t3  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter([t2.c1 + 1 > ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  4 - output([t1.c1], [t2.c1]), filter([t2.c1 = 1]), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t3.c1]), filter(nil), 
      group([t3.c2]), agg_func(nil)
  8 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select /*+ NO_REWRITE */c1 from t3 group by c2) and t2.c1=1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select c1 from t3 group by c2) and t2.c1=1);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                      |     |1        |150 |
|1 | SUBPLAN FILTER             |     |1        |149 |
|2 |  TABLE SCAN                |t1   |1        |38  |
|3 |  NESTED-LOOP JOIN CARTESIAN|     |2        |111 |
|4 |   NESTED-LOOP ANTI JOIN    |     |1        |98  |
|5 |    TABLE GET               |t2   |1        |52  |
|6 |    SUBPLAN SCAN            |VIEW1|6        |44  |
|7 |     HASH GROUP BY          |     |6        |44  |
|8 |      TABLE SCAN            |t3   |6        |37  |
|9 |   TABLE SCAN               |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([1]), filter(nil), 
      conds([t2.c1 + 1 <= VIEW1.c1 OR (T_OP_IS, t2.c1 + 1, NULL, 0)]), nl_params_(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  7 - output([t3.c1]), filter(nil), 
      group([t3.c2]), agg_func(nil)
  8 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select c1 from t3 group by c2) and t2.c1=1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select /*+ NO_REWRITE */c1 from t3 group by c2) and t2.c1=1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |350 |
|1 | SUBPLAN FILTER          |    |1        |349 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  SUBPLAN FILTER         |    |1        |311 |
|4 |   NESTED-LOOP OUTER JOIN|    |2        |262 |
|5 |    TABLE SCAN           |t1  |6        |37  |
|6 |    TABLE SCAN           |t2  |2        |37  |
|7 |   HASH GROUP BY         |    |6        |44  |
|8 |    TABLE SCAN           |t3  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter([t2.c1 + 1 > ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  4 - output([t1.c1], [t2.c1]), filter([t2.c1 = 1]), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t3.c1]), filter(nil), 
      group([t3.c2]), agg_func(nil)
  8 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 > t2.c1 where t2.c1 + 1 > all(select /*+ NO_REWRITE */c1 from t3 group by c2) and t2.c1=1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

##case
EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |6        |134 |
|1 | TABLE SCAN          |t3  |6        |37  |
|2 | MERGE JOIN          |    |6        |80  |
|3 |  TABLE SCAN         |t1  |6        |37  |
|4 |  TABLE SCAN         |t2  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    | NULL | NULL | NULL |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    | NULL | NULL | NULL |
|  6 |    7 |  6 |    8 | c    | NULL | NULL | NULL |
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |HASH OUTER JOIN  |    |1        |120 |
|1 | MERGE OUTER JOIN|    |1        |80  |
|2 |  TABLE SCAN     |t1  |6        |37  |
|3 |  TABLE SCAN     |t2  |6        |37  |
|4 | TABLE SCAN      |t3  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c1 > 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    | NULL | NULL | NULL |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    | NULL | NULL | NULL |
|  6 |    7 |  6 |    8 | c    | NULL | NULL | NULL |
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |6        |136 |
|1 | SUBPLAN SCAN          |VIEW1|6        |135 |
|2 |  HASH RIGHT OUTER JOIN|     |6        |134 |
|3 |   TABLE SCAN          |t3   |6        |37  |
|4 |   MERGE JOIN          |     |6        |80  |
|5 |    TABLE SCAN         |t1   |6        |37  |
|6 |    TABLE SCAN         |t2   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  3 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t5_temp (select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |1        |120 |
|1 | SUBPLAN SCAN      |VIEW1|1        |120 |
|2 |  HASH OUTER JOIN  |     |1        |120 |
|3 |   MERGE OUTER JOIN|     |1        |80  |
|4 |    TABLE SCAN     |t1   |6        |37  |
|5 |    TABLE SCAN     |t2   |6        |37  |
|6 |   TABLE SCAN      |t3   |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c1 > 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |161 |
|1 | SUBPLAN FILTER          |    |6        |155 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |118 |
|4 |   NESTED-LOOP JOIN      |    |1        |117 |
|5 |    HASH RIGHT OUTER JOIN|    |1        |81  |
|6 |     TABLE SCAN          |t3  |6        |37  |
|7 |     TABLE SCAN          |t1  |1        |36  |
|8 |    TABLE GET            |t2  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  6 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |6        |163 |
|1 | SUBPLAN FILTER     |    |6        |157 |
|2 |  TABLE SCAN        |t1  |6        |37  |
|3 |  LIMIT             |    |1        |119 |
|4 |   HASH OUTER JOIN  |    |1        |119 |
|5 |    MERGE OUTER JOIN|    |1        |79  |
|6 |     TABLE SCAN     |t1  |6        |37  |
|7 |     TABLE SCAN     |t2  |6        |37  |
|8 |    TABLE SCAN      |t3  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter([t2.c1 > 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |156 |
|1 | SUBPLAN FILTER          |    |1        |155 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |118 |
|4 |   NESTED-LOOP JOIN      |    |1        |117 |
|5 |    HASH RIGHT OUTER JOIN|    |1        |81  |
|6 |     TABLE SCAN          |t3  |6        |37  |
|7 |     TABLE SCAN          |t1  |1        |36  |
|8 |    TABLE GET            |t2  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  6 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |158 |
|1 | SUBPLAN FILTER     |    |1        |157 |
|2 |  TABLE SCAN        |t1  |1        |38  |
|3 |  LIMIT             |    |1        |119 |
|4 |   HASH OUTER JOIN  |    |1        |119 |
|5 |    MERGE OUTER JOIN|    |1        |79  |
|6 |     TABLE SCAN     |t1  |6        |37  |
|7 |     TABLE SCAN     |t2  |6        |37  |
|8 |    TABLE SCAN      |t3  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter([t2.c1 > 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t2.c1 > 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

##case
EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |HASH OUTER JOIN  |    |1        |119 |
|1 | MERGE OUTER JOIN|    |1        |80  |
|2 |  TABLE SCAN     |t1  |6        |37  |
|3 |  TABLE SCAN     |t2  |6        |37  |
|4 | TABLE SCAN      |t3  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE NULL END = 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |HASH OUTER JOIN  |    |1        |119 |
|1 | MERGE OUTER JOIN|    |1        |80  |
|2 |  TABLE SCAN     |t1  |6        |37  |
|3 |  TABLE SCAN     |t2  |6        |37  |
|4 | TABLE SCAN      |t3  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE NULL END = 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |1        |119 |
|1 | SUBPLAN SCAN      |VIEW1|1        |119 |
|2 |  HASH OUTER JOIN  |     |1        |119 |
|3 |   MERGE OUTER JOIN|     |1        |80  |
|4 |    TABLE SCAN     |t1   |6        |37  |
|5 |    TABLE SCAN     |t2   |6        |37  |
|6 |   TABLE SCAN      |t3   |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE NULL END = 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)

insert into t5_temp (select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |1        |119 |
|1 | SUBPLAN SCAN      |VIEW1|1        |119 |
|2 |  HASH OUTER JOIN  |     |1        |119 |
|3 |   MERGE OUTER JOIN|     |1        |80  |
|4 |    TABLE SCAN     |t1   |6        |37  |
|5 |    TABLE SCAN     |t2   |6        |37  |
|6 |   TABLE SCAN      |t3   |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE NULL END = 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |162 |
|1 | SUBPLAN FILTER    |    |6        |156 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  HASH OUTER JOIN  |    |1        |118 |
|4 |   MERGE OUTER JOIN|    |1        |79  |
|5 |    TABLE SCAN     |t1  |6        |37  |
|6 |    TABLE SCAN     |t2  |6        |37  |
|7 |   TABLE SCAN      |t3  |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE NULL END = 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |162 |
|1 | SUBPLAN FILTER    |    |6        |156 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  HASH OUTER JOIN  |    |1        |118 |
|4 |   MERGE OUTER JOIN|    |1        |79  |
|5 |    TABLE SCAN     |t1  |6        |37  |
|6 |    TABLE SCAN     |t2  |6        |37  |
|7 |   TABLE SCAN      |t3  |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE NULL END = 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |157 |
|1 | SUBPLAN FILTER    |    |1        |156 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  HASH OUTER JOIN  |    |1        |118 |
|4 |   MERGE OUTER JOIN|    |1        |79  |
|5 |    TABLE SCAN     |t1  |6        |37  |
|6 |    TABLE SCAN     |t2  |6        |37  |
|7 |   TABLE SCAN      |t3  |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE NULL END = 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |157 |
|1 | SUBPLAN FILTER    |    |1        |156 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  HASH OUTER JOIN  |    |1        |118 |
|4 |   MERGE OUTER JOIN|    |1        |79  |
|5 |    TABLE SCAN     |t1  |6        |37  |
|6 |    TABLE SCAN     |t2  |6        |37  |
|7 |   TABLE SCAN      |t3  |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE NULL END = 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where (case t2.c2 when 0 then 1 end) = 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

## case
EXPLAIN select * from t1, t1 as v join t2 on v.c1 = t2.c1;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |36       |144 |
|1 | MERGE JOIN               |    |6        |80  |
|2 |  TABLE SCAN              |v   |6        |37  |
|3 |  TABLE SCAN              |t2  |6        |37  |
|4 | MATERIAL                 |    |6        |40  |
|5 |  TABLE SCAN              |t1  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [v.c1], [v.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([v.c1], [v.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([v.c1 = t2.c1]), other_conds(nil)
  2 - output([v.c1], [v.c2]), filter(nil), 
      access([v.c1], [v.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1, t1 as v join t2 on v.c1 = t2.c1;
+----+------+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+----+------+------+
|  1 |    1 |  1 |    1 |  1 |    1 | o    |
|  1 |    1 |  2 |    5 |  2 |    5 | c    |
|  1 |    1 |  3 |    2 |  3 |    5 | b    |
|  1 |    1 |  4 |    6 |  4 |    6 | o    |
|  1 |    1 |  5 |    4 |  5 |    7 | d    |
|  1 |    1 |  6 |    7 |  6 |    8 | c    |
|  2 |    5 |  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    2 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 |  4 |    6 | o    |
|  2 |    5 |  5 |    4 |  5 |    7 | d    |
|  2 |    5 |  6 |    7 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 |  4 |    6 | o    |
|  3 |    2 |  5 |    4 |  5 |    7 | d    |
|  3 |    2 |  6 |    7 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 |  2 |    5 | c    |
|  4 |    6 |  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    4 |  5 |    7 | d    |
|  4 |    6 |  6 |    7 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 |  2 |    5 | c    |
|  5 |    4 |  3 |    2 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    7 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 |  2 |    5 | c    |
|  6 |    7 |  3 |    2 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 |  4 |    6 | o    |
|  6 |    7 |  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    7 |  6 |    8 | c    |
+----+------+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1, t1 as v join t2 on v.c1 = t2.c1;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |36       |144 |
|1 | MERGE JOIN               |    |6        |80  |
|2 |  TABLE SCAN              |v   |6        |37  |
|3 |  TABLE SCAN              |t2  |6        |37  |
|4 | MATERIAL                 |    |6        |40  |
|5 |  TABLE SCAN              |t1  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [v.c1], [v.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([v.c1], [v.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([v.c1 = t2.c1]), other_conds(nil)
  2 - output([v.c1], [v.c2]), filter(nil), 
      access([v.c1], [v.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1, t1 as v join t2 on v.c1 = t2.c1;
+----+------+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+----+------+------+
|  1 |    1 |  1 |    1 |  1 |    1 | o    |
|  1 |    1 |  2 |    5 |  2 |    5 | c    |
|  1 |    1 |  3 |    2 |  3 |    5 | b    |
|  1 |    1 |  4 |    6 |  4 |    6 | o    |
|  1 |    1 |  5 |    4 |  5 |    7 | d    |
|  1 |    1 |  6 |    7 |  6 |    8 | c    |
|  2 |    5 |  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    2 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 |  4 |    6 | o    |
|  2 |    5 |  5 |    4 |  5 |    7 | d    |
|  2 |    5 |  6 |    7 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 |  4 |    6 | o    |
|  3 |    2 |  5 |    4 |  5 |    7 | d    |
|  3 |    2 |  6 |    7 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 |  2 |    5 | c    |
|  4 |    6 |  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    4 |  5 |    7 | d    |
|  4 |    6 |  6 |    7 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 |  2 |    5 | c    |
|  5 |    4 |  3 |    2 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    7 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 |  2 |    5 | c    |
|  6 |    7 |  3 |    2 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 |  4 |    6 | o    |
|  6 |    7 |  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    7 |  6 |    8 | c    |
+----+------+----+------+----+------+------+
EXPLAIN insert into t6_temp (select * from t1, t1 as v join t2 on v.c1 = t2.c1);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |36       |154 |
|1 | SUBPLAN SCAN               |VIEW1|36       |149 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |36       |144 |
|3 |   MERGE JOIN               |     |6        |80  |
|4 |    TABLE SCAN              |v    |6        |37  |
|5 |    TABLE SCAN              |t2   |6        |37  |
|6 |   MATERIAL                 |     |6        |40  |
|7 |    TABLE SCAN              |t1   |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t6_temp: ({t6_temp: (t6_temp.__pk_increment, t6_temp.a, t6_temp.b, t6_temp.c, t6_temp.d, t6_temp.e, t6_temp.f, t6_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [v.c1], [v.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([v.c1], [v.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([v.c1 = t2.c1]), other_conds(nil)
  4 - output([v.c1], [v.c2]), filter(nil), 
      access([v.c1], [v.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t6_temp (select * from t1, t1 as v join t2 on v.c1 = t2.c1);

rollback;
EXPLAIN insert into t6_temp (select /*+ NO_REWRITE */* from t1, t1 as v join t2 on v.c1 = t2.c1);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |36       |154 |
|1 | SUBPLAN SCAN               |VIEW1|36       |149 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |36       |144 |
|3 |   MERGE JOIN               |     |6        |80  |
|4 |    TABLE SCAN              |v    |6        |37  |
|5 |    TABLE SCAN              |t2   |6        |37  |
|6 |   MATERIAL                 |     |6        |40  |
|7 |    TABLE SCAN              |t1   |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t6_temp: ({t6_temp: (t6_temp.__pk_increment, t6_temp.a, t6_temp.b, t6_temp.c, t6_temp.d, t6_temp.e, t6_temp.f, t6_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [v.c1], [v.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([v.c1], [v.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([v.c1 = t2.c1]), other_conds(nil)
  4 - output([v.c1], [v.c2]), filter(nil), 
      access([v.c1], [v.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t6_temp (select /*+ NO_REWRITE */* from t1, t1 as v join t2 on v.c1 = t2.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t1 as v join t2 on v.c1 = t2.c1 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |155 |
|1 | SUBPLAN FILTER              |    |6        |149 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |111 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |111 |
|5 |    MERGE JOIN               |    |1        |73  |
|6 |     TABLE SCAN              |v   |1        |36  |
|7 |     TABLE SCAN              |t2  |1        |36  |
|8 |    MATERIAL                 |    |6        |38  |
|9 |     TABLE SCAN              |t1  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter(nil), 
      equal_conds([v.c1 = t2.c1]), other_conds(nil)
  6 - output([v.c1]), filter(nil), 
      access([v.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t1 as v join t2 on v.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t1 as v join t2 on v.c1 = t2.c1 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |155 |
|1 | SUBPLAN FILTER              |    |6        |149 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |111 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |111 |
|5 |    MERGE JOIN               |    |1        |73  |
|6 |     TABLE SCAN              |v   |1        |36  |
|7 |     TABLE SCAN              |t2  |1        |36  |
|8 |    MATERIAL                 |    |6        |38  |
|9 |     TABLE SCAN              |t1  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter(nil), 
      equal_conds([v.c1 = t2.c1]), other_conds(nil)
  6 - output([v.c1]), filter(nil), 
      access([v.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t1 as v join t2 on v.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t1 as v join t2 on v.c1 = t2.c1 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |150 |
|1 | SUBPLAN FILTER              |    |1        |149 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |111 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |111 |
|5 |    MERGE JOIN               |    |1        |73  |
|6 |     TABLE SCAN              |v   |1        |36  |
|7 |     TABLE SCAN              |t2  |1        |36  |
|8 |    MATERIAL                 |    |6        |38  |
|9 |     TABLE SCAN              |t1  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter(nil), 
      equal_conds([v.c1 = t2.c1]), other_conds(nil)
  6 - output([v.c1]), filter(nil), 
      access([v.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t1 as v join t2 on v.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t1 as v join t2 on v.c1 = t2.c1 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |150 |
|1 | SUBPLAN FILTER              |    |1        |149 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |111 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |111 |
|5 |    MERGE JOIN               |    |1        |73  |
|6 |     TABLE SCAN              |v   |1        |36  |
|7 |     TABLE SCAN              |t2  |1        |36  |
|8 |    MATERIAL                 |    |6        |38  |
|9 |     TABLE SCAN              |t1  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter(nil), 
      equal_conds([v.c1 = t2.c1]), other_conds(nil)
  6 - output([v.c1]), filter(nil), 
      access([v.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t1 as v join t2 on v.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

##case
EXPLAIN select * from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |HASH OUTER JOIN  |    |6        |134 |
|1 | TABLE SCAN      |t3  |6        |37  |
|2 | MERGE OUTER JOIN|    |6        |80  |
|3 |  TABLE SCAN     |t2  |6        |37  |
|4 |  TABLE SCAN     |t1  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
| NULL | NULL | NULL | NULL | NULL |  1 |    2 | 3    |
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |HASH OUTER JOIN  |    |6        |134 |
|1 | TABLE SCAN      |t3  |6        |37  |
|2 | MERGE OUTER JOIN|    |6        |80  |
|3 |  TABLE SCAN     |t2  |6        |37  |
|4 |  TABLE SCAN     |t1  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
| NULL | NULL | NULL | NULL | NULL |  1 |    2 | 3    |
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |6        |136 |
|1 | SUBPLAN SCAN      |VIEW1|6        |135 |
|2 |  HASH OUTER JOIN  |     |6        |134 |
|3 |   TABLE SCAN      |t3   |6        |37  |
|4 |   MERGE OUTER JOIN|     |6        |80  |
|5 |    TABLE SCAN     |t2   |6        |37  |
|6 |    TABLE SCAN     |t1   |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  3 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t5_temp (select * from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |6        |136 |
|1 | SUBPLAN SCAN      |VIEW1|6        |135 |
|2 |  HASH OUTER JOIN  |     |6        |134 |
|3 |   TABLE SCAN      |t3   |6        |37  |
|4 |   MERGE OUTER JOIN|     |6        |80  |
|5 |    TABLE SCAN     |t2   |6        |37  |
|6 |    TABLE SCAN     |t1   |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  3 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2 limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                   |     |6        |158 |
|1 | SUBPLAN FILTER          |     |6        |152 |
|2 |  TABLE SCAN             |t1   |6        |37  |
|3 |  LIMIT                  |     |1        |114 |
|4 |   NESTED-LOOP OUTER JOIN|     |1        |114 |
|5 |    HASH OUTER JOIN      |     |1        |77  |
|6 |     SUBPLAN SCAN        |VIEW1|1        |37  |
|7 |      TABLE SCAN         |t3   |1        |36  |
|8 |     TABLE SCAN          |t2   |6        |37  |
|9 |    TABLE GET            |t1   |1        |36  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = VIEW1.t3.c2]), other_conds(nil)
  6 - output([VIEW1.t3.c2]), filter(nil), 
      access([VIEW1.t3.c2])
  7 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |161 |
|1 | SUBPLAN FILTER          |    |6        |155 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |118 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |117 |
|5 |    HASH OUTER JOIN      |    |1        |81  |
|6 |     TABLE SCAN          |t3  |6        |37  |
|7 |     TABLE SCAN          |t2  |1        |36  |
|8 |    TABLE GET            |t1  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  6 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2 limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                   |     |1        |152 |
|1 | SUBPLAN FILTER          |     |1        |151 |
|2 |  TABLE SCAN             |t1   |1        |38  |
|3 |  LIMIT                  |     |1        |114 |
|4 |   NESTED-LOOP OUTER JOIN|     |1        |114 |
|5 |    HASH OUTER JOIN      |     |1        |77  |
|6 |     SUBPLAN SCAN        |VIEW1|1        |37  |
|7 |      TABLE SCAN         |t3   |1        |36  |
|8 |     TABLE SCAN          |t2   |6        |37  |
|9 |    TABLE GET            |t1   |1        |36  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = VIEW1.t3.c2]), other_conds(nil)
  6 - output([VIEW1.t3.c2]), filter(nil), 
      access([VIEW1.t3.c2])
  7 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |156 |
|1 | SUBPLAN FILTER          |    |1        |155 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |118 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |117 |
|5 |    HASH OUTER JOIN      |    |1        |81  |
|6 |     TABLE SCAN          |t3  |6        |37  |
|7 |     TABLE SCAN          |t2  |1        |36  |
|8 |    TABLE GET            |t1  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  6 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t2.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null;
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |216      |359 |
|1 | NESTED-LOOP JOIN CARTESIAN|    |36       |150 |
|2 |  MERGE OUTER JOIN         |    |6        |80  |
|3 |   TABLE SCAN              |t2  |6        |37  |
|4 |   TABLE SCAN              |t1  |6        |37  |
|5 |  MATERIAL                 |    |6        |44  |
|6 |   TABLE SCAN              |v   |6        |37  |
|7 | MATERIAL                  |    |6        |45  |
|8 |  TABLE SCAN               |t3  |6        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2], [v.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2], [v.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([v.c1], [v.c2], [v.c3]), filter(nil)
  6 - output([v.c1], [v.c2], [v.c3]), filter(nil), 
      access([v.c1], [v.c2], [v.c3]), partitions(p0)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  8 - output([t3.c2], [t3.c1], [t3.c3]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)

select * from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  6 |    5 | c    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  6 |    5 | c    |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  6 |    5 | c    |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  6 |    5 | c    |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  6 |    5 | c    |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null;
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |216      |359 |
|1 | NESTED-LOOP JOIN CARTESIAN|    |36       |150 |
|2 |  MERGE OUTER JOIN         |    |6        |80  |
|3 |   TABLE SCAN              |t2  |6        |37  |
|4 |   TABLE SCAN              |t1  |6        |37  |
|5 |  MATERIAL                 |    |6        |44  |
|6 |   TABLE SCAN              |v   |6        |37  |
|7 | MATERIAL                  |    |6        |45  |
|8 |  TABLE SCAN               |t3  |6        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2], [v.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2], [v.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([v.c1], [v.c2], [v.c3]), filter(nil)
  6 - output([v.c1], [v.c2], [v.c3]), filter(nil), 
      access([v.c1], [v.c2], [v.c3]), partitions(p0)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  8 - output([t3.c2], [t3.c1], [t3.c3]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  6 |    5 | c    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  6 |    5 | c    |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  6 |    5 | c    |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  6 |    5 | c    |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  6 |    5 | c    |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null);
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |216      |418 |
|1 | SUBPLAN SCAN                |VIEW1|216      |388 |
|2 |  NESTED-LOOP JOIN CARTESIAN |     |216      |359 |
|3 |   NESTED-LOOP JOIN CARTESIAN|     |36       |150 |
|4 |    MERGE OUTER JOIN         |     |6        |80  |
|5 |     TABLE SCAN              |t2   |6        |37  |
|6 |     TABLE SCAN              |t1   |6        |37  |
|7 |    MATERIAL                 |     |6        |44  |
|8 |     TABLE SCAN              |v    |6        |37  |
|9 |   MATERIAL                  |     |6        |45  |
|10|    TABLE SCAN               |t3   |6        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2], [v.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2], [v.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([v.c1], [v.c2], [v.c3]), filter(nil)
  8 - output([v.c1], [v.c2], [v.c3]), filter(nil), 
      access([v.c1], [v.c2], [v.c3]), partitions(p0)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  10 - output([t3.c2], [t3.c1], [t3.c3]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)

insert into t7_temp (select * from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null);
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |216      |418 |
|1 | SUBPLAN SCAN                |VIEW1|216      |388 |
|2 |  NESTED-LOOP JOIN CARTESIAN |     |216      |359 |
|3 |   NESTED-LOOP JOIN CARTESIAN|     |36       |150 |
|4 |    MERGE OUTER JOIN         |     |6        |80  |
|5 |     TABLE SCAN              |t2   |6        |37  |
|6 |     TABLE SCAN              |t1   |6        |37  |
|7 |    MATERIAL                 |     |6        |44  |
|8 |     TABLE SCAN              |v    |6        |37  |
|9 |   MATERIAL                  |     |6        |45  |
|10|    TABLE SCAN               |t3   |6        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2], [v.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [v.c1], [v.c2], [v.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([v.c1], [v.c2], [v.c3]), filter(nil)
  8 - output([v.c1], [v.c2], [v.c3]), filter(nil), 
      access([v.c1], [v.c2], [v.c3]), partitions(p0)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  10 - output([t3.c2], [t3.c1], [t3.c3]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |6        |193 |
|1 | SUBPLAN FILTER               |    |6        |187 |
|2 |  TABLE SCAN                  |t1  |6        |37  |
|3 |  LIMIT                       |    |1        |149 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |149 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |110 |
|6 |     MERGE OUTER JOIN         |    |1        |72  |
|7 |      TABLE SCAN              |t2  |1        |36  |
|8 |      TABLE SCAN              |t1  |1        |36  |
|9 |     MATERIAL                 |    |6        |38  |
|10|      TABLE SCAN              |v   |6        |37  |
|11|    MATERIAL                  |    |6        |39  |
|12|     TABLE SCAN               |t3  |6        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      access([v.c1]), partitions(p0)
  11 - output([1]), filter(nil)
  12 - output([1]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |6        |193 |
|1 | SUBPLAN FILTER               |    |6        |187 |
|2 |  TABLE SCAN                  |t1  |6        |37  |
|3 |  LIMIT                       |    |1        |149 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |149 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |110 |
|6 |     MERGE OUTER JOIN         |    |1        |72  |
|7 |      TABLE SCAN              |t2  |1        |36  |
|8 |      TABLE SCAN              |t1  |1        |36  |
|9 |     MATERIAL                 |    |6        |38  |
|10|      TABLE SCAN              |v   |6        |37  |
|11|    MATERIAL                  |    |6        |39  |
|12|     TABLE SCAN               |t3  |6        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      access([v.c1]), partitions(p0)
  11 - output([1]), filter(nil)
  12 - output([1]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |188 |
|1 | SUBPLAN FILTER               |    |1        |187 |
|2 |  TABLE SCAN                  |t1  |1        |38  |
|3 |  LIMIT                       |    |1        |149 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |149 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |110 |
|6 |     MERGE OUTER JOIN         |    |1        |72  |
|7 |      TABLE SCAN              |t2  |1        |36  |
|8 |      TABLE SCAN              |t1  |1        |36  |
|9 |     MATERIAL                 |    |6        |38  |
|10|      TABLE SCAN              |v   |6        |37  |
|11|    MATERIAL                  |    |6        |39  |
|12|     TABLE SCAN               |t3  |6        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      access([v.c1]), partitions(p0)
  11 - output([1]), filter(nil)
  12 - output([1]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |188 |
|1 | SUBPLAN FILTER               |    |1        |187 |
|2 |  TABLE SCAN                  |t1  |1        |38  |
|3 |  LIMIT                       |    |1        |149 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |149 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |110 |
|6 |     MERGE OUTER JOIN         |    |1        |72  |
|7 |      TABLE SCAN              |t2  |1        |36  |
|8 |      TABLE SCAN              |t1  |1        |36  |
|9 |     MATERIAL                 |    |6        |38  |
|10|      TABLE SCAN              |v   |6        |37  |
|11|    MATERIAL                  |    |6        |39  |
|12|     TABLE SCAN               |t3  |6        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      access([v.c1]), partitions(p0)
  11 - output([1]), filter(nil)
  12 - output([1]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1, t2 as v, t3 where t3.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

##case resolver only support one joined table
##case same table alias twice
EXPLAIN select * from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2;
Query Plan
=======================================
|ID|OPERATOR    |NAME  |EST. ROWS|COST|
---------------------------------------
|0 |MERGE JOIN  |      |3        |84  |
|1 | SORT       |      |6        |43  |
|2 |  TABLE SCAN|table1|6        |37  |
|3 | TABLE SCAN |table2|6        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([table1.c1], [table1.c2], [table2.c1], [table2.c2]), filter(nil), 
      equal_conds([table1.c2 = table2.c1]), other_conds([table1.c1 < table2.c1 OR table1.c1 = table2.c2])
  1 - output([table1.c1], [table1.c2]), filter(nil), sort_keys([table1.c2, ASC])
  2 - output([table1.c2], [table1.c1]), filter(nil), 
      access([table1.c2], [table1.c1]), partitions(p0)
  3 - output([table2.c1], [table2.c2]), filter(nil), 
      access([table2.c1], [table2.c2]), partitions(p0)

select * from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2;
+----+------+----+------+
| c1 | c2   | c1 | c2   |
+----+------+----+------+
|  1 |    1 |  1 |    1 |
|  2 |    5 |  5 |    4 |
|  4 |    6 |  6 |    7 |
+----+------+----+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2;
Query Plan
===========================================
|ID|OPERATOR        |NAME  |EST. ROWS|COST|
-------------------------------------------
|0 |MERGE OUTER JOIN|      |3        |85  |
|1 | SORT           |      |6        |43  |
|2 |  TABLE SCAN    |table1|6        |37  |
|3 | TABLE SCAN     |table2|6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([table1.c1], [table1.c2], [table2.c1], [table2.c2]), filter([table1.c1 < table2.c1 OR table1.c1 = table2.c2]), 
      equal_conds([table1.c2 = table2.c1]), other_conds(nil)
  1 - output([table1.c1], [table1.c2]), filter(nil), sort_keys([table1.c2, ASC])
  2 - output([table1.c2], [table1.c1]), filter(nil), 
      access([table1.c2], [table1.c1]), partitions(p0)
  3 - output([table2.c1], [table2.c2]), filter(nil), 
      access([table2.c1], [table2.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2;
+----+------+----+------+
| c1 | c2   | c1 | c2   |
+----+------+----+------+
|  1 |    1 |  1 |    1 |
|  2 |    5 |  5 |    4 |
|  4 |    6 |  6 |    7 |
+----+------+----+------+
EXPLAIN insert into t8_temp (select * from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2);
Query Plan
=========================================
|ID|OPERATOR      |NAME  |EST. ROWS|COST|
-----------------------------------------
|0 |INSERT        |      |3        |85  |
|1 | SUBPLAN SCAN |VIEW1 |3        |84  |
|2 |  MERGE JOIN  |      |3        |84  |
|3 |   SORT       |      |6        |43  |
|4 |    TABLE SCAN|table1|6        |37  |
|5 |   TABLE SCAN |table2|6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t8_temp: ({t8_temp: (t8_temp.__pk_increment, t8_temp.a, t8_temp.b, t8_temp.c, t8_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([table1.c1], [table1.c2], [table2.c1], [table2.c2]), filter(nil), 
      equal_conds([table1.c2 = table2.c1]), other_conds([table1.c1 < table2.c1 OR table1.c1 = table2.c2])
  3 - output([table1.c1], [table1.c2]), filter(nil), sort_keys([table1.c2, ASC])
  4 - output([table1.c2], [table1.c1]), filter(nil), 
      access([table1.c2], [table1.c1]), partitions(p0)
  5 - output([table2.c1], [table2.c2]), filter(nil), 
      access([table2.c1], [table2.c2]), partitions(p0)

insert into t8_temp (select * from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2);

rollback;
EXPLAIN insert into t8_temp (select /*+ NO_REWRITE */* from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2);
Query Plan
=============================================
|ID|OPERATOR          |NAME  |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT            |      |3        |86  |
|1 | SUBPLAN SCAN     |VIEW1 |3        |85  |
|2 |  MERGE OUTER JOIN|      |3        |85  |
|3 |   SORT           |      |6        |43  |
|4 |    TABLE SCAN    |table1|6        |37  |
|5 |   TABLE SCAN     |table2|6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t8_temp: ({t8_temp: (t8_temp.__pk_increment, t8_temp.a, t8_temp.b, t8_temp.c, t8_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([table1.c1], [table1.c2], [table2.c1], [table2.c2]), filter([table1.c1 < table2.c1 OR table1.c1 = table2.c2]), 
      equal_conds([table1.c2 = table2.c1]), other_conds(nil)
  3 - output([table1.c1], [table1.c2]), filter(nil), sort_keys([table1.c2, ASC])
  4 - output([table1.c2], [table1.c1]), filter(nil), 
      access([table1.c2], [table1.c1]), partitions(p0)
  5 - output([table2.c1], [table2.c2]), filter(nil), 
      access([table2.c1], [table2.c2]), partitions(p0)

insert into t8_temp (select /*+ NO_REWRITE */* from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2);

rollback;
EXPLAIN update t1 set c2 = (select table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2 limit 1);
Query Plan
==========================================
|ID|OPERATOR       |NAME  |EST. ROWS|COST|
------------------------------------------
|0 |UPDATE         |      |6        |127 |
|1 | SUBPLAN FILTER|      |6        |121 |
|2 |  TABLE SCAN   |t1    |6        |37  |
|3 |  LIMIT        |      |1        |83  |
|4 |   HASH JOIN   |      |1        |83  |
|5 |    TABLE SCAN |table1|6        |37  |
|6 |    TABLE SCAN |table2|3        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([table1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([table1.c1]), filter(nil), 
      equal_conds([table1.c2 = table2.c1]), other_conds([table1.c1 < table2.c1 OR table1.c1 = table2.c2])
  5 - output([table1.c2], [table1.c1]), filter(nil), 
      access([table1.c2], [table1.c1]), partitions(p0)
  6 - output([table2.c1], [table2.c2]), filter(nil), 
      access([table2.c1], [table2.c2]), partitions(p0)

update t1 set c2 = (select table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2 limit 1);
Query Plan
=============================================
|ID|OPERATOR          |NAME  |EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE            |      |6        |127 |
|1 | SUBPLAN FILTER   |      |6        |121 |
|2 |  TABLE SCAN      |t1    |6        |37  |
|3 |  LIMIT           |      |1        |83  |
|4 |   HASH OUTER JOIN|      |1        |83  |
|5 |    TABLE SCAN    |table1|6        |37  |
|6 |    TABLE SCAN    |table2|3        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([table1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([table1.c1]), filter([table1.c1 < table2.c1 OR table1.c1 = table2.c2]), 
      equal_conds([table1.c2 = table2.c1]), other_conds(nil)
  5 - output([table1.c2], [table1.c1]), filter(nil), 
      access([table1.c2], [table1.c1]), partitions(p0)
  6 - output([table2.c1], [table2.c2]), filter(nil), 
      access([table2.c1], [table2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2 limit 1);
Query Plan
==========================================
|ID|OPERATOR       |NAME  |EST. ROWS|COST|
------------------------------------------
|0 |DELETE         |      |1        |121 |
|1 | SUBPLAN FILTER|      |1        |120 |
|2 |  TABLE SCAN   |t1    |1        |38  |
|3 |  LIMIT        |      |1        |83  |
|4 |   HASH JOIN   |      |1        |83  |
|5 |    TABLE SCAN |table1|6        |37  |
|6 |    TABLE SCAN |table2|3        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([table1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([table1.c1]), filter(nil), 
      equal_conds([table1.c2 = table2.c1]), other_conds([table1.c1 < table2.c1 OR table1.c1 = table2.c2])
  5 - output([table1.c2], [table1.c1]), filter(nil), 
      access([table1.c2], [table1.c1]), partitions(p0)
  6 - output([table2.c1], [table2.c2]), filter(nil), 
      access([table2.c1], [table2.c2]), partitions(p0)

delete from t1 where c2 = (select table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2 limit 1);
Query Plan
=============================================
|ID|OPERATOR          |NAME  |EST. ROWS|COST|
---------------------------------------------
|0 |DELETE            |      |1        |122 |
|1 | SUBPLAN FILTER   |      |1        |121 |
|2 |  TABLE SCAN      |t1    |1        |38  |
|3 |  LIMIT           |      |1        |83  |
|4 |   HASH OUTER JOIN|      |1        |83  |
|5 |    TABLE SCAN    |table1|6        |37  |
|6 |    TABLE SCAN    |table2|3        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([table1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([table1.c1]), filter([table1.c1 < table2.c1 OR table1.c1 = table2.c2]), 
      equal_conds([table1.c2 = table2.c1]), other_conds(nil)
  5 - output([table1.c2], [table1.c1]), filter(nil), 
      access([table1.c2], [table1.c1]), partitions(p0)
  6 - output([table2.c1], [table2.c2]), filter(nil), 
      access([table2.c1], [table2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 or table1.c1 = table2.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

##case same table alias twice
EXPLAIN select * from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2;
Query Plan
=======================================
|ID|OPERATOR    |NAME  |EST. ROWS|COST|
---------------------------------------
|0 |MERGE JOIN  |      |2        |79  |
|1 | TABLE SCAN |table1|2        |38  |
|2 | SORT       |      |2        |39  |
|3 |  TABLE SCAN|table2|2        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([table1.c1], [table1.c2], [table2.c1], [table2.c2]), filter(nil), 
      equal_conds([table1.c1 = table2.c2], [table1.c2 = table2.c1]), other_conds(nil)
  1 - output([table1.c2], [table1.c1]), filter([table1.c2 > table1.c1]), 
      access([table1.c2], [table1.c1]), partitions(p0)
  2 - output([table2.c1], [table2.c2]), filter(nil), sort_keys([table2.c2, ASC], [table2.c1, ASC])
  3 - output([table2.c1], [table2.c2]), filter([table2.c1 > table2.c2]), 
      access([table2.c1], [table2.c2]), partitions(p0)

select * from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2;
+----+------+----+------+
| c1 | c2   | c1 | c2   |
+----+------+----+------+
+----+------+----+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2;
Query Plan
===========================================
|ID|OPERATOR        |NAME  |EST. ROWS|COST|
-------------------------------------------
|0 |MERGE OUTER JOIN|      |1        |85  |
|1 | SORT           |      |6        |43  |
|2 |  TABLE SCAN    |table1|6        |37  |
|3 | TABLE SCAN     |table2|6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([table1.c1], [table1.c2], [table2.c1], [table2.c2]), filter([table1.c1 = table2.c2], [table1.c1 < table2.c1]), 
      equal_conds([table1.c2 = table2.c1]), other_conds(nil)
  1 - output([table1.c1], [table1.c2]), filter(nil), sort_keys([table1.c2, ASC])
  2 - output([table1.c2], [table1.c1]), filter(nil), 
      access([table1.c2], [table1.c1]), partitions(p0)
  3 - output([table2.c1], [table2.c2]), filter(nil), 
      access([table2.c1], [table2.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2;
+----+------+----+------+
| c1 | c2   | c1 | c2   |
+----+------+----+------+
+----+------+----+------+
EXPLAIN insert into t8_temp (select * from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2);
Query Plan
=========================================
|ID|OPERATOR      |NAME  |EST. ROWS|COST|
-----------------------------------------
|0 |INSERT        |      |2        |79  |
|1 | SUBPLAN SCAN |VIEW1 |2        |79  |
|2 |  MERGE JOIN  |      |2        |79  |
|3 |   TABLE SCAN |table1|2        |38  |
|4 |   SORT       |      |2        |39  |
|5 |    TABLE SCAN|table2|2        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t8_temp: ({t8_temp: (t8_temp.__pk_increment, t8_temp.a, t8_temp.b, t8_temp.c, t8_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([table1.c1], [table1.c2], [table2.c1], [table2.c2]), filter(nil), 
      equal_conds([table1.c1 = table2.c2], [table1.c2 = table2.c1]), other_conds(nil)
  3 - output([table1.c2], [table1.c1]), filter([table1.c2 > table1.c1]), 
      access([table1.c2], [table1.c1]), partitions(p0)
  4 - output([table2.c1], [table2.c2]), filter(nil), sort_keys([table2.c2, ASC], [table2.c1, ASC])
  5 - output([table2.c1], [table2.c2]), filter([table2.c1 > table2.c2]), 
      access([table2.c1], [table2.c2]), partitions(p0)

insert into t8_temp (select * from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2);

rollback;
EXPLAIN insert into t8_temp (select /*+ NO_REWRITE */* from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2);
Query Plan
=============================================
|ID|OPERATOR          |NAME  |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT            |      |1        |85  |
|1 | SUBPLAN SCAN     |VIEW1 |1        |85  |
|2 |  MERGE OUTER JOIN|      |1        |85  |
|3 |   SORT           |      |6        |43  |
|4 |    TABLE SCAN    |table1|6        |37  |
|5 |   TABLE SCAN     |table2|6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t8_temp: ({t8_temp: (t8_temp.__pk_increment, t8_temp.a, t8_temp.b, t8_temp.c, t8_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([table1.c1], [table1.c2], [table2.c1], [table2.c2]), filter([table1.c1 = table2.c2], [table1.c1 < table2.c1]), 
      equal_conds([table1.c2 = table2.c1]), other_conds(nil)
  3 - output([table1.c1], [table1.c2]), filter(nil), sort_keys([table1.c2, ASC])
  4 - output([table1.c2], [table1.c1]), filter(nil), 
      access([table1.c2], [table1.c1]), partitions(p0)
  5 - output([table2.c1], [table2.c2]), filter(nil), 
      access([table2.c1], [table2.c2]), partitions(p0)

insert into t8_temp (select /*+ NO_REWRITE */* from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2);

rollback;
EXPLAIN update t1 set c2 = (select table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2);
Query Plan
==========================================
|ID|OPERATOR       |NAME  |EST. ROWS|COST|
------------------------------------------
|0 |UPDATE         |      |6        |122 |
|1 | SUBPLAN FILTER|      |6        |116 |
|2 |  TABLE SCAN   |t1    |6        |37  |
|3 |  MERGE JOIN   |      |2        |79  |
|4 |   TABLE SCAN  |table1|2        |38  |
|5 |   SORT        |      |2        |39  |
|6 |    TABLE SCAN |table2|2        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([table1.c1]), filter(nil), 
      equal_conds([table1.c1 = table2.c2], [table1.c2 = table2.c1]), other_conds(nil)
  4 - output([table1.c2], [table1.c1]), filter([table1.c2 > table1.c1]), 
      access([table1.c2], [table1.c1]), partitions(p0)
  5 - output([table2.c2], [table2.c1]), filter(nil), sort_keys([table2.c2, ASC], [table2.c1, ASC])
  6 - output([table2.c1], [table2.c2]), filter([table2.c1 > table2.c2]), 
      access([table2.c1], [table2.c2]), partitions(p0)

update t1 set c2 = (select table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2);
Query Plan
=============================================
|ID|OPERATOR          |NAME  |EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE            |      |6        |129 |
|1 | SUBPLAN FILTER   |      |6        |123 |
|2 |  TABLE SCAN      |t1    |6        |37  |
|3 |  MERGE OUTER JOIN|      |1        |85  |
|4 |   SORT           |      |6        |43  |
|5 |    TABLE SCAN    |table1|6        |37  |
|6 |   TABLE SCAN     |table2|6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([table1.c1]), filter([table1.c1 = table2.c2], [table1.c1 < table2.c1]), 
      equal_conds([table1.c2 = table2.c1]), other_conds(nil)
  4 - output([table1.c1], [table1.c2]), filter(nil), sort_keys([table1.c2, ASC])
  5 - output([table1.c2], [table1.c1]), filter(nil), 
      access([table1.c2], [table1.c1]), partitions(p0)
  6 - output([table2.c1], [table2.c2]), filter(nil), 
      access([table2.c1], [table2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2);
Query Plan
==========================================
|ID|OPERATOR       |NAME  |EST. ROWS|COST|
------------------------------------------
|0 |DELETE         |      |1        |117 |
|1 | SUBPLAN FILTER|      |1        |116 |
|2 |  TABLE SCAN   |t1    |1        |38  |
|3 |  MERGE JOIN   |      |2        |79  |
|4 |   TABLE SCAN  |table1|2        |38  |
|5 |   SORT        |      |2        |39  |
|6 |    TABLE SCAN |table2|2        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([table1.c1]), filter(nil), 
      equal_conds([table1.c1 = table2.c2], [table1.c2 = table2.c1]), other_conds(nil)
  4 - output([table1.c2], [table1.c1]), filter([table1.c2 > table1.c1]), 
      access([table1.c2], [table1.c1]), partitions(p0)
  5 - output([table2.c2], [table2.c1]), filter(nil), sort_keys([table2.c2, ASC], [table2.c1, ASC])
  6 - output([table2.c1], [table2.c2]), filter([table2.c1 > table2.c2]), 
      access([table2.c1], [table2.c2]), partitions(p0)

delete from t1 where c2 = (select table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2);
Query Plan
=============================================
|ID|OPERATOR          |NAME  |EST. ROWS|COST|
---------------------------------------------
|0 |DELETE            |      |1        |123 |
|1 | SUBPLAN FILTER   |      |1        |122 |
|2 |  TABLE SCAN      |t1    |1        |38  |
|3 |  MERGE OUTER JOIN|      |1        |85  |
|4 |   SORT           |      |6        |43  |
|5 |    TABLE SCAN    |table1|6        |37  |
|6 |   TABLE SCAN     |table2|6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([table1.c1]), filter([table1.c1 = table2.c2], [table1.c1 < table2.c1]), 
      equal_conds([table1.c2 = table2.c1]), other_conds(nil)
  4 - output([table1.c1], [table1.c2]), filter(nil), sort_keys([table1.c2, ASC])
  5 - output([table1.c2], [table1.c1]), filter(nil), 
      access([table1.c2], [table1.c1]), partitions(p0)
  6 - output([table2.c1], [table2.c2]), filter(nil), 
      access([table2.c1], [table2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */table1.c1 from t1 as table1 left join t1 as table2 on table1.c2 = table2.c1 where table1.c1 < table2.c1 and table1.c1 = table2.c2);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

########################################################################
### null-reject satisfied
##case
EXPLAIN select * from t1 join (select * from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |6        |122 |
|1 | MERGE JOIN |    |6        |80  |
|2 |  TABLE SCAN|t1  |6        |37  |
|3 |  TABLE SCAN|t2  |6        |37  |
|4 | TABLE SCAN |t3  |6        |38  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select * from t1 join (select * from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 join (select /*+ NO_REWRITE */* from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |123 |
|1 | MERGE JOIN     |    |6        |80  |
|2 |  TABLE SCAN    |t1  |6        |37  |
|3 |  SUBPLAN SCAN  |v   |6        |38  |
|4 |   TABLE SCAN   |t2  |6        |37  |
|5 | TABLE SCAN     |t3  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [v.c1], [v.c2], [v.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [v.c1], [v.c2], [v.c3]), filter(nil), 
      equal_conds([t1.c1 = v.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([v.c1], [v.c2], [v.c3]), filter(nil), 
      access([v.c1], [v.c2], [v.c3])
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 join (select /*+ NO_REWRITE */* from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1 join (select * from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |124 |
|1 | SUBPLAN SCAN |VIEW1|6        |123 |
|2 |  MERGE JOIN  |     |6        |122 |
|3 |   MERGE JOIN |     |6        |80  |
|4 |    TABLE SCAN|t1   |6        |37  |
|5 |    TABLE SCAN|t2   |6        |37  |
|6 |   TABLE SCAN |t3   |6        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t5_temp (select * from t1 join (select * from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1 join (select /*+ NO_REWRITE */* from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |124 |
|1 | SUBPLAN SCAN     |VIEW1|6        |123 |
|2 |  MERGE OUTER JOIN|     |6        |123 |
|3 |   MERGE JOIN     |     |6        |80  |
|4 |    TABLE SCAN    |t1   |6        |37  |
|5 |    SUBPLAN SCAN  |v    |6        |38  |
|6 |     TABLE SCAN   |t2   |6        |37  |
|7 |   TABLE SCAN     |t3   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [v.c1], [v.c2], [v.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [v.c1], [v.c2], [v.c3]), filter(nil), 
      equal_conds([t1.c1 = v.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([v.c1], [v.c2], [v.c3]), filter(nil), 
      access([v.c1], [v.c2], [v.c3])
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1 join (select /*+ NO_REWRITE */* from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 join (select * from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |155 |
|1 | SUBPLAN FILTER    |    |6        |149 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE GET      |t3  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 join (select * from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join (select /*+ NO_REWRITE */* from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |155 |
|1 | SUBPLAN FILTER          |    |6        |149 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |111 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |111 |
|5 |    MERGE JOIN           |    |1        |74  |
|6 |     TABLE SCAN          |t1  |3        |37  |
|7 |     SUBPLAN SCAN        |v   |3        |37  |
|8 |      TABLE SCAN         |t2  |3        |37  |
|9 |    TABLE GET            |t3  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = v.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([v.c1]), filter(nil), 
      access([v.c1])
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  9 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join (select /*+ NO_REWRITE */* from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 join (select * from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |149 |
|1 | SUBPLAN FILTER    |    |1        |148 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE GET      |t3  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 join (select * from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join (select /*+ NO_REWRITE */* from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |150 |
|1 | SUBPLAN FILTER          |    |1        |149 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |111 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |111 |
|5 |    MERGE JOIN           |    |1        |74  |
|6 |     TABLE SCAN          |t1  |3        |37  |
|7 |     SUBPLAN SCAN        |v   |3        |37  |
|8 |      TABLE SCAN         |t2  |3        |37  |
|9 |    TABLE GET            |t3  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = v.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([v.c1]), filter(nil), 
      access([v.c1])
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  9 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join (select /*+ NO_REWRITE */* from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |6        |122 |
|1 | MERGE JOIN |    |6        |80  |
|2 |  TABLE SCAN|t1  |6        |37  |
|3 |  TABLE SCAN|t2  |6        |37  |
|4 | TABLE SCAN |t3  |6        |38  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select * from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |6        |122 |
|1 | MERGE JOIN |    |6        |80  |
|2 |  TABLE SCAN|t1  |6        |37  |
|3 |  TABLE SCAN|t2  |6        |37  |
|4 | TABLE SCAN |t3  |6        |38  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |124 |
|1 | SUBPLAN SCAN |VIEW1|6        |123 |
|2 |  MERGE JOIN  |     |6        |122 |
|3 |   MERGE JOIN |     |6        |80  |
|4 |    TABLE SCAN|t1   |6        |37  |
|5 |    TABLE SCAN|t2   |6        |37  |
|6 |   TABLE SCAN |t3   |6        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t5_temp (select * from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |124 |
|1 | SUBPLAN SCAN |VIEW1|6        |123 |
|2 |  MERGE JOIN  |     |6        |122 |
|3 |   MERGE JOIN |     |6        |80  |
|4 |    TABLE SCAN|t1   |6        |37  |
|5 |    TABLE SCAN|t2   |6        |37  |
|6 |   TABLE SCAN |t3   |6        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |155 |
|1 | SUBPLAN FILTER    |    |6        |149 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE GET      |t3  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |155 |
|1 | SUBPLAN FILTER    |    |6        |149 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE GET      |t3  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |149 |
|1 | SUBPLAN FILTER    |    |1        |148 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE GET      |t3  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |149 |
|1 | SUBPLAN FILTER    |    |1        |148 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE GET      |t3  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

##case
EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |6        |137 |
|1 | TABLE SCAN |t3  |6        |37  |
|2 | MERGE JOIN |    |6        |82  |
|3 |  TABLE SCAN|t1  |6        |37  |
|4 |  TABLE SCAN|t2  |6        |40  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c3], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |6        |134 |
|1 | TABLE SCAN          |t3  |6        |37  |
|2 | MERGE OUTER JOIN    |    |6        |80  |
|3 |  TABLE SCAN         |t1  |6        |37  |
|4 |  TABLE SCAN         |t2  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |139 |
|1 | SUBPLAN SCAN |VIEW1|6        |138 |
|2 |  HASH JOIN   |     |6        |137 |
|3 |   TABLE SCAN |t3   |6        |37  |
|4 |   MERGE JOIN |     |6        |82  |
|5 |    TABLE SCAN|t1   |6        |37  |
|6 |    TABLE SCAN|t2   |6        |40  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  3 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c3], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p0)

insert into t5_temp (select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |6        |136 |
|1 | SUBPLAN SCAN          |VIEW1|6        |135 |
|2 |  HASH RIGHT OUTER JOIN|     |6        |134 |
|3 |   TABLE SCAN          |t3   |6        |37  |
|4 |   MERGE OUTER JOIN    |     |6        |80  |
|5 |    TABLE SCAN         |t1   |6        |37  |
|6 |    TABLE SCAN         |t2   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  3 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |162 |
|1 | SUBPLAN FILTER    |    |6        |156 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |118 |
|4 |   NESTED-LOOP JOIN|    |1        |118 |
|5 |    HASH JOIN      |    |1        |81  |
|6 |     TABLE SCAN    |t3  |6        |37  |
|7 |     TABLE SCAN    |t1  |1        |36  |
|8 |    TABLE GET      |t2  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  6 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |162 |
|1 | SUBPLAN FILTER          |    |6        |156 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |119 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |119 |
|5 |    HASH OUTER JOIN      |    |1        |82  |
|6 |     TABLE SCAN          |t1  |6        |37  |
|7 |     TABLE SCAN          |t3  |1        |36  |
|8 |    TABLE GET            |t2  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)], [(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1], [t3.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t3.c2], [t3.c1]), filter(nil), 
      access([t3.c2], [t3.c1]), partitions(p0)
  8 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |157 |
|1 | SUBPLAN FILTER    |    |1        |156 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |118 |
|4 |   NESTED-LOOP JOIN|    |1        |118 |
|5 |    HASH JOIN      |    |1        |81  |
|6 |     TABLE SCAN    |t3  |6        |37  |
|7 |     TABLE SCAN    |t1  |1        |36  |
|8 |    TABLE GET      |t2  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  6 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |157 |
|1 | SUBPLAN FILTER          |    |1        |156 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |119 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |119 |
|5 |    HASH OUTER JOIN      |    |1        |82  |
|6 |     TABLE SCAN          |t1  |6        |37  |
|7 |     TABLE SCAN          |t3  |1        |36  |
|8 |    TABLE GET            |t2  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)], [(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1], [t3.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t3.c2], [t3.c1]), filter(nil), 
      access([t3.c2], [t3.c1]), partitions(p0)
  8 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |36       |161 |
|1 | HASH JOIN                |    |6        |88  |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  TABLE SCAN              |t3  |6        |37  |
|4 | MATERIAL                 |    |6        |47  |
|5 |  TABLE SCAN              |t2  |6        |40  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)

select * from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |  2 |    5 | 4    |
|  2 |    5 |  1 |    1 | o    |  4 |    5 | 1    |
|  2 |    5 |  1 |    1 | o    |  5 |    5 | 5    |
|  2 |    5 |  1 |    1 | o    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |  2 |    5 | 4    |
|  2 |    5 |  3 |    5 | b    |  4 |    5 | 1    |
|  2 |    5 |  3 |    5 | b    |  5 |    5 | 5    |
|  2 |    5 |  3 |    5 | b    |  6 |    5 | c    |
|  2 |    5 |  4 |    6 | o    |  2 |    5 | 4    |
|  2 |    5 |  4 |    6 | o    |  4 |    5 | 1    |
|  2 |    5 |  4 |    6 | o    |  5 |    5 | 5    |
|  2 |    5 |  4 |    6 | o    |  6 |    5 | c    |
|  2 |    5 |  5 |    7 | d    |  2 |    5 | 4    |
|  2 |    5 |  5 |    7 | d    |  4 |    5 | 1    |
|  2 |    5 |  5 |    7 | d    |  5 |    5 | 5    |
|  2 |    5 |  5 |    7 | d    |  6 |    5 | c    |
|  2 |    5 |  6 |    8 | c    |  2 |    5 | 4    |
|  2 |    5 |  6 |    8 | c    |  4 |    5 | 1    |
|  2 |    5 |  6 |    8 | c    |  5 |    5 | 5    |
|  2 |    5 |  6 |    8 | c    |  6 |    5 | c    |
|  3 |    2 |  1 |    1 | o    |  1 |    2 | 3    |
|  3 |    2 |  2 |    5 | c    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  1 |    2 | 3    |
|  3 |    2 |  4 |    6 | o    |  1 |    2 | 3    |
|  3 |    2 |  5 |    7 | d    |  1 |    2 | 3    |
|  3 |    2 |  6 |    8 | c    |  1 |    2 | 3    |
|  4 |    6 |  1 |    1 | o    |  3 |    6 | 1    |
|  4 |    6 |  2 |    5 | c    |  3 |    6 | 1    |
|  4 |    6 |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
|  4 |    6 |  5 |    7 | d    |  3 |    6 | 1    |
|  4 |    6 |  6 |    8 | c    |  3 |    6 | 1    |
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |36       |162 |
|1 | HASH JOIN                |    |6        |88  |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  TABLE SCAN              |t3  |6        |38  |
|4 | MATERIAL                 |    |6        |47  |
|5 |  TABLE SCAN              |t2  |6        |40  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |  2 |    5 | 4    |
|  2 |    5 |  1 |    1 | o    |  4 |    5 | 1    |
|  2 |    5 |  1 |    1 | o    |  5 |    5 | 5    |
|  2 |    5 |  1 |    1 | o    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |  2 |    5 | 4    |
|  2 |    5 |  3 |    5 | b    |  4 |    5 | 1    |
|  2 |    5 |  3 |    5 | b    |  5 |    5 | 5    |
|  2 |    5 |  3 |    5 | b    |  6 |    5 | c    |
|  2 |    5 |  4 |    6 | o    |  2 |    5 | 4    |
|  2 |    5 |  4 |    6 | o    |  4 |    5 | 1    |
|  2 |    5 |  4 |    6 | o    |  5 |    5 | 5    |
|  2 |    5 |  4 |    6 | o    |  6 |    5 | c    |
|  2 |    5 |  5 |    7 | d    |  2 |    5 | 4    |
|  2 |    5 |  5 |    7 | d    |  4 |    5 | 1    |
|  2 |    5 |  5 |    7 | d    |  5 |    5 | 5    |
|  2 |    5 |  5 |    7 | d    |  6 |    5 | c    |
|  2 |    5 |  6 |    8 | c    |  2 |    5 | 4    |
|  2 |    5 |  6 |    8 | c    |  4 |    5 | 1    |
|  2 |    5 |  6 |    8 | c    |  5 |    5 | 5    |
|  2 |    5 |  6 |    8 | c    |  6 |    5 | c    |
|  3 |    2 |  1 |    1 | o    |  1 |    2 | 3    |
|  3 |    2 |  2 |    5 | c    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  1 |    2 | 3    |
|  3 |    2 |  4 |    6 | o    |  1 |    2 | 3    |
|  3 |    2 |  5 |    7 | d    |  1 |    2 | 3    |
|  3 |    2 |  6 |    8 | c    |  1 |    2 | 3    |
|  4 |    6 |  1 |    1 | o    |  3 |    6 | 1    |
|  4 |    6 |  2 |    5 | c    |  3 |    6 | 1    |
|  4 |    6 |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
|  4 |    6 |  5 |    7 | d    |  3 |    6 | 1    |
|  4 |    6 |  6 |    8 | c    |  3 |    6 | 1    |
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |36       |171 |
|1 | SUBPLAN SCAN               |VIEW1|36       |166 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |36       |161 |
|3 |   HASH JOIN                |     |6        |88  |
|4 |    TABLE SCAN              |t1   |6        |37  |
|5 |    TABLE SCAN              |t3   |6        |37  |
|6 |   MATERIAL                 |     |6        |47  |
|7 |    TABLE SCAN              |t2   |6        |40  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  4 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)

insert into t5_temp (select * from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |36       |172 |
|1 | SUBPLAN SCAN               |VIEW1|36       |167 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |36       |162 |
|3 |   HASH JOIN                |     |6        |88  |
|4 |    TABLE SCAN              |t1   |6        |37  |
|5 |    TABLE SCAN              |t3   |6        |38  |
|6 |   MATERIAL                 |     |6        |47  |
|7 |    TABLE SCAN              |t2   |6        |40  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  4 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t2.c1 from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |169 |
|1 | SUBPLAN FILTER              |    |6        |163 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |125 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |125 |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |6        |88  |
|7 |     HASH JOIN               |    |6        |86  |
|8 |      TABLE SCAN             |t1  |6        |37  |
|9 |      TABLE SCAN             |t3  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t2.c1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)
  9 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

update t1 set c2 = (select t2.c1 from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t2.c1 from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |170 |
|1 | SUBPLAN FILTER              |    |6        |164 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |127 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |127 |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |6        |90  |
|7 |     HASH JOIN               |    |6        |87  |
|8 |      TABLE SCAN             |t1  |6        |37  |
|9 |      TABLE SCAN             |t3  |6        |38  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t2.c1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)
  9 - output([t3.c2]), filter([(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      access([t3.c1], [t3.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t2.c1 from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t2.c1 from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |164 |
|1 | SUBPLAN FILTER              |    |1        |163 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |125 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |125 |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |6        |88  |
|7 |     HASH JOIN               |    |6        |86  |
|8 |      TABLE SCAN             |t1  |6        |37  |
|9 |      TABLE SCAN             |t3  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t2.c1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)
  9 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

delete from t1 where c2 = (select t2.c1 from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |165 |
|1 | SUBPLAN FILTER              |    |1        |164 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |127 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |127 |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |6        |90  |
|7 |     HASH JOIN               |    |6        |87  |
|8 |      TABLE SCAN             |t1  |6        |37  |
|9 |      TABLE SCAN             |t3  |6        |38  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t2.c1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)
  9 - output([t3.c2]), filter([(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      access([t3.c1], [t3.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t1, t2, t3 where t3.c1 is not null and t1.c2 = t3.c2 and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |HASH JOIN        |    |6        |134 |
|1 | TABLE SCAN      |t3  |6        |37  |
|2 | MERGE OUTER JOIN|    |6        |80  |
|3 |  TABLE SCAN     |t1  |6        |37  |
|4 |  TABLE SCAN     |t2  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |6        |134 |
|1 | TABLE SCAN          |t3  |6        |37  |
|2 | MERGE OUTER JOIN    |    |6        |80  |
|3 |  TABLE SCAN         |t1  |6        |37  |
|4 |  TABLE SCAN         |t2  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |6        |136 |
|1 | SUBPLAN SCAN      |VIEW1|6        |135 |
|2 |  HASH JOIN        |     |6        |134 |
|3 |   TABLE SCAN      |t3   |6        |37  |
|4 |   MERGE OUTER JOIN|     |6        |80  |
|5 |    TABLE SCAN     |t1   |6        |37  |
|6 |    TABLE SCAN     |t2   |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  3 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t5_temp (select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |6        |136 |
|1 | SUBPLAN SCAN          |VIEW1|6        |135 |
|2 |  HASH RIGHT OUTER JOIN|     |6        |134 |
|3 |   TABLE SCAN          |t3   |6        |37  |
|4 |   MERGE OUTER JOIN    |     |6        |80  |
|5 |    TABLE SCAN         |t1   |6        |37  |
|6 |    TABLE SCAN         |t2   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  3 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |125 |
|1 | SUBPLAN FILTER|    |6        |119 |
|2 |  TABLE SCAN   |t1  |6        |37  |
|3 |  LIMIT        |    |1        |81  |
|4 |   HASH JOIN   |    |1        |81  |
|5 |    TABLE SCAN |t3  |6        |37  |
|6 |    TABLE SCAN |t1  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  5 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |162 |
|1 | SUBPLAN FILTER          |    |6        |156 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |119 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |119 |
|5 |    HASH OUTER JOIN      |    |1        |82  |
|6 |     TABLE SCAN          |t1  |6        |37  |
|7 |     TABLE SCAN          |t3  |1        |36  |
|8 |    TABLE GET            |t2  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1], [t3.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t3.c2], [t3.c1]), filter(nil), 
      access([t3.c2], [t3.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |119 |
|1 | SUBPLAN FILTER|    |1        |118 |
|2 |  TABLE SCAN   |t1  |1        |38  |
|3 |  LIMIT        |    |1        |81  |
|4 |   HASH JOIN   |    |1        |81  |
|5 |    TABLE SCAN |t3  |6        |37  |
|6 |    TABLE SCAN |t1  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  5 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |157 |
|1 | SUBPLAN FILTER          |    |1        |156 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |119 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |119 |
|5 |    HASH OUTER JOIN      |    |1        |82  |
|6 |     TABLE SCAN          |t1  |6        |37  |
|7 |     TABLE SCAN          |t3  |1        |36  |
|8 |    TABLE GET            |t2  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1], [t3.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t3.c2], [t3.c1]), filter(nil), 
      access([t3.c2], [t3.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 where t3.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |HASH JOIN        |    |6        |134 |
|1 | TABLE SCAN      |t3  |6        |37  |
|2 | MERGE OUTER JOIN|    |6        |80  |
|3 |  TABLE SCAN     |t1  |6        |37  |
|4 |  TABLE SCAN     |t2  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |HASH JOIN        |    |6        |135 |
|1 | TABLE SCAN      |t3  |6        |38  |
|2 | MERGE OUTER JOIN|    |6        |80  |
|3 |  TABLE SCAN     |t1  |6        |37  |
|4 |  TABLE SCAN     |t2  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |6        |136 |
|1 | SUBPLAN SCAN      |VIEW1|6        |135 |
|2 |  HASH JOIN        |     |6        |134 |
|3 |   TABLE SCAN      |t3   |6        |37  |
|4 |   MERGE OUTER JOIN|     |6        |80  |
|5 |    TABLE SCAN     |t1   |6        |37  |
|6 |    TABLE SCAN     |t2   |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t5_temp (select * from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |6        |136 |
|1 | SUBPLAN SCAN      |VIEW1|6        |135 |
|2 |  HASH JOIN        |     |6        |135 |
|3 |   TABLE SCAN      |t3   |6        |38  |
|4 |   MERGE OUTER JOIN|     |6        |80  |
|5 |    TABLE SCAN     |t1   |6        |37  |
|6 |    TABLE SCAN     |t2   |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |125 |
|1 | SUBPLAN FILTER|    |6        |119 |
|2 |  TABLE SCAN   |t1  |6        |37  |
|3 |  LIMIT        |    |1        |81  |
|4 |   HASH JOIN   |    |1        |81  |
|5 |    TABLE SCAN |t3  |6        |37  |
|6 |    TABLE SCAN |t1  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  5 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |162 |
|1 | SUBPLAN FILTER          |    |6        |156 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |119 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |119 |
|5 |    HASH JOIN            |    |1        |82  |
|6 |     TABLE SCAN          |t1  |6        |37  |
|7 |     TABLE SCAN          |t3  |1        |37  |
|8 |    TABLE GET            |t2  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t3.c2]), filter([(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |119 |
|1 | SUBPLAN FILTER|    |1        |118 |
|2 |  TABLE SCAN   |t1  |1        |38  |
|3 |  LIMIT        |    |1        |81  |
|4 |   HASH JOIN   |    |1        |81  |
|5 |    TABLE SCAN |t3  |6        |37  |
|6 |    TABLE SCAN |t1  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  5 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |157 |
|1 | SUBPLAN FILTER          |    |1        |156 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |119 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |119 |
|5 |    HASH JOIN            |    |1        |82  |
|6 |     TABLE SCAN          |t1  |6        |37  |
|7 |     TABLE SCAN          |t3  |1        |37  |
|8 |    TABLE GET            |t2  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t3.c2]), filter([(T_OP_IS_NOT, t3.c1, NULL, 0)]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1, t3 where t3.c1 is not null and t1.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 join t2 on t1.c1 = t2.c1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 join t2 on t1.c1 = t2.c1;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 join t2 on t1.c1 = t2.c1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 join t2 on t1.c1 = t2.c1;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 join t2 on t1.c1 = t2.c1);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |81  |
|1 | SUBPLAN SCAN|VIEW1|6        |80  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 join t2 on t1.c1 = t2.c1);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 join t2 on t1.c1 = t2.c1);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |81  |
|1 | SUBPLAN SCAN|VIEW1|6        |80  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 join t2 on t1.c1 = t2.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1, t2 where t1.c1 = t2.c1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1, t2 where t1.c1 = t2.c1;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1, t2 where t1.c1 = t2.c1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1, t2 where t1.c1 = t2.c1;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1, t2 where t1.c1 = t2.c1);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |81  |
|1 | SUBPLAN SCAN|VIEW1|6        |80  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1, t2 where t1.c1 = t2.c1);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1 = t2.c1);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |81  |
|1 | SUBPLAN SCAN|VIEW1|6        |80  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1 = t2.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 = t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 = t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 = t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 = t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |6        |122 |
|1 | MERGE JOIN |    |6        |80  |
|2 |  TABLE SCAN|t1  |6        |37  |
|3 |  TABLE SCAN|t2  |6        |37  |
|4 | TABLE SCAN |t3  |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |6        |122 |
|1 | MERGE JOIN |    |6        |80  |
|2 |  TABLE SCAN|t1  |6        |37  |
|3 |  TABLE SCAN|t2  |6        |37  |
|4 | TABLE SCAN |t3  |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |123 |
|1 | SUBPLAN SCAN |VIEW1|6        |123 |
|2 |  MERGE JOIN  |     |6        |122 |
|3 |   MERGE JOIN |     |6        |80  |
|4 |    TABLE SCAN|t1   |6        |37  |
|5 |    TABLE SCAN|t2   |6        |37  |
|6 |   TABLE SCAN |t3   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t5_temp (select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |123 |
|1 | SUBPLAN SCAN |VIEW1|6        |123 |
|2 |  MERGE JOIN  |     |6        |122 |
|3 |   MERGE JOIN |     |6        |80  |
|4 |    TABLE SCAN|t1   |6        |37  |
|5 |    TABLE SCAN|t2   |6        |37  |
|6 |   TABLE SCAN |t3   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |155 |
|1 | SUBPLAN FILTER    |    |6        |149 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE GET      |t3  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |155 |
|1 | SUBPLAN FILTER    |    |6        |149 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE GET      |t3  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |149 |
|1 | SUBPLAN FILTER    |    |1        |148 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE GET      |t3  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |149 |
|1 | SUBPLAN FILTER    |    |1        |148 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE GET      |t3  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |6        |122 |
|1 | MERGE JOIN |    |6        |80  |
|2 |  TABLE SCAN|t1  |6        |37  |
|3 |  TABLE SCAN|t2  |6        |37  |
|4 | TABLE SCAN |t3  |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select * from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |6        |122 |
|1 | MERGE JOIN |    |6        |80  |
|2 |  TABLE SCAN|t1  |6        |37  |
|3 |  TABLE SCAN|t2  |6        |37  |
|4 | TABLE SCAN |t3  |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |123 |
|1 | SUBPLAN SCAN |VIEW1|6        |123 |
|2 |  MERGE JOIN  |     |6        |122 |
|3 |   MERGE JOIN |     |6        |80  |
|4 |    TABLE SCAN|t1   |6        |37  |
|5 |    TABLE SCAN|t2   |6        |37  |
|6 |   TABLE SCAN |t3   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t5_temp (select * from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |123 |
|1 | SUBPLAN SCAN |VIEW1|6        |123 |
|2 |  MERGE JOIN  |     |6        |122 |
|3 |   MERGE JOIN |     |6        |80  |
|4 |    TABLE SCAN|t1   |6        |37  |
|5 |    TABLE SCAN|t2   |6        |37  |
|6 |   TABLE SCAN |t3   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |155 |
|1 | SUBPLAN FILTER    |    |6        |149 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE GET      |t3  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |155 |
|1 | SUBPLAN FILTER    |    |6        |149 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE GET      |t3  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |149 |
|1 | SUBPLAN FILTER    |    |1        |148 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE GET      |t3  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |149 |
|1 | SUBPLAN FILTER    |    |1        |148 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE GET      |t3  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |81  |
|1 | SUBPLAN SCAN|VIEW1|6        |80  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |81  |
|1 | SUBPLAN SCAN     |VIEW1|6        |80  |
|2 |  MERGE OUTER JOIN|     |6        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |117 |
|1 | SUBPLAN FILTER          |    |6        |111 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |73  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    TABLE GET            |t2  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |112 |
|1 | SUBPLAN FILTER          |    |1        |111 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |73  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    TABLE GET            |t2  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |81  |
|1 | SUBPLAN SCAN|VIEW1|6        |80  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |82  |
|1 | SUBPLAN SCAN|VIEW1|6        |81  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t2.c1 is not null and t1.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1>1 where t2.c1 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |98  |
|1 | TABLE SCAN               |t2  |6        |37  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1>1 where t2.c1 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1>1 where t2.c1 is not null;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |6        |98  |
|1 | TABLE SCAN           |t1  |6        |37  |
|2 | MATERIAL             |    |6        |44  |
|3 |  TABLE SCAN          |t2  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      conds([t1.c1 > 1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1>1 where t2.c1 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1>1 where t2.c1 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |106 |
|1 | SUBPLAN SCAN               |VIEW1|30       |102 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |98  |
|3 |   TABLE SCAN               |t2   |6        |37  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1>1 where t2.c1 is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1>1 where t2.c1 is not null);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |6        |99  |
|1 | SUBPLAN SCAN           |VIEW1|6        |99  |
|2 |  NESTED-LOOP OUTER JOIN|     |6        |98  |
|3 |   TABLE SCAN           |t1   |6        |37  |
|4 |   MATERIAL             |     |6        |44  |
|5 |    TABLE SCAN          |t2   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      conds([t1.c1 > 1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1>1 where t2.c1 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is not null limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |121 |
|1 | SUBPLAN FILTER          |    |6        |115 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |77  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |77  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    MATERIAL             |    |6        |38  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      conds([t1.c1 > 1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is not null limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |115 |
|1 | SUBPLAN FILTER          |    |1        |114 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |77  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |77  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    MATERIAL             |    |6        |38  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      conds([t1.c1 > 1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1, t2 where t1.c1 > 1 and t2.c1 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |98  |
|1 | TABLE SCAN               |t2  |6        |37  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1, t2 where t1.c1 > 1 and t2.c1 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c1 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |98  |
|1 | TABLE SCAN               |t2  |6        |38  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c1 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1, t2 where t1.c1 > 1 and t2.c1 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |106 |
|1 | SUBPLAN SCAN               |VIEW1|30       |102 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |98  |
|3 |   TABLE SCAN               |t2   |6        |37  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1, t2 where t1.c1 > 1 and t2.c1 is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c1 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |106 |
|1 | SUBPLAN SCAN               |VIEW1|30       |102 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |98  |
|3 |   TABLE SCAN               |t2   |6        |38  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c1 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  4 |
+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  4 |
+----+
EXPLAIN insert into t12_temp (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |82  |
|1 | SUBPLAN SCAN|VIEW1|6        |81  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t12_temp (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null);

rollback;
EXPLAIN insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |82  |
|1 | SUBPLAN SCAN     |VIEW1|6        |81  |
|2 |  MERGE OUTER JOIN|     |6        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  5 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |116 |
|1 | SUBPLAN FILTER          |    |6        |110 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |73  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    TABLE GET            |t2  |1        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1], [t1.c2])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c2]), filter([? = t2.c2]), 
      access([t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |111 |
|1 | SUBPLAN FILTER    |    |1        |110 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  5 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |111 |
|1 | SUBPLAN FILTER          |    |1        |110 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |73  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    TABLE GET            |t2  |1        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1], [t1.c2])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c2]), filter([? = t2.c2]), 
      access([t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  4 |
+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  4 |
+----+
EXPLAIN insert into t12_temp (select t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |82  |
|1 | SUBPLAN SCAN|VIEW1|6        |81  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t12_temp (select t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null);

rollback;
EXPLAIN insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |82  |
|1 | SUBPLAN SCAN|VIEW1|6        |81  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  5 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  5 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |111 |
|1 | SUBPLAN FILTER    |    |1        |110 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  5 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |111 |
|1 | SUBPLAN FILTER    |    |1        |110 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  5 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 = t2.c1 and t1.c2 = t2.c2 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 inner join t2 on t1.c1>1 where t2.c3 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |100 |
|1 | TABLE SCAN               |t2  |6        |40  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 inner join t2 on t1.c1>1 where t2.c3 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c3 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |100 |
|1 | TABLE SCAN               |t2  |6        |40  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c3 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 inner join t2 on t1.c1>1 where t2.c3 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |109 |
|1 | SUBPLAN SCAN               |VIEW1|30       |104 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |100 |
|3 |   TABLE SCAN               |t2   |6        |40  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 inner join t2 on t1.c1>1 where t2.c3 is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c3 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |109 |
|1 | SUBPLAN SCAN               |VIEW1|30       |104 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |100 |
|3 |   TABLE SCAN               |t2   |6        |40  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c3 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1, t2 where t1.c1 > 1 and t2.c3 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |100 |
|1 | TABLE SCAN               |t2  |6        |40  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1, t2 where t1.c1 > 1 and t2.c3 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c3 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |100 |
|1 | TABLE SCAN               |t2  |6        |40  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c3 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1, t2 where t1.c1 > 1 and t2.c3 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |109 |
|1 | SUBPLAN SCAN               |VIEW1|30       |104 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |100 |
|3 |   TABLE SCAN               |t2   |6        |40  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1, t2 where t1.c1 > 1 and t2.c3 is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c3 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |109 |
|1 | SUBPLAN SCAN               |VIEW1|30       |104 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |100 |
|3 |   TABLE SCAN               |t2   |6        |40  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c3 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1 inner join t2 on t1.c1>1 where t2.c2 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |98  |
|1 | TABLE SCAN               |t2  |6        |38  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 inner join t2 on t1.c1>1 where t2.c2 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c2 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |98  |
|1 | TABLE SCAN               |t2  |6        |38  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c2 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 inner join t2 on t1.c1>1 where t2.c2 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |106 |
|1 | SUBPLAN SCAN               |VIEW1|30       |102 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |98  |
|3 |   TABLE SCAN               |t2   |6        |38  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 inner join t2 on t1.c1>1 where t2.c2 is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c2 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |106 |
|1 | SUBPLAN SCAN               |VIEW1|30       |102 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |98  |
|3 |   TABLE SCAN               |t2   |6        |38  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c2 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1, t2 where t1.c1 > 1 and t2.c2 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |98  |
|1 | TABLE SCAN               |t2  |6        |38  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1, t2 where t1.c1 > 1 and t2.c2 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c2 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |98  |
|1 | TABLE SCAN               |t2  |6        |38  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c2 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1, t2 where t1.c1 > 1 and t2.c2 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |106 |
|1 | SUBPLAN SCAN               |VIEW1|30       |102 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |98  |
|3 |   TABLE SCAN               |t2   |6        |38  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1, t2 where t1.c1 > 1 and t2.c2 is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c2 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |106 |
|1 | SUBPLAN SCAN               |VIEW1|30       |102 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |98  |
|3 |   TABLE SCAN               |t2   |6        |38  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c2 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |81  |
|1 | SUBPLAN SCAN|VIEW1|6        |80  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |82  |
|1 | SUBPLAN SCAN|VIEW1|6        |81  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |81  |
|1 | SUBPLAN SCAN|VIEW1|6        |80  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |82  |
|1 | SUBPLAN SCAN|VIEW1|6        |81  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 and t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  4 |
+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  4 |
+----+
EXPLAIN insert into t12_temp (select t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |82  |
|1 | SUBPLAN SCAN|VIEW1|6        |81  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t12_temp (select t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null);

rollback;
EXPLAIN insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |82  |
|1 | SUBPLAN SCAN|VIEW1|6        |81  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  5 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  5 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |111 |
|1 | SUBPLAN FILTER    |    |1        |110 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  5 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |111 |
|1 | SUBPLAN FILTER    |    |1        |110 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  5 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c1 and t1.c2 = t2.c2 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  4 |
+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |6        |80  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  4 |
+----+
EXPLAIN insert into t12_temp (select t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |82  |
|1 | SUBPLAN SCAN|VIEW1|6        |81  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t12_temp (select t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null);

rollback;
EXPLAIN insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |82  |
|1 | SUBPLAN SCAN|VIEW1|6        |81  |
|2 |  MERGE JOIN |     |6        |80  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1], [t1.c2 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  5 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  5 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |111 |
|1 | SUBPLAN FILTER    |    |1        |110 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  5 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |111 |
|1 | SUBPLAN FILTER    |    |1        |110 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  5 - output([t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 and t1.c2=t2.c2 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 inner join t2 on t1.c1>1 where t2.c1 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |98  |
|1 | TABLE SCAN               |t2  |6        |37  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 inner join t2 on t1.c1>1 where t2.c1 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c1 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |98  |
|1 | TABLE SCAN               |t2  |6        |38  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c1 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 inner join t2 on t1.c1>1 where t2.c1 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |106 |
|1 | SUBPLAN SCAN               |VIEW1|30       |102 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |98  |
|3 |   TABLE SCAN               |t2   |6        |37  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 inner join t2 on t1.c1>1 where t2.c1 is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c1 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |106 |
|1 | SUBPLAN SCAN               |VIEW1|30       |102 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |98  |
|3 |   TABLE SCAN               |t2   |6        |38  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c1 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c1 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c1 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c1 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c1 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1, t2 where t1.c1 > 1 and t2.c1 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |98  |
|1 | TABLE SCAN               |t2  |6        |37  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1, t2 where t1.c1 > 1 and t2.c1 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c1 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |98  |
|1 | TABLE SCAN               |t2  |6        |38  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c1 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1, t2 where t1.c1 > 1 and t2.c1 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |106 |
|1 | SUBPLAN SCAN               |VIEW1|30       |102 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |98  |
|3 |   TABLE SCAN               |t2   |6        |37  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1, t2 where t1.c1 > 1 and t2.c1 is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c1 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |106 |
|1 | SUBPLAN SCAN               |VIEW1|30       |102 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |98  |
|3 |   TABLE SCAN               |t2   |6        |38  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c1 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c1, NULL, 0)]), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1 inner join t2 on t1.c1>1 where t2.c2 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |98  |
|1 | TABLE SCAN               |t2  |6        |38  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 inner join t2 on t1.c1>1 where t2.c2 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c2 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |98  |
|1 | TABLE SCAN               |t2  |6        |38  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c2 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 inner join t2 on t1.c1>1 where t2.c2 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |106 |
|1 | SUBPLAN SCAN               |VIEW1|30       |102 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |98  |
|3 |   TABLE SCAN               |t2   |6        |38  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 inner join t2 on t1.c1>1 where t2.c2 is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c2 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |106 |
|1 | SUBPLAN SCAN               |VIEW1|30       |102 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |98  |
|3 |   TABLE SCAN               |t2   |6        |38  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c2 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1, t2 where t1.c1 > 1 and t2.c2 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |98  |
|1 | TABLE SCAN               |t2  |6        |38  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1, t2 where t1.c1 > 1 and t2.c2 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c2 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |98  |
|1 | TABLE SCAN               |t2  |6        |38  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c2 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1, t2 where t1.c1 > 1 and t2.c2 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |106 |
|1 | SUBPLAN SCAN               |VIEW1|30       |102 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |98  |
|3 |   TABLE SCAN               |t2   |6        |38  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1, t2 where t1.c1 > 1 and t2.c2 is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c2 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |106 |
|1 | SUBPLAN SCAN               |VIEW1|30       |102 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |98  |
|3 |   TABLE SCAN               |t2   |6        |38  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c2], [t2.c1], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c2 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c2 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1 inner join t2 on t1.c1>1 where t2.c3 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |100 |
|1 | TABLE SCAN               |t2  |6        |40  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 inner join t2 on t1.c1>1 where t2.c3 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c3 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |100 |
|1 | TABLE SCAN               |t2  |6        |40  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c3 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 inner join t2 on t1.c1>1 where t2.c3 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |109 |
|1 | SUBPLAN SCAN               |VIEW1|30       |104 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |100 |
|3 |   TABLE SCAN               |t2   |6        |40  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 inner join t2 on t1.c1>1 where t2.c3 is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c3 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |109 |
|1 | SUBPLAN SCAN               |VIEW1|30       |104 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |100 |
|3 |   TABLE SCAN               |t2   |6        |40  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1>1 where t2.c3 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1>1 where t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1, t2 where t1.c1 > 1 and t2.c3 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |100 |
|1 | TABLE SCAN               |t2  |6        |40  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1, t2 where t1.c1 > 1 and t2.c3 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c3 is not null;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |30       |100 |
|1 | TABLE SCAN               |t2  |6        |40  |
|2 | MATERIAL                 |    |5        |39  |
|3 |  TABLE SCAN              |t1  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c3 is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  2 |    5 |  3 |    5 | b    |
|  2 |    5 |  4 |    6 | o    |
|  2 |    5 |  5 |    7 | d    |
|  2 |    5 |  6 |    8 | c    |
|  3 |    2 |  1 |    1 | o    |
|  3 |    2 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  3 |    2 |  4 |    6 | o    |
|  3 |    2 |  5 |    7 | d    |
|  3 |    2 |  6 |    8 | c    |
|  4 |    6 |  1 |    1 | o    |
|  4 |    6 |  2 |    5 | c    |
|  4 |    6 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  4 |    6 |  5 |    7 | d    |
|  4 |    6 |  6 |    8 | c    |
|  5 |    4 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  5 |    4 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  5 |    4 |  6 |    8 | c    |
|  6 |    7 |  1 |    1 | o    |
|  6 |    7 |  2 |    5 | c    |
|  6 |    7 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
|  6 |    7 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1, t2 where t1.c1 > 1 and t2.c3 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |109 |
|1 | SUBPLAN SCAN               |VIEW1|30       |104 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |100 |
|3 |   TABLE SCAN               |t2   |6        |40  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1, t2 where t1.c1 > 1 and t2.c3 is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c3 is not null);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |30       |109 |
|1 | SUBPLAN SCAN               |VIEW1|30       |104 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |30       |100 |
|3 |   TABLE SCAN               |t2   |6        |40  |
|4 |   MATERIAL                 |     |5        |39  |
|5 |    TABLE SCAN              |t1   |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c3], [t2.c1], [t2.c2]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1 > 1 and t2.c3 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |118 |
|1 | SUBPLAN FILTER              |    |6        |112 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t2  |1        |36  |
|6 |    MATERIAL                 |    |5        |38  |
|7 |     TABLE SCAN              |t1  |5        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([(T_OP_IS_NOT, t2.c3, NULL, 0)]), 
      access([t2.c3]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1 > 1 and t2.c3 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

################################################################################################################
EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |6        |138 |
|1 | MERGE OUTER JOIN     |    |6        |80  |
|2 |  TABLE SCAN          |t1  |6        |37  |
|3 |  TABLE SCAN          |t2  |6        |37  |
|4 | MATERIAL             |    |6        |44  |
|5 |  TABLE SCAN          |t3  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t1.c1 = t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |6        |138 |
|1 | MERGE OUTER JOIN     |    |6        |80  |
|2 |  TABLE SCAN          |t1  |6        |37  |
|3 |  TABLE SCAN          |t2  |6        |37  |
|4 | MATERIAL             |    |6        |44  |
|5 |  TABLE SCAN          |t3  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t1.c1 = t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |6        |140 |
|1 | SUBPLAN SCAN           |VIEW1|6        |139 |
|2 |  NESTED-LOOP OUTER JOIN|     |6        |138 |
|3 |   MERGE OUTER JOIN     |     |6        |80  |
|4 |    TABLE SCAN          |t1   |6        |37  |
|5 |    TABLE SCAN          |t2   |6        |37  |
|6 |   MATERIAL             |     |6        |44  |
|7 |    TABLE SCAN          |t3   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t1.c1 = t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t5_temp (select * from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |6        |140 |
|1 | SUBPLAN SCAN           |VIEW1|6        |139 |
|2 |  NESTED-LOOP OUTER JOIN|     |6        |138 |
|3 |   MERGE OUTER JOIN     |     |6        |80  |
|4 |    TABLE SCAN          |t1   |6        |37  |
|5 |    TABLE SCAN          |t2   |6        |37  |
|6 |   MATERIAL             |     |6        |44  |
|7 |    TABLE SCAN          |t3   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t1.c1 = t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1 limit 1);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                    |     |6        |157 |
|1 | SUBPLAN FILTER           |     |6        |151 |
|2 |  TABLE SCAN              |t1   |6        |37  |
|3 |  LIMIT                   |     |1        |113 |
|4 |   NESTED-LOOP OUTER JOIN |     |1        |113 |
|5 |    NESTED-LOOP OUTER JOIN|     |1        |73  |
|6 |     SUBPLAN SCAN         |VIEW1|1        |37  |
|7 |      TABLE SCAN          |t1   |1        |36  |
|8 |     TABLE GET            |t2   |1        |36  |
|9 |    MATERIAL              |     |6        |38  |
|10|     TABLE SCAN           |t3   |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      conds([VIEW1.t1.c1 = t2.c1]), nl_params_(nil)
  5 - output([VIEW1.t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_([VIEW1.t1.c1])
  6 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |158 |
|1 | SUBPLAN FILTER          |    |6        |152 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |114 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |114 |
|5 |    MERGE OUTER JOIN     |    |1        |74  |
|6 |     TABLE SCAN          |t1  |3        |37  |
|7 |     TABLE SCAN          |t2  |3        |37  |
|8 |    MATERIAL             |    |6        |38  |
|9 |     TABLE SCAN          |t3  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 = t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1 limit 1);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                    |     |1        |152 |
|1 | SUBPLAN FILTER           |     |1        |151 |
|2 |  TABLE SCAN              |t1   |1        |38  |
|3 |  LIMIT                   |     |1        |113 |
|4 |   NESTED-LOOP OUTER JOIN |     |1        |113 |
|5 |    NESTED-LOOP OUTER JOIN|     |1        |73  |
|6 |     SUBPLAN SCAN         |VIEW1|1        |37  |
|7 |      TABLE SCAN          |t1   |1        |36  |
|8 |     TABLE GET            |t2   |1        |36  |
|9 |    MATERIAL              |     |6        |38  |
|10|     TABLE SCAN           |t3   |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      conds([VIEW1.t1.c1 = t2.c1]), nl_params_(nil)
  5 - output([VIEW1.t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_([VIEW1.t1.c1])
  6 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |153 |
|1 | SUBPLAN FILTER          |    |1        |152 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |114 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |114 |
|5 |    MERGE OUTER JOIN     |    |1        |74  |
|6 |     TABLE SCAN          |t1  |3        |37  |
|7 |     TABLE SCAN          |t2  |3        |37  |
|8 |    MATERIAL             |    |6        |38  |
|9 |     TABLE SCAN          |t3  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 = t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null;
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |216      |390 |
|1 | NESTED-LOOP JOIN CARTESIAN|    |36       |196 |
|2 |  MERGE OUTER JOIN         |    |6        |80  |
|3 |   TABLE SCAN              |t2  |6        |37  |
|4 |   TABLE SCAN              |t3  |6        |37  |
|5 |  MATERIAL                 |    |6        |88  |
|6 |   MERGE OUTER JOIN        |    |6        |80  |
|7 |    TABLE SCAN             |t1  |6        |37  |
|8 |    TABLE SCAN             |t   |6        |37  |
|9 | MATERIAL                  |    |6        |40  |
|10|  TABLE SCAN               |tt  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [tt.c1], [tt.c2]), filter(nil), startup_filter([1]), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  5 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil)
  6 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)
  9 - output([tt.c1], [tt.c2]), filter(nil)
  10 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p0)

select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null;
+----+------+----+------+------+----+------+------+----+------+------+----+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   |
+----+------+----+------+------+----+------+------+----+------+------+----+------+
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |  1 |    1 |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |  2 |    5 |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |  3 |    2 |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |  4 |    6 |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |  5 |    4 |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |  6 |    7 |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |  1 |    1 |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |  2 |    5 |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |  3 |    2 |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |  4 |    6 |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |  5 |    4 |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |  6 |    7 |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |  1 |    1 |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |  2 |    5 |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |  3 |    2 |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |  4 |    6 |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |  5 |    4 |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |  6 |    7 |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |  1 |    1 |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |  2 |    5 |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |  3 |    2 |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |  4 |    6 |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |  5 |    4 |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |  6 |    7 |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |  1 |    1 |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |  2 |    5 |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |  3 |    2 |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |  4 |    6 |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |  5 |    4 |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |  6 |    7 |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |  1 |    1 |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |  2 |    5 |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |  3 |    2 |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |  4 |    6 |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |  5 |    4 |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |  6 |    7 |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |  1 |    1 |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |  2 |    5 |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |  3 |    2 |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |  4 |    6 |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |  5 |    4 |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |  6 |    7 |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |  1 |    1 |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |  2 |    5 |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |  3 |    2 |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |  4 |    6 |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |  5 |    4 |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |  6 |    7 |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |  1 |    1 |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |  2 |    5 |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |  3 |    2 |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |  4 |    6 |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |  5 |    4 |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |  6 |    7 |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |  1 |    1 |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |  2 |    5 |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |  3 |    2 |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |  4 |    6 |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |  5 |    4 |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |  6 |    7 |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |  1 |    1 |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |  2 |    5 |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |  3 |    2 |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |  4 |    6 |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |  5 |    4 |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |  6 |    7 |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |  1 |    1 |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |  2 |    5 |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |  3 |    2 |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |  4 |    6 |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |  5 |    4 |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |  6 |    7 |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |  1 |    1 |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |  2 |    5 |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |  3 |    2 |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |  4 |    6 |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |  5 |    4 |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |  6 |    7 |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |  1 |    1 |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |  2 |    5 |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |  3 |    2 |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |  4 |    6 |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |  5 |    4 |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |  6 |    7 |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |  1 |    1 |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |  2 |    5 |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |  3 |    2 |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |  4 |    6 |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |  5 |    4 |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |  6 |    7 |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |  1 |    1 |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |  2 |    5 |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |  3 |    2 |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |  4 |    6 |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |  5 |    4 |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |  6 |    7 |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |  1 |    1 |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |  2 |    5 |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |  3 |    2 |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |  4 |    6 |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |  5 |    4 |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |  6 |    7 |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |  1 |    1 |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |  2 |    5 |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |  3 |    2 |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |  4 |    6 |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |  5 |    4 |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |  6 |    7 |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |  1 |    1 |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |  2 |    5 |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |  3 |    2 |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |  4 |    6 |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |  5 |    4 |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |  6 |    7 |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |  1 |    1 |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |  2 |    5 |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |  3 |    2 |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |  4 |    6 |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |  5 |    4 |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |  6 |    7 |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |  1 |    1 |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |  2 |    5 |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |  3 |    2 |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |  4 |    6 |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |  5 |    4 |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |  6 |    7 |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |  1 |    1 |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |  2 |    5 |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |  3 |    2 |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |  4 |    6 |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |  5 |    4 |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |  6 |    7 |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |  1 |    1 |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |  2 |    5 |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |  3 |    2 |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |  4 |    6 |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |  5 |    4 |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |  6 |    7 |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |  1 |    1 |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |  2 |    5 |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |  3 |    2 |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |  4 |    6 |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |  5 |    4 |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |  6 |    7 |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |  1 |    1 |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |  2 |    5 |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |  3 |    2 |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |  4 |    6 |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |  5 |    4 |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |  6 |    7 |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |  1 |    1 |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |  2 |    5 |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |  3 |    2 |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |  4 |    6 |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |  5 |    4 |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |  6 |    7 |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |  1 |    1 |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |  2 |    5 |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |  3 |    2 |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |  4 |    6 |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |  5 |    4 |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |  6 |    7 |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |  1 |    1 |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |  2 |    5 |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |  3 |    2 |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |  4 |    6 |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |  5 |    4 |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |  6 |    7 |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |  1 |    1 |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |  2 |    5 |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |  3 |    2 |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |  4 |    6 |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |  5 |    4 |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |  6 |    7 |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |  1 |    1 |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |  2 |    5 |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |  3 |    2 |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |  4 |    6 |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |  5 |    4 |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |  6 |    7 |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |  1 |    1 |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |  2 |    5 |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |  3 |    2 |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |  4 |    6 |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |  5 |    4 |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |  6 |    7 |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |  1 |    1 |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |  2 |    5 |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |  3 |    2 |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |  4 |    6 |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |  5 |    4 |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |  6 |    7 |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |  1 |    1 |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |  2 |    5 |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |  3 |    2 |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |  4 |    6 |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |  5 |    4 |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |  6 |    7 |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |  1 |    1 |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |  2 |    5 |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |  3 |    2 |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |  4 |    6 |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |  5 |    4 |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |  6 |    7 |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |  1 |    1 |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |  2 |    5 |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |  3 |    2 |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |  4 |    6 |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |  5 |    4 |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |  6 |    7 |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |  1 |    1 |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |  2 |    5 |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |  3 |    2 |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |  4 |    6 |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |  5 |    4 |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |  6 |    7 |
+----+------+----+------+------+----+------+------+----+------+------+----+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null;
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |216      |390 |
|1 | NESTED-LOOP JOIN CARTESIAN|    |36       |196 |
|2 |  MERGE OUTER JOIN         |    |6        |80  |
|3 |   TABLE SCAN              |t2  |6        |37  |
|4 |   TABLE SCAN              |t3  |6        |37  |
|5 |  MATERIAL                 |    |6        |89  |
|6 |   MERGE OUTER JOIN        |    |6        |80  |
|7 |    TABLE SCAN             |t1  |6        |38  |
|8 |    TABLE SCAN             |t   |6        |37  |
|9 | MATERIAL                  |    |6        |40  |
|10|  TABLE SCAN               |tt  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [tt.c1], [tt.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  5 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil)
  6 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter([(T_OP_IS_NOT, t1.c1, NULL, 0)]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)
  9 - output([tt.c1], [tt.c2]), filter(nil)
  10 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null;
+----+------+----+------+------+----+------+------+----+------+------+----+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   |
+----+------+----+------+------+----+------+------+----+------+------+----+------+
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |  1 |    1 |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |  2 |    5 |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |  3 |    2 |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |  4 |    6 |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |  5 |    4 |
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |  6 |    7 |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |  1 |    1 |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |  2 |    5 |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |  3 |    2 |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |  4 |    6 |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |  5 |    4 |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |  6 |    7 |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |  1 |    1 |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |  2 |    5 |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |  3 |    2 |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |  4 |    6 |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |  5 |    4 |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |  6 |    7 |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |  1 |    1 |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |  2 |    5 |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |  3 |    2 |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |  4 |    6 |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |  5 |    4 |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |  6 |    7 |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |  1 |    1 |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |  2 |    5 |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |  3 |    2 |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |  4 |    6 |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |  5 |    4 |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |  6 |    7 |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |  1 |    1 |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |  2 |    5 |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |  3 |    2 |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |  4 |    6 |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |  5 |    4 |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |  6 |    7 |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |  1 |    1 |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |  2 |    5 |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |  3 |    2 |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |  4 |    6 |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |  5 |    4 |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |  6 |    7 |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |  1 |    1 |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |  2 |    5 |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |  3 |    2 |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |  4 |    6 |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |  5 |    4 |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |  6 |    7 |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |  1 |    1 |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |  2 |    5 |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |  3 |    2 |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |  4 |    6 |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |  5 |    4 |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |  6 |    7 |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |  1 |    1 |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |  2 |    5 |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |  3 |    2 |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |  4 |    6 |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |  5 |    4 |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |  6 |    7 |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |  1 |    1 |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |  2 |    5 |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |  3 |    2 |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |  4 |    6 |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |  5 |    4 |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |  6 |    7 |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |  1 |    1 |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |  2 |    5 |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |  3 |    2 |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |  4 |    6 |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |  5 |    4 |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |  6 |    7 |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |  1 |    1 |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |  2 |    5 |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |  3 |    2 |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |  4 |    6 |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |  5 |    4 |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |  6 |    7 |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |  1 |    1 |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |  2 |    5 |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |  3 |    2 |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |  4 |    6 |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |  5 |    4 |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |  6 |    7 |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |  1 |    1 |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |  2 |    5 |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |  3 |    2 |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |  4 |    6 |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |  5 |    4 |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |  6 |    7 |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |  1 |    1 |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |  2 |    5 |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |  3 |    2 |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |  4 |    6 |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |  5 |    4 |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |  6 |    7 |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |  1 |    1 |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |  2 |    5 |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |  3 |    2 |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |  4 |    6 |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |  5 |    4 |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |  6 |    7 |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |  1 |    1 |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |  2 |    5 |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |  3 |    2 |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |  4 |    6 |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |  5 |    4 |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |  6 |    7 |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |  1 |    1 |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |  2 |    5 |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |  3 |    2 |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |  4 |    6 |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |  5 |    4 |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |  6 |    7 |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |  1 |    1 |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |  2 |    5 |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |  3 |    2 |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |  4 |    6 |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |  5 |    4 |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |  6 |    7 |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |  1 |    1 |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |  2 |    5 |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |  3 |    2 |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |  4 |    6 |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |  5 |    4 |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |  6 |    7 |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |  1 |    1 |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |  2 |    5 |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |  3 |    2 |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |  4 |    6 |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |  5 |    4 |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |  6 |    7 |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |  1 |    1 |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |  2 |    5 |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |  3 |    2 |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |  4 |    6 |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |  5 |    4 |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |  6 |    7 |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |  1 |    1 |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |  2 |    5 |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |  3 |    2 |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |  4 |    6 |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |  5 |    4 |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |  6 |    7 |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |  1 |    1 |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |  2 |    5 |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |  3 |    2 |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |  4 |    6 |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |  5 |    4 |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |  6 |    7 |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |  1 |    1 |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |  2 |    5 |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |  3 |    2 |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |  4 |    6 |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |  5 |    4 |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |  6 |    7 |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |  1 |    1 |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |  2 |    5 |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |  3 |    2 |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |  4 |    6 |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |  5 |    4 |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |  6 |    7 |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |  1 |    1 |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |  2 |    5 |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |  3 |    2 |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |  4 |    6 |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |  5 |    4 |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |  6 |    7 |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |  1 |    1 |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |  2 |    5 |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |  3 |    2 |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |  4 |    6 |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |  5 |    4 |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |  6 |    7 |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |  1 |    1 |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |  2 |    5 |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |  3 |    2 |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |  4 |    6 |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |  5 |    4 |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |  6 |    7 |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |  1 |    1 |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |  2 |    5 |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |  3 |    2 |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |  4 |    6 |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |  5 |    4 |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |  6 |    7 |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |  1 |    1 |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |  2 |    5 |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |  3 |    2 |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |  4 |    6 |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |  5 |    4 |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |  6 |    7 |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |  1 |    1 |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |  2 |    5 |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |  3 |    2 |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |  4 |    6 |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |  5 |    4 |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |  6 |    7 |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |  1 |    1 |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |  2 |    5 |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |  3 |    2 |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |  4 |    6 |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |  5 |    4 |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |  6 |    7 |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |  1 |    1 |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |  2 |    5 |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |  3 |    2 |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |  4 |    6 |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |  5 |    4 |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |  6 |    7 |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |  1 |    1 |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |  2 |    5 |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |  3 |    2 |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |  4 |    6 |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |  5 |    4 |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |  6 |    7 |
+----+------+----+------+------+----+------+------+----+------+------+----+------+
EXPLAIN insert into t10_temp (select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null);
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |216      |449 |
|1 | SUBPLAN SCAN                |VIEW1|216      |420 |
|2 |  NESTED-LOOP JOIN CARTESIAN |     |216      |390 |
|3 |   NESTED-LOOP JOIN CARTESIAN|     |36       |196 |
|4 |    MERGE OUTER JOIN         |     |6        |80  |
|5 |     TABLE SCAN              |t2   |6        |37  |
|6 |     TABLE SCAN              |t3   |6        |37  |
|7 |    MATERIAL                 |     |6        |88  |
|8 |     MERGE OUTER JOIN        |     |6        |80  |
|9 |      TABLE SCAN             |t1   |6        |37  |
|10|      TABLE SCAN             |t    |6        |37  |
|11|   MATERIAL                  |     |6        |40  |
|12|    TABLE SCAN               |tt   |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t10_temp: ({t10_temp: (t10_temp.__pk_increment, t10_temp.a, t10_temp.b, t10_temp.c, t10_temp.d, t10_temp.e, t10_temp.f, t10_temp.g, t10_temp.h, t10_temp.i, t10_temp.j, t10_temp.k, t10_temp.l, t10_temp.m)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), startup_filter([1]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [tt.c1], [tt.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  7 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil)
  8 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  10 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)
  11 - output([tt.c1], [tt.c2]), filter(nil)
  12 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p0)

insert into t10_temp (select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null);

rollback;
EXPLAIN insert into t10_temp (select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null);
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |216      |450 |
|1 | SUBPLAN SCAN                |VIEW1|216      |420 |
|2 |  NESTED-LOOP JOIN CARTESIAN |     |216      |390 |
|3 |   NESTED-LOOP JOIN CARTESIAN|     |36       |196 |
|4 |    MERGE OUTER JOIN         |     |6        |80  |
|5 |     TABLE SCAN              |t2   |6        |37  |
|6 |     TABLE SCAN              |t3   |6        |37  |
|7 |    MATERIAL                 |     |6        |89  |
|8 |     MERGE OUTER JOIN        |     |6        |80  |
|9 |      TABLE SCAN             |t1   |6        |38  |
|10|      TABLE SCAN             |t    |6        |37  |
|11|   MATERIAL                  |     |6        |40  |
|12|    TABLE SCAN               |tt   |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t10_temp: ({t10_temp: (t10_temp.__pk_increment, t10_temp.a, t10_temp.b, t10_temp.c, t10_temp.d, t10_temp.e, t10_temp.f, t10_temp.g, t10_temp.h, t10_temp.i, t10_temp.j, t10_temp.k, t10_temp.l, t10_temp.m)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [tt.c1], [tt.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  7 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil)
  8 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  9 - output([t1.c1], [t1.c2]), filter([(T_OP_IS_NOT, t1.c1, NULL, 0)]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  10 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)
  11 - output([tt.c1], [tt.c2]), filter(nil)
  12 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p0)

insert into t10_temp (select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |6        |156 |
|1 | SUBPLAN FILTER               |    |6        |150 |
|2 |  TABLE SCAN                  |t1  |6        |37  |
|3 |  LIMIT                       |    |1        |113 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |113 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|6 |     TABLE SCAN               |t1  |1        |36  |
|7 |     MATERIAL                 |    |6        |38  |
|8 |      TABLE SCAN              |t2  |6        |37  |
|9 |    MATERIAL                  |    |6        |38  |
|10|     TABLE SCAN               |tt  |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([1]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([1]), filter(nil)
  8 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      access([tt.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |6        |236 |
|1 | SUBPLAN FILTER               |    |6        |230 |
|2 |  TABLE SCAN                  |t1  |6        |37  |
|3 |  LIMIT                       |    |1        |192 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |192 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |153 |
|6 |     MERGE OUTER JOIN         |    |1        |72  |
|7 |      TABLE SCAN              |t1  |1        |36  |
|8 |      TABLE SCAN              |t   |1        |36  |
|9 |     MATERIAL                 |    |6        |81  |
|10|      MERGE OUTER JOIN        |    |6        |79  |
|11|       TABLE SCAN             |t2  |6        |37  |
|12|       TABLE SCAN             |t3  |6        |37  |
|13|    MATERIAL                  |    |6        |38  |
|14|     TABLE SCAN               |tt  |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  7 - output([t1.c1]), filter([(T_OP_IS_NOT, t1.c1, NULL, 0)]), 
      access([t1.c1]), partitions(p0)
  8 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  13 - output([1]), filter(nil)
  14 - output([1]), filter(nil), 
      access([tt.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |151 |
|1 | SUBPLAN FILTER               |    |1        |150 |
|2 |  TABLE SCAN                  |t1  |1        |38  |
|3 |  LIMIT                       |    |1        |113 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |113 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|6 |     TABLE SCAN               |t1  |1        |36  |
|7 |     MATERIAL                 |    |6        |38  |
|8 |      TABLE SCAN              |t2  |6        |37  |
|9 |    MATERIAL                  |    |6        |38  |
|10|     TABLE SCAN               |tt  |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([1]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([1]), filter(nil)
  8 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      access([tt.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |230 |
|1 | SUBPLAN FILTER               |    |1        |229 |
|2 |  TABLE SCAN                  |t1  |1        |38  |
|3 |  LIMIT                       |    |1        |192 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |192 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |153 |
|6 |     MERGE OUTER JOIN         |    |1        |72  |
|7 |      TABLE SCAN              |t1  |1        |36  |
|8 |      TABLE SCAN              |t   |1        |36  |
|9 |     MATERIAL                 |    |6        |81  |
|10|      MERGE OUTER JOIN        |    |6        |79  |
|11|       TABLE SCAN             |t2  |6        |37  |
|12|       TABLE SCAN             |t3  |6        |37  |
|13|    MATERIAL                  |    |6        |38  |
|14|     TABLE SCAN               |tt  |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  7 - output([t1.c1]), filter([(T_OP_IS_NOT, t1.c1, NULL, 0)]), 
      access([t1.c1]), partitions(p0)
  8 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  13 - output([1]), filter(nil)
  14 - output([1]), filter(nil), 
      access([tt.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |NESTED-LOOP JOIN |    |1        |145 |
|1 | NESTED-LOOP JOIN|    |1        |138 |
|2 |  HASH JOIN      |    |6        |87  |
|3 |   TABLE SCAN    |t1  |6        |37  |
|4 |   TABLE SCAN    |tt  |6        |37  |
|5 |  MATERIAL       |    |6        |38  |
|6 |   TABLE SCAN    |t2  |6        |37  |
|7 | TABLE GET       |t3  |1        |36  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  1 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  2 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

select t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1;
+----+
| c1 |
+----+
+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |NESTED-LOOP JOIN |    |1        |145 |
|1 | NESTED-LOOP JOIN|    |1        |138 |
|2 |  HASH JOIN      |    |6        |87  |
|3 |   TABLE SCAN    |t1  |6        |37  |
|4 |   TABLE SCAN    |tt  |6        |37  |
|5 |  MATERIAL       |    |6        |38  |
|6 |   TABLE SCAN    |t2  |6        |37  |
|7 | TABLE GET       |t3  |1        |36  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  1 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  2 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1;
+----+
| c1 |
+----+
+----+
EXPLAIN insert into t12_temp (select t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |1        |145 |
|1 | SUBPLAN SCAN      |VIEW1|1        |145 |
|2 |  NESTED-LOOP JOIN |     |1        |145 |
|3 |   NESTED-LOOP JOIN|     |1        |138 |
|4 |    HASH JOIN      |     |6        |87  |
|5 |     TABLE SCAN    |t1   |6        |37  |
|6 |     TABLE SCAN    |tt   |6        |37  |
|7 |    MATERIAL       |     |6        |38  |
|8 |     TABLE SCAN    |t2   |6        |37  |
|9 |   TABLE GET       |t3   |1        |36  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  3 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  4 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

insert into t12_temp (select t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1);

rollback;
EXPLAIN insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |1        |145 |
|1 | SUBPLAN SCAN      |VIEW1|1        |145 |
|2 |  NESTED-LOOP JOIN |     |1        |145 |
|3 |   NESTED-LOOP JOIN|     |1        |138 |
|4 |    HASH JOIN      |     |6        |87  |
|5 |     TABLE SCAN    |t1   |6        |37  |
|6 |     TABLE SCAN    |tt   |6        |37  |
|7 |    MATERIAL       |     |6        |38  |
|8 |     TABLE SCAN    |t2   |6        |37  |
|9 |   TABLE GET       |t3   |1        |36  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  3 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  4 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |6        |189 |
|1 | SUBPLAN FILTER     |    |6        |183 |
|2 |  TABLE SCAN        |t1  |6        |37  |
|3 |  LIMIT             |    |1        |145 |
|4 |   NESTED-LOOP JOIN |    |1        |145 |
|5 |    NESTED-LOOP JOIN|    |1        |138 |
|6 |     HASH JOIN      |    |6        |87  |
|7 |      TABLE SCAN    |t1  |6        |37  |
|8 |      TABLE SCAN    |tt  |6        |37  |
|9 |     MATERIAL       |    |6        |38  |
|10|      TABLE SCAN    |t2  |6        |37  |
|11|    TABLE GET       |t3  |1        |36  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  6 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |6        |189 |
|1 | SUBPLAN FILTER     |    |6        |183 |
|2 |  TABLE SCAN        |t1  |6        |37  |
|3 |  LIMIT             |    |1        |145 |
|4 |   NESTED-LOOP JOIN |    |1        |145 |
|5 |    NESTED-LOOP JOIN|    |1        |138 |
|6 |     HASH JOIN      |    |6        |87  |
|7 |      TABLE SCAN    |t1  |6        |37  |
|8 |      TABLE SCAN    |tt  |6        |37  |
|9 |     MATERIAL       |    |6        |38  |
|10|      TABLE SCAN    |t2  |6        |37  |
|11|    TABLE GET       |t3  |1        |36  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  6 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |184 |
|1 | SUBPLAN FILTER     |    |1        |183 |
|2 |  TABLE SCAN        |t1  |1        |38  |
|3 |  LIMIT             |    |1        |145 |
|4 |   NESTED-LOOP JOIN |    |1        |145 |
|5 |    NESTED-LOOP JOIN|    |1        |138 |
|6 |     HASH JOIN      |    |6        |87  |
|7 |      TABLE SCAN    |t1  |6        |37  |
|8 |      TABLE SCAN    |tt  |6        |37  |
|9 |     MATERIAL       |    |6        |38  |
|10|      TABLE SCAN    |t2  |6        |37  |
|11|    TABLE GET       |t3  |1        |36  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  6 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |184 |
|1 | SUBPLAN FILTER     |    |1        |183 |
|2 |  TABLE SCAN        |t1  |1        |38  |
|3 |  LIMIT             |    |1        |145 |
|4 |   NESTED-LOOP JOIN |    |1        |145 |
|5 |    NESTED-LOOP JOIN|    |1        |138 |
|6 |     HASH JOIN      |    |6        |87  |
|7 |      TABLE SCAN    |t1  |6        |37  |
|8 |      TABLE SCAN    |tt  |6        |37  |
|9 |     MATERIAL       |    |6        |38  |
|10|      TABLE SCAN    |t2  |6        |37  |
|11|    TABLE GET       |t3  |1        |36  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  6 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |36       |196 |
|1 | MERGE OUTER JOIN         |    |6        |80  |
|2 |  TABLE SCAN              |t2  |6        |37  |
|3 |  TABLE SCAN              |t3  |6        |37  |
|4 | MATERIAL                 |    |6        |88  |
|5 |  MERGE OUTER JOIN        |    |6        |80  |
|6 |   TABLE SCAN             |t1  |6        |37  |
|7 |   TABLE SCAN             |t   |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil)
  5 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)

select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |36       |196 |
|1 | MERGE OUTER JOIN         |    |6        |80  |
|2 |  TABLE SCAN              |t2  |6        |37  |
|3 |  TABLE SCAN              |t3  |6        |37  |
|4 | MATERIAL                 |    |6        |88  |
|5 |  MERGE OUTER JOIN        |    |6        |80  |
|6 |   TABLE SCAN             |t1  |6        |37  |
|7 |   TABLE SCAN             |t   |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil)
  5 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |
|  1 |    1 |  1 |    1 | o    |  2 |    5 | c    |  2 |    5 | 4    |
|  1 |    1 |  1 |    1 | o    |  3 |    5 | b    |  3 |    6 | 1    |
|  1 |    1 |  1 |    1 | o    |  4 |    6 | o    |  4 |    5 | 1    |
|  1 |    1 |  1 |    1 | o    |  5 |    7 | d    |  5 |    5 | 5    |
|  1 |    1 |  1 |    1 | o    |  6 |    8 | c    |  6 |    5 | c    |
|  2 |    5 |  2 |    5 | c    |  1 |    1 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  3 |    5 | b    |  3 |    6 | 1    |
|  2 |    5 |  2 |    5 | c    |  4 |    6 | o    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    7 | d    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    8 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  1 |    1 | o    |  1 |    2 | 3    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |
|  3 |    2 |  3 |    5 | b    |  4 |    6 | o    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  5 |    7 | d    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  6 |    8 | c    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  1 |    1 | o    |  1 |    2 | 3    |
|  4 |    6 |  4 |    6 | o    |  2 |    5 | c    |  2 |    5 | 4    |
|  4 |    6 |  4 |    6 | o    |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |
|  4 |    6 |  4 |    6 | o    |  5 |    7 | d    |  5 |    5 | 5    |
|  4 |    6 |  4 |    6 | o    |  6 |    8 | c    |  6 |    5 | c    |
|  5 |    4 |  5 |    7 | d    |  1 |    1 | o    |  1 |    2 | 3    |
|  5 |    4 |  5 |    7 | d    |  2 |    5 | c    |  2 |    5 | 4    |
|  5 |    4 |  5 |    7 | d    |  3 |    5 | b    |  3 |    6 | 1    |
|  5 |    4 |  5 |    7 | d    |  4 |    6 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |
|  5 |    4 |  5 |    7 | d    |  6 |    8 | c    |  6 |    5 | c    |
|  6 |    7 |  6 |    8 | c    |  1 |    1 | o    |  1 |    2 | 3    |
|  6 |    7 |  6 |    8 | c    |  2 |    5 | c    |  2 |    5 | 4    |
|  6 |    7 |  6 |    8 | c    |  3 |    5 | b    |  3 |    6 | 1    |
|  6 |    7 |  6 |    8 | c    |  4 |    6 | o    |  4 |    5 | 1    |
|  6 |    7 |  6 |    8 | c    |  5 |    7 | d    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |36       |206 |
|1 | SUBPLAN SCAN               |VIEW1|36       |201 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |36       |196 |
|3 |   MERGE OUTER JOIN         |     |6        |80  |
|4 |    TABLE SCAN              |t2   |6        |37  |
|5 |    TABLE SCAN              |t3   |6        |37  |
|6 |   MATERIAL                 |     |6        |88  |
|7 |    MERGE OUTER JOIN        |     |6        |80  |
|8 |     TABLE SCAN             |t1   |6        |37  |
|9 |     TABLE SCAN             |t    |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil)
  7 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)

insert into t7_temp (select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |36       |206 |
|1 | SUBPLAN SCAN               |VIEW1|36       |201 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |36       |196 |
|3 |   MERGE OUTER JOIN         |     |6        |80  |
|4 |    TABLE SCAN              |t2   |6        |37  |
|5 |    TABLE SCAN              |t3   |6        |37  |
|6 |   MATERIAL                 |     |6        |88  |
|7 |    MERGE OUTER JOIN        |     |6        |80  |
|8 |     TABLE SCAN             |t1   |6        |37  |
|9 |     TABLE SCAN             |t    |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil)
  7 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |119 |
|1 | SUBPLAN FILTER              |    |6        |113 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t1  |1        |36  |
|6 |    MATERIAL                 |    |6        |38  |
|7 |     TABLE SCAN              |t2  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |198 |
|1 | SUBPLAN FILTER              |    |6        |192 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |154 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |154 |
|5 |    MERGE OUTER JOIN         |    |1        |73  |
|6 |     TABLE SCAN              |t1  |1        |36  |
|7 |     TABLE SCAN              |t   |1        |36  |
|8 |    MATERIAL                 |    |6        |81  |
|9 |     MERGE OUTER JOIN        |    |6        |79  |
|10|      TABLE SCAN             |t2  |6        |37  |
|11|      TABLE SCAN             |t3  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t1  |1        |36  |
|6 |    MATERIAL                 |    |6        |38  |
|7 |     TABLE SCAN              |t2  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |193 |
|1 | SUBPLAN FILTER              |    |1        |192 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |154 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |154 |
|5 |    MERGE OUTER JOIN         |    |1        |73  |
|6 |     TABLE SCAN              |t1  |1        |36  |
|7 |     TABLE SCAN              |t   |1        |36  |
|8 |    MATERIAL                 |    |6        |81  |
|9 |     MERGE OUTER JOIN        |    |6        |79  |
|10|      TABLE SCAN             |t2  |6        |37  |
|11|      TABLE SCAN             |t3  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |1        |151 |
|1 | NESTED-LOOP JOIN     |    |1        |150 |
|2 |  NESTED-LOOP JOIN    |    |1        |143 |
|3 |   TABLE SCAN         |t2  |6        |37  |
|4 |   MATERIAL           |    |6        |92  |
|5 |    HASH JOIN         |    |6        |87  |
|6 |     TABLE SCAN       |t1  |6        |37  |
|7 |     TABLE SCAN       |tt  |6        |37  |
|8 |  TABLE GET           |t3  |1        |36  |
|9 | TABLE GET            |t   |1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [tt.c1], [tt.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [tt.c1], [tt.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1], [t2.c1])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [tt.c1], [tt.c2]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [tt.c1], [tt.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2], [tt.c1], [tt.c2]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  9 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)

select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1;
+----+------+----+------+------+----+------+------+----+------+------+----+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   |
+----+------+----+------+------+----+------+------+----+------+------+----+------+
+----+------+----+------+------+----+------+------+----+------+------+----+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN |    |1        |151 |
|1 | NESTED-LOOP OUTER JOIN|    |1        |150 |
|2 |  NESTED-LOOP JOIN     |    |1        |143 |
|3 |   TABLE SCAN          |t2  |6        |37  |
|4 |   MATERIAL            |    |6        |92  |
|5 |    HASH JOIN          |    |6        |87  |
|6 |     TABLE SCAN        |t1  |6        |37  |
|7 |     TABLE SCAN        |tt  |6        |37  |
|8 |  TABLE GET            |t3  |1        |36  |
|9 | TABLE GET             |t   |1        |36  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [tt.c1], [tt.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [tt.c1], [tt.c2]), filter([t1.c1 = t3.c1]), 
      conds(nil), nl_params_([t2.c1])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [tt.c1], [tt.c2]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [tt.c1], [tt.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2], [tt.c1], [tt.c2]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  9 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1;
+----+------+----+------+------+----+------+------+----+------+------+----+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   |
+----+------+----+------+------+----+------+------+----+------+------+----+------+
+----+------+----+------+------+----+------+------+----+------+------+----+------+
EXPLAIN insert into t10_temp (select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |1        |151 |
|1 | SUBPLAN SCAN           |VIEW1|1        |151 |
|2 |  NESTED-LOOP OUTER JOIN|     |1        |151 |
|3 |   NESTED-LOOP JOIN     |     |1        |150 |
|4 |    NESTED-LOOP JOIN    |     |1        |143 |
|5 |     TABLE SCAN         |t2   |6        |37  |
|6 |     MATERIAL           |     |6        |92  |
|7 |      HASH JOIN         |     |6        |87  |
|8 |       TABLE SCAN       |t1   |6        |37  |
|9 |       TABLE SCAN       |tt   |6        |37  |
|10|    TABLE GET           |t3   |1        |36  |
|11|   TABLE GET            |t    |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t10_temp: ({t10_temp: (t10_temp.__pk_increment, t10_temp.a, t10_temp.b, t10_temp.c, t10_temp.d, t10_temp.e, t10_temp.f, t10_temp.g, t10_temp.h, t10_temp.i, t10_temp.j, t10_temp.k, t10_temp.l, t10_temp.m)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [tt.c1], [tt.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [tt.c1], [tt.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1], [t2.c1])
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [tt.c1], [tt.c2]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2], [tt.c1], [tt.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2], [tt.c1], [tt.c2]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  10 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  11 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)

insert into t10_temp (select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1);

rollback;
EXPLAIN insert into t10_temp (select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |1        |151 |
|1 | SUBPLAN SCAN            |VIEW1|1        |151 |
|2 |  NESTED-LOOP OUTER JOIN |     |1        |151 |
|3 |   NESTED-LOOP OUTER JOIN|     |1        |150 |
|4 |    NESTED-LOOP JOIN     |     |1        |143 |
|5 |     TABLE SCAN          |t2   |6        |37  |
|6 |     MATERIAL            |     |6        |92  |
|7 |      HASH JOIN          |     |6        |87  |
|8 |       TABLE SCAN        |t1   |6        |37  |
|9 |       TABLE SCAN        |tt   |6        |37  |
|10|    TABLE GET            |t3   |1        |36  |
|11|   TABLE GET             |t    |1        |36  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t10_temp: ({t10_temp: (t10_temp.__pk_increment, t10_temp.a, t10_temp.b, t10_temp.c, t10_temp.d, t10_temp.e, t10_temp.f, t10_temp.g, t10_temp.h, t10_temp.i, t10_temp.j, t10_temp.k, t10_temp.l, t10_temp.m)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [tt.c1], [tt.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [tt.c1], [tt.c2]), filter([t1.c1 = t3.c1]), 
      conds(nil), nl_params_([t2.c1])
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [tt.c1], [tt.c2]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2], [tt.c1], [tt.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2], [tt.c1], [tt.c2]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  10 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  11 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)

insert into t10_temp (select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |6        |189 |
|1 | SUBPLAN FILTER     |    |6        |183 |
|2 |  TABLE SCAN        |t1  |6        |37  |
|3 |  LIMIT             |    |1        |145 |
|4 |   NESTED-LOOP JOIN |    |1        |145 |
|5 |    NESTED-LOOP JOIN|    |1        |138 |
|6 |     HASH JOIN      |    |6        |87  |
|7 |      TABLE SCAN    |t1  |6        |37  |
|8 |      TABLE SCAN    |tt  |6        |37  |
|9 |     MATERIAL       |    |6        |38  |
|10|      TABLE SCAN    |t2  |6        |37  |
|11|    TABLE GET       |t3  |1        |36  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1], [t2.c1])
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  6 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |6        |190 |
|1 | SUBPLAN FILTER           |    |6        |184 |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  LIMIT                   |    |1        |146 |
|4 |   NESTED-LOOP OUTER JOIN |    |1        |146 |
|5 |    NESTED-LOOP OUTER JOIN|    |1        |145 |
|6 |     NESTED-LOOP JOIN     |    |1        |138 |
|7 |      HASH JOIN           |    |6        |87  |
|8 |       TABLE SCAN         |t1  |6        |37  |
|9 |       TABLE SCAN         |tt  |6        |37  |
|10|      MATERIAL            |    |6        |38  |
|11|       TABLE SCAN         |t2  |6        |37  |
|12|     TABLE GET            |t3  |1        |36  |
|13|    TABLE GET             |t   |1        |36  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter([t1.c1 = t3.c1]), 
      conds(nil), nl_params_([t2.c1])
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  7 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  13 - output([1]), filter(nil), 
      access([t.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |184 |
|1 | SUBPLAN FILTER     |    |1        |183 |
|2 |  TABLE SCAN        |t1  |1        |38  |
|3 |  LIMIT             |    |1        |145 |
|4 |   NESTED-LOOP JOIN |    |1        |145 |
|5 |    NESTED-LOOP JOIN|    |1        |138 |
|6 |     HASH JOIN      |    |6        |87  |
|7 |      TABLE SCAN    |t1  |6        |37  |
|8 |      TABLE SCAN    |tt  |6        |37  |
|9 |     MATERIAL       |    |6        |38  |
|10|      TABLE SCAN    |t2  |6        |37  |
|11|    TABLE GET       |t3  |1        |36  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1], [t2.c1])
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  6 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |185 |
|1 | SUBPLAN FILTER           |    |1        |184 |
|2 |  TABLE SCAN              |t1  |1        |38  |
|3 |  LIMIT                   |    |1        |146 |
|4 |   NESTED-LOOP OUTER JOIN |    |1        |146 |
|5 |    NESTED-LOOP OUTER JOIN|    |1        |145 |
|6 |     NESTED-LOOP JOIN     |    |1        |138 |
|7 |      HASH JOIN           |    |6        |87  |
|8 |       TABLE SCAN         |t1  |6        |37  |
|9 |       TABLE SCAN         |tt  |6        |37  |
|10|      MATERIAL            |    |6        |38  |
|11|       TABLE SCAN         |t2  |6        |37  |
|12|     TABLE GET            |t3  |1        |36  |
|13|    TABLE GET             |t   |1        |36  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter([t1.c1 = t3.c1]), 
      conds(nil), nl_params_([t2.c1])
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil)
  7 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([tt.c2], [tt.c1]), filter(nil), 
      access([tt.c2], [tt.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  13 - output([1]), filter(nil), 
      access([t.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |LIMIT       |    |6        |80  |
|1 | MERGE JOIN |    |6        |79  |
|2 |  TABLE SCAN|t1  |6        |37  |
|3 |  TABLE SCAN|t2  |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |LIMIT       |    |6        |80  |
|1 | MERGE JOIN |    |6        |79  |
|2 |  TABLE SCAN|t1  |6        |37  |
|3 |  TABLE SCAN|t2  |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
+----+
EXPLAIN insert into t4_temp (select * from t1, t2 where t1.c1=t2.c1 limit 100);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |82  |
|1 | SUBPLAN SCAN |VIEW1|6        |81  |
|2 |  LIMIT       |     |6        |80  |
|3 |   MERGE JOIN |     |6        |80  |
|4 |    TABLE SCAN|t1   |6        |37  |
|5 |    TABLE SCAN|t2   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), limit(100), offset(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1, t2 where t1.c1=t2.c1 limit 100);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1=t2.c1 limit 100);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |82  |
|1 | SUBPLAN SCAN |VIEW1|6        |81  |
|2 |  LIMIT       |     |6        |80  |
|3 |   MERGE JOIN |     |6        |80  |
|4 |    TABLE SCAN|t1   |6        |37  |
|5 |    TABLE SCAN|t2   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), limit(100), offset(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1, t2 where t1.c1=t2.c1 limit 100);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select sum(c1), count(*) from t1 group by c2 order by c2 limit 100;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |LIMIT          |    |6        |46  |
|1 | MERGE GROUP BY|    |6        |45  |
|2 |  SORT         |    |6        |43  |
|3 |   TABLE SCAN  |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)])
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select sum(c1), count(*) from t1 group by c2 order by c2 limit 100;
+---------+----------+
| sum(c1) | count(*) |
+---------+----------+
|       1 |        1 |
|       2 |        1 |
|       3 |        1 |
|       4 |        1 |
|       5 |        1 |
|       6 |        1 |
+---------+----------+
EXPLAIN select /*+ NO_REWRITE */sum(c1), count(*) from t1 group by c2 order by c2 limit 100;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |LIMIT          |    |6        |46  |
|1 | MERGE GROUP BY|    |6        |45  |
|2 |  SORT         |    |6        |43  |
|3 |   TABLE SCAN  |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)])
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */sum(c1), count(*) from t1 group by c2 order by c2 limit 100;
+---------+----------+
| sum(c1) | count(*) |
+---------+----------+
|       1 |        1 |
|       2 |        1 |
|       3 |        1 |
|       4 |        1 |
|       5 |        1 |
|       6 |        1 |
+---------+----------+
EXPLAIN insert into t11_temp (select sum(c1), count(*) from t1 group by c2 order by c2 limit 100);
Query Plan
===========================================
|ID|OPERATOR         |NAME |EST. ROWS|COST|
-------------------------------------------
|0 |INSERT           |     |6        |47  |
|1 | SUBPLAN SCAN    |VIEW1|6        |47  |
|2 |  LIMIT          |     |6        |46  |
|3 |   MERGE GROUP BY|     |6        |45  |
|4 |    SORT         |     |6        |43  |
|5 |     TABLE SCAN  |t1   |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,cast(VIEW1.sum(c1), INT(-1, 0)))], [column_conv(INT,PS:(11,0),NULL,cast(VIEW1.count(*), INT(-1, 0)))]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.sum(c1)], [VIEW1.count(*)]), filter(nil), 
      access([VIEW1.sum(c1)], [VIEW1.count(*)])
  2 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), limit(100), offset(nil)
  3 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)])
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t11_temp (select sum(c1), count(*) from t1 group by c2 order by c2 limit 100);

rollback;
EXPLAIN insert into t11_temp (select /*+ NO_REWRITE */sum(c1), count(*) from t1 group by c2 order by c2 limit 100);
Query Plan
===========================================
|ID|OPERATOR         |NAME |EST. ROWS|COST|
-------------------------------------------
|0 |INSERT           |     |6        |47  |
|1 | SUBPLAN SCAN    |VIEW1|6        |47  |
|2 |  LIMIT          |     |6        |46  |
|3 |   MERGE GROUP BY|     |6        |45  |
|4 |    SORT         |     |6        |43  |
|5 |     TABLE SCAN  |t1   |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,cast(VIEW1.sum(c1), INT(-1, 0)))], [column_conv(INT,PS:(11,0),NULL,cast(VIEW1.count(*), INT(-1, 0)))]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.sum(c1)], [VIEW1.count(*)]), filter(nil), 
      access([VIEW1.sum(c1)], [VIEW1.count(*)])
  2 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), limit(100), offset(nil)
  3 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)])
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t11_temp (select /*+ NO_REWRITE */sum(c1), count(*) from t1 group by c2 order by c2 limit 100);

rollback;
EXPLAIN update t1 set c2 = (select sum(c1) from t1 group by c2 order by c2 limit 1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |UPDATE           |    |6        |87  |
|1 | SUBPLAN FILTER  |    |6        |81  |
|2 |  TABLE SCAN     |t1  |6        |37  |
|3 |  LIMIT          |    |1        |43  |
|4 |   MERGE GROUP BY|    |1        |43  |
|5 |    SORT         |    |1        |43  |
|6 |     TABLE SCAN  |t1  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([cast(subquery(1), INT(-1, 0))]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([T_FUN_SUM(t1.c1)]), filter(nil), limit(1), offset(nil)
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select sum(c1) from t1 group by c2 order by c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */sum(c1) from t1 group by c2 order by c2 limit 1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |UPDATE           |    |6        |87  |
|1 | SUBPLAN FILTER  |    |6        |81  |
|2 |  TABLE SCAN     |t1  |6        |37  |
|3 |  LIMIT          |    |1        |43  |
|4 |   MERGE GROUP BY|    |1        |43  |
|5 |    SORT         |    |1        |43  |
|6 |     TABLE SCAN  |t1  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([cast(subquery(1), INT(-1, 0))]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([T_FUN_SUM(t1.c1)]), filter(nil), limit(1), offset(nil)
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */sum(c1) from t1 group by c2 order by c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select sum(c1) from t1 group by c2 order by c2 limit 1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |DELETE           |    |1        |81  |
|1 | SUBPLAN FILTER  |    |1        |81  |
|2 |  TABLE SCAN     |t1  |1        |38  |
|3 |  LIMIT          |    |1        |43  |
|4 |   MERGE GROUP BY|    |1        |43  |
|5 |    SORT         |    |1        |43  |
|6 |     TABLE SCAN  |t1  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([cast(t1.c2, DECIMAL(11, 0)) = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([T_FUN_SUM(t1.c1)]), filter(nil), limit(1), offset(nil)
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select sum(c1) from t1 group by c2 order by c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */sum(c1) from t1 group by c2 order by c2 limit 1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |DELETE           |    |1        |81  |
|1 | SUBPLAN FILTER  |    |1        |81  |
|2 |  TABLE SCAN     |t1  |1        |38  |
|3 |  LIMIT          |    |1        |43  |
|4 |   MERGE GROUP BY|    |1        |43  |
|5 |    SORT         |    |1        |43  |
|6 |     TABLE SCAN  |t1  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([cast(t1.c2, DECIMAL(11, 0)) = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([T_FUN_SUM(t1.c1)]), filter(nil), limit(1), offset(nil)
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */sum(c1) from t1 group by c2 order by c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select c1 from t1 as t order by c1;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t   |6        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p0)

select c1 from t1 as t order by c1;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
+----+
EXPLAIN select /*+ NO_REWRITE */c1 from t1 as t order by c1;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t   |6        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p0)

select /*+ NO_REWRITE */c1 from t1 as t order by c1;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
+----+
EXPLAIN insert into t12_temp (select c1 from t1 as t order by c1);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |39  |
|1 | SUBPLAN SCAN|VIEW1|6        |38  |
|2 |  TABLE SCAN |t    |6        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p0)

insert into t12_temp (select c1 from t1 as t order by c1);

rollback;
EXPLAIN insert into t12_temp (select /*+ NO_REWRITE */c1 from t1 as t order by c1);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |39  |
|1 | SUBPLAN SCAN|VIEW1|6        |38  |
|2 |  TABLE SCAN |t    |6        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p0)

insert into t12_temp (select /*+ NO_REWRITE */c1 from t1 as t order by c1);

rollback;
EXPLAIN update t1 set c2 = (select c1 from t1 as t order by c1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |80  |
|1 | SUBPLAN FILTER|    |6        |74  |
|2 |  TABLE SCAN   |t1  |6        |37  |
|3 |  TABLE SCAN   |t   |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p0), 
      limit(1), offset(nil)

update t1 set c2 = (select c1 from t1 as t order by c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */c1 from t1 as t order by c1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |80  |
|1 | SUBPLAN FILTER|    |6        |74  |
|2 |  TABLE SCAN   |t1  |6        |37  |
|3 |  TABLE SCAN   |t   |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p0), 
      limit(1), offset(nil)

update t1 set c2 = (select /*+ NO_REWRITE */c1 from t1 as t order by c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select c1 from t1 as t order by c1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |75  |
|1 | SUBPLAN FILTER|    |1        |74  |
|2 |  TABLE SCAN   |t1  |1        |38  |
|3 |  TABLE SCAN   |t   |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t1 where c2 = (select c1 from t1 as t order by c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */c1 from t1 as t order by c1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |75  |
|1 | SUBPLAN FILTER|    |1        |74  |
|2 |  TABLE SCAN   |t1  |1        |38  |
|3 |  TABLE SCAN   |t   |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t1 where c2 = (select /*+ NO_REWRITE */c1 from t1 as t order by c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |1        |80  |
|1 | TABLE SCAN|t2  |6        |37  |
|2 | TABLE SCAN|t3  |6        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c3 > t3.c3], [t2.c2 < t3.c2])
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select * from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3;
+----+------+------+----+------+------+
| c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+------+----+------+------+
|  1 |    1 | o    |  1 |    2 | 3    |
|  3 |    5 | b    |  3 |    6 | 1    |
+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |2        |78  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | TABLE SCAN     |t3  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t2.c3 > t3.c3]), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c2 < t3.c2])
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3;
+----+------+------+----+------+------+
| c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+------+----+------+------+
|  1 |    1 | o    |  1 |    2 | 3    |
|  3 |    5 | b    |  3 |    6 | 1    |
+----+------+------+----+------+------+
EXPLAIN insert into t13_temp (select * from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |1        |80  |
|1 | SUBPLAN SCAN|VIEW1|1        |80  |
|2 |  MERGE JOIN |     |1        |80  |
|3 |   TABLE SCAN|t2   |6        |37  |
|4 |   TABLE SCAN|t3   |6        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t13_temp: ({t13_temp: (t13_temp.__pk_increment, t13_temp.a, t13_temp.b, t13_temp.c, t13_temp.d, t13_temp.e, t13_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c3 > t3.c3], [t2.c2 < t3.c2])
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t13_temp (select * from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3);

rollback;
EXPLAIN insert into t13_temp (select /*+ NO_REWRITE */* from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |2        |79  |
|1 | SUBPLAN SCAN     |VIEW1|2        |78  |
|2 |  MERGE OUTER JOIN|     |2        |78  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   TABLE SCAN     |t3   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t13_temp: ({t13_temp: (t13_temp.__pk_increment, t13_temp.a, t13_temp.b, t13_temp.c, t13_temp.d, t13_temp.e, t13_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t2.c3 > t3.c3]), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c2 < t3.c2])
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t13_temp (select /*+ NO_REWRITE */* from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3);

rollback;
EXPLAIN update t1 set c2 = (select t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |124 |
|1 | SUBPLAN FILTER|    |6        |118 |
|2 |  TABLE SCAN   |t1  |6        |37  |
|3 |  LIMIT        |    |1        |80  |
|4 |   MERGE JOIN  |    |1        |80  |
|5 |    TABLE SCAN |t2  |6        |37  |
|6 |    TABLE SCAN |t3  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c3 > t3.c3], [t2.c2 < t3.c2])
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

update t1 set c2 = (select t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |120 |
|1 | SUBPLAN FILTER    |    |6        |114 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |76  |
|4 |   MERGE OUTER JOIN|    |1        |76  |
|5 |    TABLE SCAN     |t2  |5        |37  |
|6 |    TABLE SCAN     |t3  |5        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t2.c1]), filter([t2.c3 > t3.c3]), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c2 < t3.c2])
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |119 |
|1 | SUBPLAN FILTER|    |1        |118 |
|2 |  TABLE SCAN   |t1  |1        |38  |
|3 |  LIMIT        |    |1        |80  |
|4 |   MERGE JOIN  |    |1        |80  |
|5 |    TABLE SCAN |t2  |6        |37  |
|6 |    TABLE SCAN |t3  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c3 > t3.c3], [t2.c2 < t3.c2])
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

delete from t1 where c2 = (select t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |115 |
|1 | SUBPLAN FILTER    |    |1        |114 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |76  |
|4 |   MERGE OUTER JOIN|    |1        |76  |
|5 |    TABLE SCAN     |t2  |5        |37  |
|6 |    TABLE SCAN     |t3  |5        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t2.c1]), filter([t2.c3 > t3.c3]), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c2 < t3.c2])
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |1        |136 |
|1 | TABLE SCAN |t2  |6        |37  |
|2 | MERGE JOIN |    |6        |79  |
|3 |  TABLE SCAN|t1  |6        |37  |
|4 |  TABLE SCAN|t3  |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t2.c2], [t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c3]), partitions(p0)

select t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3;
+----+
| c1 |
+----+
+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |1        |136 |
|1 | TABLE SCAN |t2  |6        |37  |
|2 | MERGE JOIN |    |6        |79  |
|3 |  TABLE SCAN|t1  |6        |37  |
|4 |  TABLE SCAN|t3  |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t2.c2], [t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c3]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3;
+----+
| c1 |
+----+
+----+
EXPLAIN insert into t12_temp (select t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |1        |136 |
|1 | SUBPLAN SCAN |VIEW1|1        |136 |
|2 |  HASH JOIN   |     |1        |136 |
|3 |   TABLE SCAN |t2   |6        |37  |
|4 |   MERGE JOIN |     |6        |79  |
|5 |    TABLE SCAN|t1   |6        |37  |
|6 |    TABLE SCAN|t3   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t2.c2], [t2.c3 = t3.c3]), other_conds(nil)
  3 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c3]), partitions(p0)

insert into t12_temp (select t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3);

rollback;
EXPLAIN insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |1        |136 |
|1 | SUBPLAN SCAN |VIEW1|1        |136 |
|2 |  HASH JOIN   |     |1        |136 |
|3 |   TABLE SCAN |t2   |6        |37  |
|4 |   MERGE JOIN |     |6        |79  |
|5 |    TABLE SCAN|t1   |6        |37  |
|6 |    TABLE SCAN|t3   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t2.c2], [t2.c3 = t3.c3]), other_conds(nil)
  3 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c3]), partitions(p0)

insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |180 |
|1 | SUBPLAN FILTER|    |6        |174 |
|2 |  TABLE SCAN   |t1  |6        |37  |
|3 |  LIMIT        |    |1        |136 |
|4 |   HASH JOIN   |    |1        |136 |
|5 |    TABLE SCAN |t2  |6        |37  |
|6 |    MERGE JOIN |    |6        |79  |
|7 |     TABLE SCAN|t1  |6        |37  |
|8 |     TABLE SCAN|t3  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t2.c2], [t2.c3 = t3.c3]), other_conds(nil)
  5 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t3.c1], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c3]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |180 |
|1 | SUBPLAN FILTER|    |6        |174 |
|2 |  TABLE SCAN   |t1  |6        |37  |
|3 |  LIMIT        |    |1        |136 |
|4 |   HASH JOIN   |    |1        |136 |
|5 |    TABLE SCAN |t2  |6        |37  |
|6 |    MERGE JOIN |    |6        |79  |
|7 |     TABLE SCAN|t1  |6        |37  |
|8 |     TABLE SCAN|t3  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t2.c2], [t2.c3 = t3.c3]), other_conds(nil)
  5 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t3.c1], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c3]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |174 |
|1 | SUBPLAN FILTER|    |1        |173 |
|2 |  TABLE SCAN   |t1  |1        |38  |
|3 |  LIMIT        |    |1        |136 |
|4 |   HASH JOIN   |    |1        |136 |
|5 |    TABLE SCAN |t2  |6        |37  |
|6 |    MERGE JOIN |    |6        |79  |
|7 |     TABLE SCAN|t1  |6        |37  |
|8 |     TABLE SCAN|t3  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t2.c2], [t2.c3 = t3.c3]), other_conds(nil)
  5 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t3.c1], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c3]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |174 |
|1 | SUBPLAN FILTER|    |1        |173 |
|2 |  TABLE SCAN   |t1  |1        |38  |
|3 |  LIMIT        |    |1        |136 |
|4 |   HASH JOIN   |    |1        |136 |
|5 |    TABLE SCAN |t2  |6        |37  |
|6 |    MERGE JOIN |    |6        |79  |
|7 |     TABLE SCAN|t1  |6        |37  |
|8 |     TABLE SCAN|t3  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t2.c2], [t2.c3 = t3.c3]), other_conds(nil)
  5 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t3.c1], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c3]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1;
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |MERGE JOIN        |    |6        |164 |
|1 | MERGE JOIN       |    |6        |122 |
|2 |  MERGE OUTER JOIN|    |6        |80  |
|3 |   TABLE SCAN     |t1  |6        |37  |
|4 |   TABLE SCAN     |t   |6        |37  |
|5 |  TABLE SCAN      |t3  |6        |37  |
|6 | TABLE SCAN       |t2  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1;
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |MERGE OUTER JOIN   |    |6        |181 |
|1 | MERGE JOIN        |    |6        |139 |
|2 |  SORT             |    |6        |97  |
|3 |   MERGE OUTER JOIN|    |6        |80  |
|4 |    TABLE SCAN     |t2  |6        |37  |
|5 |    TABLE SCAN     |t3  |6        |37  |
|6 |  TABLE SCAN       |t1  |6        |37  |
|7 | TABLE SCAN        |t   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC])
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |  1 |    1 | o    |  1 |    2 | 3    |
|  2 |    5 |  2 |    5 | c    |  2 |    5 | c    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  3 |    5 | b    |  3 |    6 | 1    |
|  4 |    6 |  4 |    6 | o    |  4 |    6 | o    |  4 |    5 | 1    |
|  5 |    4 |  5 |    7 | d    |  5 |    7 | d    |  5 |    5 | 5    |
|  6 |    7 |  6 |    8 | c    |  6 |    8 | c    |  6 |    5 | c    |
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1);
Query Plan
==============================================
|ID|OPERATOR            |NAME |EST. ROWS|COST|
----------------------------------------------
|0 |INSERT              |     |6        |166 |
|1 | SUBPLAN SCAN       |VIEW1|6        |165 |
|2 |  MERGE JOIN        |     |6        |164 |
|3 |   MERGE JOIN       |     |6        |122 |
|4 |    MERGE OUTER JOIN|     |6        |80  |
|5 |     TABLE SCAN     |t1   |6        |37  |
|6 |     TABLE SCAN     |t    |6        |37  |
|7 |    TABLE SCAN      |t3   |6        |37  |
|8 |   TABLE SCAN       |t2   |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select * from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |INSERT               |     |6        |183 |
|1 | SUBPLAN SCAN        |VIEW1|6        |182 |
|2 |  MERGE OUTER JOIN   |     |6        |181 |
|3 |   MERGE JOIN        |     |6        |139 |
|4 |    SORT             |     |6        |97  |
|5 |     MERGE OUTER JOIN|     |6        |80  |
|6 |      TABLE SCAN     |t2   |6        |37  |
|7 |      TABLE SCAN     |t3   |6        |37  |
|8 |    TABLE SCAN       |t1   |6        |37  |
|9 |   TABLE SCAN        |t    |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC])
  5 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |155 |
|1 | SUBPLAN FILTER    |    |6        |149 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t3  |3        |37  |
|8 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t3.c1])
  5 - output([t1.c1], [t3.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |203 |
|1 | SUBPLAN FILTER          |    |6        |197 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |159 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |159 |
|5 |    MERGE JOIN           |    |1        |122 |
|6 |     SORT                |    |3        |85  |
|7 |      MERGE OUTER JOIN   |    |6        |79  |
|8 |       TABLE SCAN        |t2  |6        |37  |
|9 |       TABLE SCAN        |t3  |6        |37  |
|10|     TABLE SCAN          |t1  |3        |37  |
|11|    TABLE GET            |t   |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  7 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  11 - output([1]), filter(nil), 
      access([t.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |149 |
|1 | SUBPLAN FILTER    |    |1        |148 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |111 |
|4 |   NESTED-LOOP JOIN|    |1        |111 |
|5 |    MERGE JOIN     |    |1        |74  |
|6 |     TABLE SCAN    |t1  |3        |37  |
|7 |     TABLE SCAN    |t3  |3        |37  |
|8 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t3.c1])
  5 - output([t1.c1], [t3.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |197 |
|1 | SUBPLAN FILTER          |    |1        |196 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |159 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |159 |
|5 |    MERGE JOIN           |    |1        |122 |
|6 |     SORT                |    |3        |85  |
|7 |      MERGE OUTER JOIN   |    |6        |79  |
|8 |       TABLE SCAN        |t2  |6        |37  |
|9 |       TABLE SCAN        |t3  |6        |37  |
|10|     TABLE SCAN          |t1  |3        |37  |
|11|    TABLE GET            |t   |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  7 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  11 - output([1]), filter(nil), 
      access([t.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where false;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), startup_filter([0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where false;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1=t2.c1 where false;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), startup_filter([0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1=t2.c1 where false;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where false);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |81  |
|1 | SUBPLAN SCAN     |VIEW1|6        |80  |
|2 |  MERGE OUTER JOIN|     |6        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where false);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1=t2.c1 where false);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |81  |
|1 | SUBPLAN SCAN     |VIEW1|6        |80  |
|2 |  MERGE OUTER JOIN|     |6        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1=t2.c1 where false);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where false limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |80  |
|1 | SUBPLAN FILTER|    |6        |74  |
|2 |  TABLE SCAN   |t1  |6        |37  |
|3 |  TABLE SCAN   |t1  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where false limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where false limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |117 |
|1 | SUBPLAN FILTER          |    |6        |111 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |73  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    TABLE GET            |t2  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where false limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where false limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |75  |
|1 | SUBPLAN FILTER|    |1        |74  |
|2 |  TABLE SCAN   |t1  |1        |38  |
|3 |  TABLE SCAN   |t1  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where false limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where false limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |112 |
|1 | SUBPLAN FILTER          |    |1        |111 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |73  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    TABLE GET            |t2  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where false limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |36       |102 |
|1 | TABLE SCAN               |t2  |6        |37  |
|2 | MATERIAL                 |    |6        |40  |
|3 |  TABLE SCAN              |t1  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |1        |98  |
|1 | TABLE SCAN           |t1  |6        |37  |
|2 | MATERIAL             |    |6        |44  |
|3 |  TABLE SCAN          |t2  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > 1], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 > 1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |36       |112 |
|1 | SUBPLAN SCAN               |VIEW1|36       |107 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |36       |102 |
|3 |   TABLE SCAN               |t2   |6        |37  |
|4 |   MATERIAL                 |     |6        |40  |
|5 |    TABLE SCAN              |t1   |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |1        |98  |
|1 | SUBPLAN SCAN           |VIEW1|1        |98  |
|2 |  NESTED-LOOP OUTER JOIN|     |1        |98  |
|3 |   TABLE SCAN           |t1   |6        |37  |
|4 |   MATERIAL             |     |6        |44  |
|5 |    TABLE SCAN          |t2   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > 1], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 > 1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |119 |
|1 | SUBPLAN FILTER              |    |6        |113 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t1  |1        |36  |
|6 |    MATERIAL                 |    |6        |38  |
|7 |     TABLE SCAN              |t2  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |135 |
|1 | SUBPLAN FILTER          |    |6        |129 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |92  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |92  |
|5 |    TABLE SCAN           |t1  |6        |37  |
|6 |    MATERIAL             |    |6        |40  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 > 1], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 > 1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t1  |1        |36  |
|6 |    MATERIAL                 |    |6        |38  |
|7 |     TABLE SCAN              |t2  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |130 |
|1 | SUBPLAN FILTER          |    |1        |129 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |92  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |92  |
|5 |    TABLE SCAN           |t1  |6        |37  |
|6 |    MATERIAL             |    |6        |40  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 > 1], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 > 1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 right join t2 on t1.c1 = t2.c2;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |6        |88  |
|1 | TABLE SCAN          |t1  |6        |37  |
|2 | TABLE SCAN          |t2  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)

select * from t1 right join t2 on t1.c1 = t2.c2;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
| NULL | NULL |  5 |    7 | d    |
| NULL | NULL |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c2;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |6        |88  |
|1 | TABLE SCAN          |t1  |6        |37  |
|2 | TABLE SCAN          |t2  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c2;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
| NULL | NULL |  5 |    7 | d    |
| NULL | NULL |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 right join t2 on t1.c1 = t2.c2);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |6        |89  |
|1 | SUBPLAN SCAN          |VIEW1|6        |88  |
|2 |  HASH RIGHT OUTER JOIN|     |6        |88  |
|3 |   TABLE SCAN          |t1   |6        |37  |
|4 |   TABLE SCAN          |t2   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 right join t2 on t1.c1 = t2.c2);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c2);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |6        |89  |
|1 | SUBPLAN SCAN          |VIEW1|6        |88  |
|2 |  HASH RIGHT OUTER JOIN|     |6        |88  |
|3 |   TABLE SCAN          |t1   |6        |37  |
|4 |   TABLE SCAN          |t2   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c2);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c2 limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                   |     |6        |117 |
|1 | SUBPLAN FILTER          |     |6        |111 |
|2 |  TABLE SCAN             |t1   |6        |37  |
|3 |  LIMIT                  |     |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|     |1        |73  |
|5 |    SUBPLAN SCAN         |VIEW1|1        |37  |
|6 |     TABLE SCAN          |t2   |1        |36  |
|7 |    TABLE GET            |t1   |1        |36  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([VIEW1.t2.c2])
  5 - output([VIEW1.t2.c2]), filter(nil), 
      access([VIEW1.t2.c2])
  6 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0), 
      limit(1), offset(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c2 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |117 |
|1 | SUBPLAN FILTER          |    |6        |111 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |73  |
|5 |    TABLE SCAN           |t2  |1        |36  |
|6 |    TABLE GET            |t1  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c2])
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c2 limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                   |     |1        |112 |
|1 | SUBPLAN FILTER          |     |1        |111 |
|2 |  TABLE SCAN             |t1   |1        |38  |
|3 |  LIMIT                  |     |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|     |1        |73  |
|5 |    SUBPLAN SCAN         |VIEW1|1        |37  |
|6 |     TABLE SCAN          |t2   |1        |36  |
|7 |    TABLE GET            |t1   |1        |36  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([VIEW1.t2.c2])
  5 - output([VIEW1.t2.c2]), filter(nil), 
      access([VIEW1.t2.c2])
  6 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0), 
      limit(1), offset(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c2 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |112 |
|1 | SUBPLAN FILTER          |    |1        |111 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |73  |
|5 |    TABLE SCAN           |t2  |1        |36  |
|6 |    TABLE GET            |t1  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c2])
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 inner join t2 on t1.c1 = t2.c2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |6        |88  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)

select * from t1 inner join t2 on t1.c1 = t2.c2;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1 = t2.c2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |6        |88  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |6        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1 = t2.c2;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  5 |    4 |  2 |    5 | c    |
|  5 |    4 |  3 |    5 | b    |
|  6 |    7 |  4 |    6 | o    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 inner join t2 on t1.c1 = t2.c2);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |89  |
|1 | SUBPLAN SCAN|VIEW1|6        |88  |
|2 |  HASH JOIN  |     |6        |88  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 inner join t2 on t1.c1 = t2.c2);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1 = t2.c2);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |6        |89  |
|1 | SUBPLAN SCAN|VIEW1|6        |88  |
|2 |  HASH JOIN  |     |6        |88  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |6        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 inner join t2 on t1.c1 = t2.c2);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1 = t2.c2 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |36  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c2])
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 inner join t2 on t1.c1 = t2.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c2 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |36  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c2])
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1 = t2.c2 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |36  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c2])
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 inner join t2 on t1.c1 = t2.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c2 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |36  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c2])
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 inner join t2 on t1.c1 = t2.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

## case
EXPLAIN select c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 100;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |LIMIT       |    |1        |39  |
|1 | TOP-N SORT |    |1        |39  |
|2 |  TABLE SCAN|t1  |1        |38  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC]), topn(100)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 < 0]), 
      access([t1.c1], [t1.c2]), partitions(p0)

select c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 100;
+----+
| c1 |
+----+
+----+
EXPLAIN select /*+ NO_REWRITE */c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 100;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |LIMIT       |    |1        |39  |
|1 | TOP-N SORT |    |1        |39  |
|2 |  TABLE SCAN|t1  |1        |38  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC]), topn(100)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 < 0]), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 100;
+----+
| c1 |
+----+
+----+
EXPLAIN insert into t12_temp (select c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 100);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |1        |39  |
|1 | SUBPLAN SCAN |VIEW1|1        |39  |
|2 |  LIMIT       |     |1        |39  |
|3 |   TOP-N SORT |     |1        |39  |
|4 |    TABLE SCAN|t1   |1        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC]), topn(100)
  4 - output([t1.c1], [t1.c2]), filter([t1.c2 < 0]), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t12_temp (select c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 100);

rollback;
EXPLAIN insert into t12_temp (select /*+ NO_REWRITE */c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 100);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |1        |39  |
|1 | SUBPLAN SCAN |VIEW1|1        |39  |
|2 |  LIMIT       |     |1        |39  |
|3 |   TOP-N SORT |     |1        |39  |
|4 |    TABLE SCAN|t1   |1        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC]), topn(100)
  4 - output([t1.c1], [t1.c2]), filter([t1.c2 < 0]), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t12_temp (select /*+ NO_REWRITE */c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 100);

rollback;
EXPLAIN update t1 set c2 = (select c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |83  |
|1 | SUBPLAN FILTER|    |6        |77  |
|2 |  TABLE SCAN   |t1  |6        |37  |
|3 |  LIMIT        |    |1        |39  |
|4 |   TOP-N SORT  |    |1        |39  |
|5 |    TABLE SCAN |t1  |1        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC]), topn(1)
  5 - output([t1.c1], [t1.c2]), filter([t1.c2 < 0]), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |83  |
|1 | SUBPLAN FILTER|    |6        |77  |
|2 |  TABLE SCAN   |t1  |6        |37  |
|3 |  LIMIT        |    |1        |39  |
|4 |   TOP-N SORT  |    |1        |39  |
|5 |    TABLE SCAN |t1  |1        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC]), topn(1)
  5 - output([t1.c1], [t1.c2]), filter([t1.c2 < 0]), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |77  |
|1 | SUBPLAN FILTER|    |1        |76  |
|2 |  TABLE SCAN   |t1  |1        |38  |
|3 |  LIMIT        |    |1        |39  |
|4 |   TOP-N SORT  |    |1        |39  |
|5 |    TABLE SCAN |t1  |1        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC]), topn(1)
  5 - output([t1.c1], [t1.c2]), filter([t1.c2 < 0]), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |77  |
|1 | SUBPLAN FILTER|    |1        |76  |
|2 |  TABLE SCAN   |t1  |1        |38  |
|3 |  LIMIT        |    |1        |39  |
|4 |   TOP-N SORT  |    |1        |39  |
|5 |    TABLE SCAN |t1  |1        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC]), topn(1)
  5 - output([t1.c1], [t1.c2]), filter([t1.c2 < 0]), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

## case  join
EXPLAIN select t1.c1 from t1, t2 limit 100;
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |LIMIT                      |    |36       |105 |
|1 | NESTED-LOOP JOIN CARTESIAN|    |36       |100 |
|2 |  TABLE SCAN               |t1  |6        |37  |
|3 |  MATERIAL                 |    |6        |38  |
|4 |   TABLE SCAN              |t2  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([1]), filter(nil)
  4 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select t1.c1 from t1, t2 limit 100;
+----+
| c1 |
+----+
|  1 |
|  1 |
|  1 |
|  1 |
|  1 |
|  1 |
|  2 |
|  2 |
|  2 |
|  2 |
|  2 |
|  2 |
|  3 |
|  3 |
|  3 |
|  3 |
|  3 |
|  3 |
|  4 |
|  4 |
|  4 |
|  4 |
|  4 |
|  4 |
|  5 |
|  5 |
|  5 |
|  5 |
|  5 |
|  5 |
|  6 |
|  6 |
|  6 |
|  6 |
|  6 |
|  6 |
+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 from t1, t2 limit 100;
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |LIMIT                      |    |36       |105 |
|1 | NESTED-LOOP JOIN CARTESIAN|    |36       |100 |
|2 |  TABLE SCAN               |t1  |6        |37  |
|3 |  MATERIAL                 |    |6        |38  |
|4 |   TABLE SCAN              |t2  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([1]), filter(nil)
  4 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 from t1, t2 limit 100;
+----+
| c1 |
+----+
|  1 |
|  1 |
|  1 |
|  1 |
|  1 |
|  1 |
|  2 |
|  2 |
|  2 |
|  2 |
|  2 |
|  2 |
|  3 |
|  3 |
|  3 |
|  3 |
|  3 |
|  3 |
|  4 |
|  4 |
|  4 |
|  4 |
|  4 |
|  4 |
|  5 |
|  5 |
|  5 |
|  5 |
|  5 |
|  5 |
|  6 |
|  6 |
|  6 |
|  6 |
|  6 |
|  6 |
+----+
EXPLAIN insert into t12_temp (select t1.c1 from t1, t2 limit 100);
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |36       |115 |
|1 | SUBPLAN SCAN                |VIEW1|36       |110 |
|2 |  LIMIT                      |     |36       |105 |
|3 |   NESTED-LOOP JOIN CARTESIAN|     |36       |100 |
|4 |    TABLE SCAN               |t1   |6        |37  |
|5 |    MATERIAL                 |     |6        |38  |
|6 |     TABLE SCAN              |t2   |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  3 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([1]), filter(nil)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

insert into t12_temp (select t1.c1 from t1, t2 limit 100);

rollback;
EXPLAIN insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1, t2 limit 100);
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |36       |115 |
|1 | SUBPLAN SCAN                |VIEW1|36       |110 |
|2 |  LIMIT                      |     |36       |105 |
|3 |   NESTED-LOOP JOIN CARTESIAN|     |36       |100 |
|4 |    TABLE SCAN               |t1   |6        |37  |
|5 |    MATERIAL                 |     |6        |38  |
|6 |     TABLE SCAN              |t2   |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  3 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([1]), filter(nil)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1, t2 limit 100);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |119 |
|1 | SUBPLAN FILTER              |    |6        |113 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t1  |1        |36  |
|6 |    MATERIAL                 |    |6        |38  |
|7 |     TABLE SCAN              |t2  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |119 |
|1 | SUBPLAN FILTER              |    |6        |113 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t1  |1        |36  |
|6 |    MATERIAL                 |    |6        |38  |
|7 |     TABLE SCAN              |t2  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t1  |1        |36  |
|6 |    MATERIAL                 |    |6        |38  |
|7 |     TABLE SCAN              |t2  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |113 |
|1 | SUBPLAN FILTER              |    |1        |112 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |75  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |75  |
|5 |    TABLE SCAN               |t1  |1        |36  |
|6 |    MATERIAL                 |    |6        |38  |
|7 |     TABLE SCAN              |t2  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

## case  join with predicate
EXPLAIN select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |LIMIT       |    |6        |80  |
|1 | MERGE JOIN |    |6        |79  |
|2 |  TABLE SCAN|t1  |6        |37  |
|3 |  TABLE SCAN|t2  |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |LIMIT       |    |6        |80  |
|1 | MERGE JOIN |    |6        |79  |
|2 |  TABLE SCAN|t1  |6        |37  |
|3 |  TABLE SCAN|t2  |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
+----+
EXPLAIN insert into t12_temp (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |82  |
|1 | SUBPLAN SCAN |VIEW1|6        |81  |
|2 |  LIMIT       |     |6        |80  |
|3 |   MERGE JOIN |     |6        |79  |
|4 |    TABLE SCAN|t1   |6        |37  |
|5 |    TABLE SCAN|t2   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

insert into t12_temp (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100);

rollback;
EXPLAIN insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |82  |
|1 | SUBPLAN SCAN |VIEW1|6        |81  |
|2 |  LIMIT       |     |6        |80  |
|3 |   MERGE JOIN |     |6        |79  |
|4 |    TABLE SCAN|t1   |6        |37  |
|5 |    TABLE SCAN|t2   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 ;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 ;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 ;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 ;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |81  |
|1 | SUBPLAN SCAN     |VIEW1|6        |80  |
|2 |  MERGE OUTER JOIN|     |6        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 );
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |81  |
|1 | SUBPLAN SCAN     |VIEW1|6        |80  |
|2 |  MERGE OUTER JOIN|     |6        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 = t2.c1 );

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |80  |
|1 | SUBPLAN FILTER|    |6        |74  |
|2 |  TABLE SCAN   |t1  |6        |37  |
|3 |  TABLE SCAN   |t1  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1  limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |117 |
|1 | SUBPLAN FILTER          |    |6        |111 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |73  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    TABLE GET            |t2  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1  limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |75  |
|1 | SUBPLAN FILTER|    |1        |74  |
|2 |  TABLE SCAN   |t1  |1        |38  |
|3 |  TABLE SCAN   |t1  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1  limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |112 |
|1 | SUBPLAN FILTER          |    |1        |111 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |73  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    TABLE GET            |t2  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1  limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |LIMIT       |    |6        |80  |
|1 | MERGE JOIN |    |6        |79  |
|2 |  TABLE SCAN|t1  |6        |37  |
|3 |  TABLE SCAN|t2  |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |LIMIT       |    |6        |80  |
|1 | MERGE JOIN |    |6        |79  |
|2 |  TABLE SCAN|t1  |6        |37  |
|3 |  TABLE SCAN|t2  |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
+----+
EXPLAIN insert into t12_temp (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |82  |
|1 | SUBPLAN SCAN |VIEW1|6        |81  |
|2 |  LIMIT       |     |6        |80  |
|3 |   MERGE JOIN |     |6        |79  |
|4 |    TABLE SCAN|t1   |6        |37  |
|5 |    TABLE SCAN|t2   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

insert into t12_temp (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100);

rollback;
EXPLAIN insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |82  |
|1 | SUBPLAN SCAN |VIEW1|6        |81  |
|2 |  LIMIT       |     |6        |80  |
|3 |   MERGE JOIN |     |6        |79  |
|4 |    TABLE SCAN|t1   |6        |37  |
|5 |    TABLE SCAN|t2   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    TABLE GET      |t2  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2 where t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |2        |125 |
|1 | MERGE JOIN |    |2        |78  |
|2 |  TABLE SCAN|t1  |6        |37  |
|3 |  TABLE SCAN|t2  |6        |37  |
|4 | TABLE SCAN |t3  |5        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t1.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 > t2.c2])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)

select t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1;
+----+
| c1 |
+----+
+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |2        |125 |
|1 | MERGE JOIN |    |2        |78  |
|2 |  TABLE SCAN|t1  |6        |37  |
|3 |  TABLE SCAN|t2  |6        |37  |
|4 | TABLE SCAN |t3  |5        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t1.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 > t2.c2])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1;
+----+
| c1 |
+----+
+----+
EXPLAIN insert into t12_temp (select t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |2        |126 |
|1 | SUBPLAN SCAN |VIEW1|2        |126 |
|2 |  HASH JOIN   |     |2        |125 |
|3 |   MERGE JOIN |     |2        |78  |
|4 |    TABLE SCAN|t1   |6        |37  |
|5 |    TABLE SCAN|t2   |6        |37  |
|6 |   TABLE SCAN |t3   |5        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  3 - output([t1.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 > t2.c2])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)

insert into t12_temp (select t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1);

rollback;
EXPLAIN insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |2        |126 |
|1 | SUBPLAN SCAN |VIEW1|2        |126 |
|2 |  HASH JOIN   |     |2        |125 |
|3 |   MERGE JOIN |     |2        |78  |
|4 |    TABLE SCAN|t1   |6        |37  |
|5 |    TABLE SCAN|t2   |6        |37  |
|6 |   TABLE SCAN |t3   |5        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  3 - output([t1.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 > t2.c2])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)

insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |167 |
|1 | SUBPLAN FILTER|    |6        |161 |
|2 |  TABLE SCAN   |t1  |6        |37  |
|3 |  LIMIT        |    |1        |123 |
|4 |   HASH JOIN   |    |1        |123 |
|5 |    MERGE JOIN |    |2        |78  |
|6 |     TABLE SCAN|t1  |6        |37  |
|7 |     TABLE SCAN|t2  |6        |37  |
|8 |    TABLE SCAN |t3  |4        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  5 - output([t1.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 > t2.c2])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |167 |
|1 | SUBPLAN FILTER|    |6        |161 |
|2 |  TABLE SCAN   |t1  |6        |37  |
|3 |  LIMIT        |    |1        |123 |
|4 |   HASH JOIN   |    |1        |123 |
|5 |    MERGE JOIN |    |2        |78  |
|6 |     TABLE SCAN|t1  |6        |37  |
|7 |     TABLE SCAN|t2  |6        |37  |
|8 |    TABLE SCAN |t3  |4        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  5 - output([t1.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 > t2.c2])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |162 |
|1 | SUBPLAN FILTER|    |1        |161 |
|2 |  TABLE SCAN   |t1  |1        |38  |
|3 |  LIMIT        |    |1        |123 |
|4 |   HASH JOIN   |    |1        |123 |
|5 |    MERGE JOIN |    |2        |78  |
|6 |     TABLE SCAN|t1  |6        |37  |
|7 |     TABLE SCAN|t2  |6        |37  |
|8 |    TABLE SCAN |t3  |4        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  5 - output([t1.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 > t2.c2])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |162 |
|1 | SUBPLAN FILTER|    |1        |161 |
|2 |  TABLE SCAN   |t1  |1        |38  |
|3 |  LIMIT        |    |1        |123 |
|4 |   HASH JOIN   |    |1        |123 |
|5 |    MERGE JOIN |    |2        |78  |
|6 |     TABLE SCAN|t1  |6        |37  |
|7 |     TABLE SCAN|t2  |6        |37  |
|8 |    TABLE SCAN |t3  |4        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  5 - output([t1.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 > t2.c2])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |1        |80  |
|1 | TABLE SCAN|t2  |6        |37  |
|2 | TABLE SCAN|t3  |6        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c3 > t3.c3], [t2.c2 < t3.c2])
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select * from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3;
+----+------+------+----+------+------+
| c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+------+----+------+------+
|  1 |    1 | o    |  1 |    2 | 3    |
|  3 |    5 | b    |  3 |    6 | 1    |
+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |2        |78  |
|1 | TABLE SCAN     |t2  |6        |37  |
|2 | TABLE SCAN     |t3  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t2.c3 > t3.c3]), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c2 < t3.c2])
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3;
+----+------+------+----+------+------+
| c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+------+----+------+------+
|  1 |    1 | o    |  1 |    2 | 3    |
|  3 |    5 | b    |  3 |    6 | 1    |
+----+------+------+----+------+------+
EXPLAIN insert into t13_temp (select * from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |1        |80  |
|1 | SUBPLAN SCAN|VIEW1|1        |80  |
|2 |  MERGE JOIN |     |1        |80  |
|3 |   TABLE SCAN|t2   |6        |37  |
|4 |   TABLE SCAN|t3   |6        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t13_temp: ({t13_temp: (t13_temp.__pk_increment, t13_temp.a, t13_temp.b, t13_temp.c, t13_temp.d, t13_temp.e, t13_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c3 > t3.c3], [t2.c2 < t3.c2])
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t13_temp (select * from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3);

rollback;
EXPLAIN insert into t13_temp (select /*+ NO_REWRITE */* from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |2        |79  |
|1 | SUBPLAN SCAN     |VIEW1|2        |78  |
|2 |  MERGE OUTER JOIN|     |2        |78  |
|3 |   TABLE SCAN     |t2   |6        |37  |
|4 |   TABLE SCAN     |t3   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t13_temp: ({t13_temp: (t13_temp.__pk_increment, t13_temp.a, t13_temp.b, t13_temp.c, t13_temp.d, t13_temp.e, t13_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t2.c3 > t3.c3]), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c2 < t3.c2])
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t13_temp (select /*+ NO_REWRITE */* from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3);

rollback;
EXPLAIN update t1 set c2 = (select t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |124 |
|1 | SUBPLAN FILTER|    |6        |118 |
|2 |  TABLE SCAN   |t1  |6        |37  |
|3 |  LIMIT        |    |1        |80  |
|4 |   MERGE JOIN  |    |1        |80  |
|5 |    TABLE SCAN |t2  |6        |37  |
|6 |    TABLE SCAN |t3  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c3 > t3.c3], [t2.c2 < t3.c2])
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

update t1 set c2 = (select t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |120 |
|1 | SUBPLAN FILTER    |    |6        |114 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |76  |
|4 |   MERGE OUTER JOIN|    |1        |76  |
|5 |    TABLE SCAN     |t2  |5        |37  |
|6 |    TABLE SCAN     |t3  |5        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t2.c1]), filter([t2.c3 > t3.c3]), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c2 < t3.c2])
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |119 |
|1 | SUBPLAN FILTER|    |1        |118 |
|2 |  TABLE SCAN   |t1  |1        |38  |
|3 |  LIMIT        |    |1        |80  |
|4 |   MERGE JOIN  |    |1        |80  |
|5 |    TABLE SCAN |t2  |6        |37  |
|6 |    TABLE SCAN |t3  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c3 > t3.c3], [t2.c2 < t3.c2])
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

delete from t1 where c2 = (select t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |115 |
|1 | SUBPLAN FILTER    |    |1        |114 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |76  |
|4 |   MERGE OUTER JOIN|    |1        |76  |
|5 |    TABLE SCAN     |t2  |5        |37  |
|6 |    TABLE SCAN     |t3  |5        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t2.c1]), filter([t2.c3 > t3.c3]), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c2 < t3.c2])
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t2.c1 from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |60  |
|1 | TABLE SCAN     |t2  |1        |38  |
|2 | TABLE GET      |t1  |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  1 - output([t2.c1]), filter([t2.c2 > 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1;
+----+
| c1 |
+----+
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |1        |79  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter([t2.c2 > 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1;
+----+
| c1 |
+----+
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
+----+
EXPLAIN insert into t12_temp (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |1        |61  |
|1 | SUBPLAN SCAN     |VIEW1|1        |60  |
|2 |  NESTED-LOOP JOIN|     |1        |60  |
|3 |   TABLE SCAN     |t2   |1        |38  |
|4 |   TABLE GET      |t1   |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  3 - output([t2.c1]), filter([t2.c2 > 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

insert into t12_temp (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1);

rollback;
EXPLAIN insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |1        |79  |
|1 | SUBPLAN SCAN     |VIEW1|1        |79  |
|2 |  MERGE OUTER JOIN|     |1        |79  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{t12_temp: ({t12_temp: (t12_temp.__pk_increment, t12_temp.a)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter([t2.c2 > 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t12_temp (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |104 |
|1 | SUBPLAN FILTER    |    |6        |98  |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |60  |
|4 |   NESTED-LOOP JOIN|    |1        |60  |
|5 |    TABLE SCAN     |t2  |1        |38  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([t2.c2 > 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |123 |
|1 | SUBPLAN FILTER    |    |6        |117 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |79  |
|4 |   MERGE OUTER JOIN|    |1        |79  |
|5 |    TABLE SCAN     |t1  |6        |37  |
|6 |    TABLE SCAN     |t2  |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 > 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |99  |
|1 | SUBPLAN FILTER    |    |1        |98  |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |60  |
|4 |   NESTED-LOOP JOIN|    |1        |60  |
|5 |    TABLE SCAN     |t2  |1        |38  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([t2.c2 > 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |118 |
|1 | SUBPLAN FILTER    |    |1        |117 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |79  |
|4 |   MERGE OUTER JOIN|    |1        |79  |
|5 |    TABLE SCAN     |t1  |6        |37  |
|6 |    TABLE SCAN     |t2  |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 > 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |77  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |5        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c1 > 1])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 | NULL | NULL | NULL |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |78  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c1 > 1])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 | NULL | NULL | NULL |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |79  |
|1 | SUBPLAN SCAN     |VIEW1|6        |78  |
|2 |  MERGE OUTER JOIN|     |6        |77  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |5        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c1 > 1])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |79  |
|1 | SUBPLAN SCAN     |VIEW1|6        |79  |
|2 |  MERGE OUTER JOIN|     |6        |78  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c1 > 1])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |80  |
|1 | SUBPLAN FILTER|    |6        |74  |
|2 |  TABLE SCAN   |t1  |6        |37  |
|3 |  TABLE SCAN   |t1  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |117 |
|1 | SUBPLAN FILTER          |    |6        |111 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |73  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    TABLE GET            |t2  |1        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter([? > 1]), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |75  |
|1 | SUBPLAN FILTER|    |1        |74  |
|2 |  TABLE SCAN   |t1  |1        |38  |
|3 |  TABLE SCAN   |t1  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |111 |
|1 | SUBPLAN FILTER          |    |1        |110 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |73  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    TABLE GET            |t2  |1        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter([? > 1]), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |6        |134 |
|1 | TABLE SCAN |t3  |6        |37  |
|2 | MERGE JOIN |    |6        |80  |
|3 |  TABLE SCAN|t1  |6        |37  |
|4 |  TABLE SCAN|t2  |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |6        |134 |
|1 | TABLE SCAN |t3  |6        |37  |
|2 | MERGE JOIN |    |6        |80  |
|3 |  TABLE SCAN|t1  |6        |37  |
|4 |  TABLE SCAN|t2  |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |  2 |    5 | 4    |
|  2 |    5 |  2 |    5 | c    |  4 |    5 | 1    |
|  2 |    5 |  2 |    5 | c    |  5 |    5 | 5    |
|  2 |    5 |  2 |    5 | c    |  6 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |  2 |    5 | 4    |
|  3 |    2 |  3 |    5 | b    |  4 |    5 | 1    |
|  3 |    2 |  3 |    5 | b    |  5 |    5 | 5    |
|  3 |    2 |  3 |    5 | b    |  6 |    5 | c    |
|  4 |    6 |  4 |    6 | o    |  3 |    6 | 1    |
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |136 |
|1 | SUBPLAN SCAN |VIEW1|6        |135 |
|2 |  HASH JOIN   |     |6        |134 |
|3 |   TABLE SCAN |t3   |6        |37  |
|4 |   MERGE JOIN |     |6        |80  |
|5 |    TABLE SCAN|t1   |6        |37  |
|6 |    TABLE SCAN|t2   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  3 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t5_temp (select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |136 |
|1 | SUBPLAN SCAN |VIEW1|6        |135 |
|2 |  HASH JOIN   |     |6        |134 |
|3 |   TABLE SCAN |t3   |6        |37  |
|4 |   MERGE JOIN |     |6        |80  |
|5 |    TABLE SCAN|t1   |6        |37  |
|6 |    TABLE SCAN|t2   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  3 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |161 |
|1 | SUBPLAN FILTER    |    |6        |155 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |118 |
|4 |   NESTED-LOOP JOIN|    |1        |117 |
|5 |    HASH JOIN      |    |1        |81  |
|6 |     TABLE SCAN    |t3  |6        |37  |
|7 |     TABLE SCAN    |t2  |1        |36  |
|8 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  6 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |161 |
|1 | SUBPLAN FILTER    |    |6        |155 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |118 |
|4 |   NESTED-LOOP JOIN|    |1        |117 |
|5 |    HASH JOIN      |    |1        |81  |
|6 |     TABLE SCAN    |t3  |6        |37  |
|7 |     TABLE SCAN    |t2  |1        |36  |
|8 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  6 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |156 |
|1 | SUBPLAN FILTER    |    |1        |155 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |118 |
|4 |   NESTED-LOOP JOIN|    |1        |117 |
|5 |    HASH JOIN      |    |1        |81  |
|6 |     TABLE SCAN    |t3  |6        |37  |
|7 |     TABLE SCAN    |t2  |1        |36  |
|8 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  6 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |156 |
|1 | SUBPLAN FILTER    |    |1        |155 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |118 |
|4 |   NESTED-LOOP JOIN|    |1        |117 |
|5 |    HASH JOIN      |    |1        |81  |
|6 |     TABLE SCAN    |t3  |6        |37  |
|7 |     TABLE SCAN    |t2  |1        |36  |
|8 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  6 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t1.c2 where t2.c2 = 1;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |HASH JOIN        |    |1        |117 |
|1 | NESTED-LOOP JOIN|    |1        |75  |
|2 |  TABLE SCAN     |t2  |1        |38  |
|3 |  TABLE GET      |t1  |1        |36  |
|4 | TABLE SCAN      |t3  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c2 = t1.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 = 1]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)

select * from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t1.c2 where t2.c2 = 1;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t1.c2 where t2.c2 = 1;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |HASH OUTER JOIN  |    |1        |134 |
|1 | TABLE SCAN      |t3  |6        |37  |
|2 | MERGE OUTER JOIN|    |6        |80  |
|3 |  TABLE SCAN     |t2  |6        |37  |
|4 |  TABLE SCAN     |t1  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t2.c2 = 1]), 
      equal_conds([t3.c2 = t1.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t1.c2 where t2.c2 = 1;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |136 |
|1 | SUBPLAN SCAN |VIEW1|6        |135 |
|2 |  HASH JOIN   |     |6        |134 |
|3 |   TABLE SCAN |t3   |6        |37  |
|4 |   MERGE JOIN |     |6        |80  |
|5 |    TABLE SCAN|t1   |6        |37  |
|6 |    TABLE SCAN|t2   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  3 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t5_temp (select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |136 |
|1 | SUBPLAN SCAN |VIEW1|6        |135 |
|2 |  HASH JOIN   |     |6        |134 |
|3 |   TABLE SCAN |t3   |6        |37  |
|4 |   MERGE JOIN |     |6        |80  |
|5 |    TABLE SCAN|t1   |6        |37  |
|6 |    TABLE SCAN|t2   |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  3 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |161 |
|1 | SUBPLAN FILTER    |    |6        |155 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |118 |
|4 |   NESTED-LOOP JOIN|    |1        |117 |
|5 |    HASH JOIN      |    |1        |81  |
|6 |     TABLE SCAN    |t3  |6        |37  |
|7 |     TABLE SCAN    |t2  |1        |36  |
|8 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  6 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |161 |
|1 | SUBPLAN FILTER    |    |6        |155 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |118 |
|4 |   NESTED-LOOP JOIN|    |1        |117 |
|5 |    HASH JOIN      |    |1        |81  |
|6 |     TABLE SCAN    |t3  |6        |37  |
|7 |     TABLE SCAN    |t2  |1        |36  |
|8 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  6 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |156 |
|1 | SUBPLAN FILTER    |    |1        |155 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |118 |
|4 |   NESTED-LOOP JOIN|    |1        |117 |
|5 |    HASH JOIN      |    |1        |81  |
|6 |     TABLE SCAN    |t3  |6        |37  |
|7 |     TABLE SCAN    |t2  |1        |36  |
|8 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  6 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |156 |
|1 | SUBPLAN FILTER    |    |1        |155 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |118 |
|4 |   NESTED-LOOP JOIN|    |1        |117 |
|5 |    HASH JOIN      |    |1        |81  |
|6 |     TABLE SCAN    |t3  |6        |37  |
|7 |     TABLE SCAN    |t2  |1        |36  |
|8 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  6 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |1        |115 |
|1 | NESTED-LOOP OUTER JOIN   |    |1        |75  |
|2 |  TABLE SCAN              |t2  |1        |38  |
|3 |  TABLE GET               |t1  |1        |36  |
|4 | MATERIAL                 |    |1        |40  |
|5 |  TABLE SCAN              |t3  |1        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 = 1]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  5 - output([t3.c2], [t3.c1], [t3.c3]), filter([t3.c2 = 1]), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)

select * from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |HASH OUTER JOIN  |    |1        |134 |
|1 | TABLE SCAN      |t3  |6        |37  |
|2 | MERGE OUTER JOIN|    |6        |80  |
|3 |  TABLE SCAN     |t2  |6        |37  |
|4 |  TABLE SCAN     |t1  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t2.c2 = 1]), 
      equal_conds([t3.c2 = t2.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |1        |115 |
|1 | SUBPLAN SCAN               |VIEW1|1        |115 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |1        |115 |
|3 |   NESTED-LOOP OUTER JOIN   |     |1        |75  |
|4 |    TABLE SCAN              |t2   |1        |38  |
|5 |    TABLE GET               |t1   |1        |36  |
|6 |   MATERIAL                 |     |1        |40  |
|7 |    TABLE SCAN              |t3   |1        |38  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 = 1]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c2], [t3.c1], [t3.c3]), filter([t3.c2 = 1]), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)

insert into t5_temp (select * from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |1        |134 |
|1 | SUBPLAN SCAN      |VIEW1|1        |134 |
|2 |  HASH OUTER JOIN  |     |1        |134 |
|3 |   TABLE SCAN      |t3   |6        |37  |
|4 |   MERGE OUTER JOIN|     |6        |80  |
|5 |    TABLE SCAN     |t2   |6        |37  |
|6 |    TABLE SCAN     |t1   |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t2.c2 = 1]), 
      equal_conds([t3.c2 = t2.c2]), other_conds(nil)
  3 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |158 |
|1 | SUBPLAN FILTER              |    |6        |152 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |114 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |114 |
|5 |    NESTED-LOOP OUTER JOIN   |    |1        |75  |
|6 |     TABLE SCAN              |t2  |1        |38  |
|7 |     TABLE GET               |t1  |1        |36  |
|8 |    MATERIAL                 |    |1        |39  |
|9 |     TABLE SCAN              |t3  |1        |38  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  6 - output([t2.c1]), filter([t2.c2 = 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter([t3.c2 = 1]), 
      access([t3.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |6        |172 |
|1 | SUBPLAN FILTER     |    |6        |166 |
|2 |  TABLE SCAN        |t1  |6        |37  |
|3 |  LIMIT             |    |1        |128 |
|4 |   HASH OUTER JOIN  |    |1        |128 |
|5 |    TABLE SCAN      |t3  |6        |37  |
|6 |    MERGE OUTER JOIN|    |6        |79  |
|7 |     TABLE SCAN     |t2  |6        |37  |
|8 |     TABLE SCAN     |t1  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 = 1]), 
      equal_conds([t3.c2 = t2.c2]), other_conds(nil)
  5 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  6 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |152 |
|1 | SUBPLAN FILTER              |    |1        |151 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |114 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |114 |
|5 |    NESTED-LOOP OUTER JOIN   |    |1        |75  |
|6 |     TABLE SCAN              |t2  |1        |38  |
|7 |     TABLE GET               |t1  |1        |36  |
|8 |    MATERIAL                 |    |1        |39  |
|9 |     TABLE SCAN              |t3  |1        |38  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  6 - output([t2.c1]), filter([t2.c2 = 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter([t3.c2 = 1]), 
      access([t3.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |167 |
|1 | SUBPLAN FILTER     |    |1        |166 |
|2 |  TABLE SCAN        |t1  |1        |38  |
|3 |  LIMIT             |    |1        |128 |
|4 |   HASH OUTER JOIN  |    |1        |128 |
|5 |    TABLE SCAN      |t3  |6        |37  |
|6 |    MERGE OUTER JOIN|    |6        |79  |
|7 |     TABLE SCAN     |t2  |6        |37  |
|8 |     TABLE SCAN     |t1  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 = 1]), 
      equal_conds([t3.c2 = t2.c2]), other_conds(nil)
  5 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  6 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t2.c2 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |HASH JOIN        |    |1        |117 |
|1 | NESTED-LOOP JOIN|    |1        |75  |
|2 |  TABLE SCAN     |t1  |1        |38  |
|3 |  TABLE GET      |t2  |1        |36  |
|4 | TABLE SCAN      |t3  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c2 = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)

select * from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |HASH OUTER JOIN  |    |1        |134 |
|1 | TABLE SCAN      |t3  |6        |37  |
|2 | MERGE OUTER JOIN|    |6        |80  |
|3 |  TABLE SCAN     |t2  |6        |37  |
|4 |  TABLE SCAN     |t1  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t1.c2 = 1]), 
      equal_conds([t3.c2 = t2.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1;
+----+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+
EXPLAIN insert into t5_temp (select * from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |1        |117 |
|1 | SUBPLAN SCAN      |VIEW1|1        |117 |
|2 |  HASH JOIN        |     |1        |117 |
|3 |   NESTED-LOOP JOIN|     |1        |75  |
|4 |    TABLE SCAN     |t1   |1        |38  |
|5 |    TABLE GET      |t2   |1        |36  |
|6 |   TABLE SCAN      |t3   |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c2 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  4 - output([t1.c1], [t1.c2]), filter([t1.c2 = 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)

insert into t5_temp (select * from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1);

rollback;
EXPLAIN insert into t5_temp (select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |1        |134 |
|1 | SUBPLAN SCAN      |VIEW1|1        |134 |
|2 |  HASH OUTER JOIN  |     |1        |134 |
|3 |   TABLE SCAN      |t3   |6        |37  |
|4 |   MERGE OUTER JOIN|     |6        |80  |
|5 |    TABLE SCAN     |t2   |6        |37  |
|6 |    TABLE SCAN     |t1   |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.e, t5_temp.f, t5_temp.g, t5_temp.h)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t1.c2 = 1]), 
      equal_conds([t3.c2 = t2.c2]), other_conds(nil)
  3 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t5_temp (select /*+ NO_REWRITE */* from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |6        |160 |
|1 | SUBPLAN FILTER     |    |6        |154 |
|2 |  TABLE SCAN        |t1  |6        |37  |
|3 |  LIMIT             |    |1        |116 |
|4 |   HASH JOIN        |    |1        |116 |
|5 |    NESTED-LOOP JOIN|    |1        |75  |
|6 |     TABLE SCAN     |t1  |1        |38  |
|7 |     TABLE GET      |t2  |1        |36  |
|8 |    TABLE SCAN      |t3  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t3.c2 = t2.c2]), other_conds(nil)
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  6 - output([t1.c1]), filter([t1.c2 = 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  8 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |6        |172 |
|1 | SUBPLAN FILTER     |    |6        |166 |
|2 |  TABLE SCAN        |t1  |6        |37  |
|3 |  LIMIT             |    |1        |128 |
|4 |   HASH OUTER JOIN  |    |1        |128 |
|5 |    TABLE SCAN      |t3  |6        |37  |
|6 |    MERGE OUTER JOIN|    |6        |79  |
|7 |     TABLE SCAN     |t2  |6        |37  |
|8 |     TABLE SCAN     |t1  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t1.c2 = 1]), 
      equal_conds([t3.c2 = t2.c2]), other_conds(nil)
  5 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  6 - output([t1.c1], [t2.c2], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |155 |
|1 | SUBPLAN FILTER     |    |1        |154 |
|2 |  TABLE SCAN        |t1  |1        |38  |
|3 |  LIMIT             |    |1        |116 |
|4 |   HASH JOIN        |    |1        |116 |
|5 |    NESTED-LOOP JOIN|    |1        |75  |
|6 |     TABLE SCAN     |t1  |1        |38  |
|7 |     TABLE GET      |t2  |1        |36  |
|8 |    TABLE SCAN      |t3  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t3.c2 = t2.c2]), other_conds(nil)
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  6 - output([t1.c1]), filter([t1.c2 = 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  8 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |167 |
|1 | SUBPLAN FILTER     |    |1        |166 |
|2 |  TABLE SCAN        |t1  |1        |38  |
|3 |  LIMIT             |    |1        |128 |
|4 |   HASH OUTER JOIN  |    |1        |128 |
|5 |    TABLE SCAN      |t3  |6        |37  |
|6 |    MERGE OUTER JOIN|    |6        |79  |
|7 |     TABLE SCAN     |t2  |6        |37  |
|8 |     TABLE SCAN     |t1  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t1.c2 = 1]), 
      equal_conds([t3.c2 = t2.c2]), other_conds(nil)
  5 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  6 - output([t1.c1], [t2.c2], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join t2 on t1.c1 = t2.c1 right join t3 on t3.c2 = t2.c2 where t1.c2 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |9        |85  |
|1 | TABLE SCAN     |t2  |3        |38  |
|2 | MATERIAL       |    |6        |38  |
|3 |  TABLE SCAN    |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t2.c1]), filter([t2.c2 IN (1, 2, 3)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3);
+----+----+
| a1 | a2 |
+----+----+
|  2 |  1 |
|  3 |  1 |
|  4 |  1 |
|  5 |  1 |
|  6 |  1 |
+----+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3);
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |9        |96  |
|1 | TABLE SCAN           |t1  |6        |37  |
|2 | MATERIAL             |    |6        |40  |
|3 |  TABLE SCAN          |t2  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter([t2.c2 IN (1, 2, 3)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3);
+----+----+
| a1 | a2 |
+----+----+
|  2 |  1 |
|  3 |  1 |
|  4 |  1 |
|  5 |  1 |
|  6 |  1 |
+----+----+
EXPLAIN insert into t11_temp (select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |9        |88  |
|1 | SUBPLAN SCAN     |VIEW1|9        |87  |
|2 |  NESTED-LOOP JOIN|     |9        |85  |
|3 |   TABLE SCAN     |t2   |3        |38  |
|4 |   MATERIAL       |     |6        |38  |
|5 |    TABLE SCAN    |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.a2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.a1], [VIEW1.a2]), filter(nil), 
      access([VIEW1.a1], [VIEW1.a2])
  2 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t2.c1]), filter([t2.c2 IN (1, 2, 3)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

insert into t11_temp (select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3));

rollback;
EXPLAIN insert into t11_temp (select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |9        |98  |
|1 | SUBPLAN SCAN           |VIEW1|9        |97  |
|2 |  NESTED-LOOP OUTER JOIN|     |9        |96  |
|3 |   TABLE SCAN           |t1   |6        |37  |
|4 |   MATERIAL             |     |6        |40  |
|5 |    TABLE SCAN          |t2   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.a2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.a1], [VIEW1.a2]), filter(nil), 
      access([VIEW1.a1], [VIEW1.a2])
  2 - output([t1.c1], [t2.c1]), filter([t2.c2 IN (1, 2, 3)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t11_temp (select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |119 |
|1 | SUBPLAN FILTER    |    |6        |113 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |75  |
|4 |   NESTED-LOOP JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t2  |1        |36  |
|6 |    MATERIAL       |    |6        |38  |
|7 |     TABLE SCAN    |t1  |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t2.c1]), filter([t2.c2 IN (1, 2, 3)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |121 |
|1 | SUBPLAN FILTER          |    |6        |115 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |78  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |78  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    MATERIAL             |    |6        |40  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 IN (1, 2, 3)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |114 |
|1 | SUBPLAN FILTER    |    |1        |113 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |75  |
|4 |   NESTED-LOOP JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t2  |1        |36  |
|6 |    MATERIAL       |    |6        |38  |
|7 |     TABLE SCAN    |t1  |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t2.c1]), filter([t2.c2 IN (1, 2, 3)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |116 |
|1 | SUBPLAN FILTER          |    |1        |115 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |78  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |78  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    MATERIAL             |    |6        |40  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 IN (1, 2, 3)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, 3) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |9        |85  |
|1 | TABLE SCAN     |t2  |3        |38  |
|2 | MATERIAL       |    |6        |38  |
|3 |  TABLE SCAN    |t1  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t2.c1]), filter([(T_OP_NOT_IN, t2.c2, (1, 2, 3))]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3);
+----+----+
| a1 | a2 |
+----+----+
|  1 |  2 |
|  1 |  3 |
|  1 |  4 |
|  1 |  5 |
|  1 |  6 |
|  2 |  3 |
|  2 |  4 |
|  2 |  5 |
|  2 |  6 |
|  3 |  2 |
|  3 |  4 |
|  3 |  5 |
|  3 |  6 |
|  4 |  2 |
|  4 |  3 |
|  4 |  5 |
|  4 |  6 |
|  5 |  2 |
|  5 |  3 |
|  5 |  4 |
|  5 |  6 |
|  6 |  2 |
|  6 |  3 |
|  6 |  4 |
|  6 |  5 |
+----+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3);
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |9        |96  |
|1 | TABLE SCAN           |t1  |6        |37  |
|2 | MATERIAL             |    |6        |40  |
|3 |  TABLE SCAN          |t2  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter([(T_OP_NOT_IN, t2.c2, (1, 2, 3))]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3);
+----+----+
| a1 | a2 |
+----+----+
|  1 |  2 |
|  1 |  3 |
|  1 |  4 |
|  1 |  5 |
|  1 |  6 |
|  2 |  3 |
|  2 |  4 |
|  2 |  5 |
|  2 |  6 |
|  3 |  2 |
|  3 |  4 |
|  3 |  5 |
|  3 |  6 |
|  4 |  2 |
|  4 |  3 |
|  4 |  5 |
|  4 |  6 |
|  5 |  2 |
|  5 |  3 |
|  5 |  4 |
|  5 |  6 |
|  6 |  2 |
|  6 |  3 |
|  6 |  4 |
|  6 |  5 |
+----+----+
EXPLAIN insert into t11_temp (select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |9        |88  |
|1 | SUBPLAN SCAN     |VIEW1|9        |87  |
|2 |  NESTED-LOOP JOIN|     |9        |85  |
|3 |   TABLE SCAN     |t2   |3        |38  |
|4 |   MATERIAL       |     |6        |38  |
|5 |    TABLE SCAN    |t1   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.a2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.a1], [VIEW1.a2]), filter(nil), 
      access([VIEW1.a1], [VIEW1.a2])
  2 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t2.c1]), filter([(T_OP_NOT_IN, t2.c2, (1, 2, 3))]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

insert into t11_temp (select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3));

rollback;
EXPLAIN insert into t11_temp (select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |9        |98  |
|1 | SUBPLAN SCAN           |VIEW1|9        |97  |
|2 |  NESTED-LOOP OUTER JOIN|     |9        |96  |
|3 |   TABLE SCAN           |t1   |6        |37  |
|4 |   MATERIAL             |     |6        |40  |
|5 |    TABLE SCAN          |t2   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.a2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.a1], [VIEW1.a2]), filter(nil), 
      access([VIEW1.a1], [VIEW1.a2])
  2 - output([t1.c1], [t2.c1]), filter([(T_OP_NOT_IN, t2.c2, (1, 2, 3))]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t11_temp (select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |119 |
|1 | SUBPLAN FILTER    |    |6        |113 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |75  |
|4 |   NESTED-LOOP JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t2  |1        |36  |
|6 |    MATERIAL       |    |6        |38  |
|7 |     TABLE SCAN    |t1  |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t2.c1]), filter([(T_OP_NOT_IN, t2.c2, (1, 2, 3))]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |121 |
|1 | SUBPLAN FILTER          |    |6        |115 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |78  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |78  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    MATERIAL             |    |6        |40  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_IN, t2.c2, (1, 2, 3))]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |114 |
|1 | SUBPLAN FILTER    |    |1        |113 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |75  |
|4 |   NESTED-LOOP JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t2  |1        |36  |
|6 |    MATERIAL       |    |6        |38  |
|7 |     TABLE SCAN    |t1  |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t2.c1]), filter([(T_OP_NOT_IN, t2.c2, (1, 2, 3))]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |116 |
|1 | SUBPLAN FILTER          |    |1        |115 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |78  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |78  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    MATERIAL             |    |6        |40  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_IN, t2.c2, (1, 2, 3))]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, 3) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2);
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |8        |96  |
|1 | TABLE SCAN           |t1  |6        |37  |
|2 | MATERIAL             |    |6        |40  |
|3 |  TABLE SCAN          |t2  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter([t1.c2 IN (1, 2) OR t1.c2 = t2.c2]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2);
+----+----+
| a1 | a2 |
+----+----+
|  1 |  2 |
|  1 |  3 |
|  1 |  4 |
|  1 |  5 |
|  1 |  6 |
|  2 |  3 |
|  3 |  1 |
|  3 |  2 |
|  3 |  4 |
|  3 |  5 |
|  3 |  6 |
|  6 |  5 |
+----+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2);
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |8        |96  |
|1 | TABLE SCAN           |t1  |6        |37  |
|2 | MATERIAL             |    |6        |40  |
|3 |  TABLE SCAN          |t2  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter([t1.c2 IN (1, 2) OR t1.c2 = t2.c2]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2);
+----+----+
| a1 | a2 |
+----+----+
|  1 |  2 |
|  1 |  3 |
|  1 |  4 |
|  1 |  5 |
|  1 |  6 |
|  2 |  3 |
|  3 |  1 |
|  3 |  2 |
|  3 |  4 |
|  3 |  5 |
|  3 |  6 |
|  6 |  5 |
+----+----+
EXPLAIN insert into t11_temp (select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |8        |98  |
|1 | SUBPLAN SCAN           |VIEW1|8        |97  |
|2 |  NESTED-LOOP OUTER JOIN|     |8        |96  |
|3 |   TABLE SCAN           |t1   |6        |37  |
|4 |   MATERIAL             |     |6        |40  |
|5 |    TABLE SCAN          |t2   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.a2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.a1], [VIEW1.a2]), filter(nil), 
      access([VIEW1.a1], [VIEW1.a2])
  2 - output([t1.c1], [t2.c1]), filter([t1.c2 IN (1, 2) OR t1.c2 = t2.c2]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t11_temp (select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2));

rollback;
EXPLAIN insert into t11_temp (select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |8        |98  |
|1 | SUBPLAN SCAN           |VIEW1|8        |97  |
|2 |  NESTED-LOOP OUTER JOIN|     |8        |96  |
|3 |   TABLE SCAN           |t1   |6        |37  |
|4 |   MATERIAL             |     |6        |40  |
|5 |    TABLE SCAN          |t2   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.a2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.a1], [VIEW1.a2]), filter(nil), 
      access([VIEW1.a1], [VIEW1.a2])
  2 - output([t1.c1], [t2.c1]), filter([t1.c2 IN (1, 2) OR t1.c2 = t2.c2]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t11_temp (select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |122 |
|1 | SUBPLAN FILTER          |    |6        |116 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |78  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |78  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    MATERIAL             |    |6        |40  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t1.c2 IN (1, 2) OR t1.c2 = t2.c2]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |122 |
|1 | SUBPLAN FILTER          |    |6        |116 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |78  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |78  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    MATERIAL             |    |6        |40  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t1.c2 IN (1, 2) OR t1.c2 = t2.c2]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 as a1  from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |117 |
|1 | SUBPLAN FILTER          |    |1        |116 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |78  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |78  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    MATERIAL             |    |6        |40  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t1.c2 IN (1, 2) OR t1.c2 = t2.c2]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 as a1  from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |117 |
|1 | SUBPLAN FILTER          |    |1        |116 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |78  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |78  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    MATERIAL             |    |6        |40  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t1.c2 IN (1, 2) OR t1.c2 = t2.c2]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t1.c2 in (1, 2, t2.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |6        |82  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | MATERIAL       |    |2        |39  |
|3 |  TABLE SCAN    |t2  |2        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1]), filter(nil)
  3 - output([t2.c1]), filter([t2.c2 IN (1, 2)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL);
+----+----+
| a1 | a2 |
+----+----+
|  2 |  1 |
|  3 |  1 |
|  4 |  1 |
|  5 |  1 |
|  6 |  1 |
+----+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL);
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |6        |96  |
|1 | TABLE SCAN           |t1  |6        |37  |
|2 | MATERIAL             |    |6        |40  |
|3 |  TABLE SCAN          |t2  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter([t2.c2 IN (1, 2) OR t2.c2 = NULL]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL);
+----+----+
| a1 | a2 |
+----+----+
|  2 |  1 |
|  3 |  1 |
|  4 |  1 |
|  5 |  1 |
|  6 |  1 |
+----+----+
EXPLAIN insert into t11_temp (select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |84  |
|1 | SUBPLAN SCAN     |VIEW1|6        |83  |
|2 |  NESTED-LOOP JOIN|     |6        |82  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   MATERIAL       |     |2        |39  |
|5 |    TABLE SCAN    |t2   |2        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.a2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.a1], [VIEW1.a2]), filter(nil), 
      access([VIEW1.a1], [VIEW1.a2])
  2 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1]), filter(nil)
  5 - output([t2.c1]), filter([t2.c2 IN (1, 2)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t11_temp (select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL));

rollback;
EXPLAIN insert into t11_temp (select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |6        |98  |
|1 | SUBPLAN SCAN           |VIEW1|6        |97  |
|2 |  NESTED-LOOP OUTER JOIN|     |6        |96  |
|3 |   TABLE SCAN           |t1   |6        |37  |
|4 |   MATERIAL             |     |6        |40  |
|5 |    TABLE SCAN          |t2   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.a2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.a1], [VIEW1.a2]), filter(nil), 
      access([VIEW1.a1], [VIEW1.a2])
  2 - output([t1.c1], [t2.c1]), filter([t2.c2 IN (1, 2) OR t2.c2 = NULL]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t11_temp (select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |119 |
|1 | SUBPLAN FILTER    |    |6        |113 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |76  |
|4 |   NESTED-LOOP JOIN|    |1        |76  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    MATERIAL       |    |2        |39  |
|7 |     TABLE SCAN    |t2  |2        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil)
  7 - output([t2.c1]), filter([t2.c2 IN (1, 2)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |123 |
|1 | SUBPLAN FILTER          |    |6        |117 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |79  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |79  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    MATERIAL             |    |6        |40  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 IN (1, 2) OR t2.c2 = NULL]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |114 |
|1 | SUBPLAN FILTER    |    |1        |113 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |76  |
|4 |   NESTED-LOOP JOIN|    |1        |76  |
|5 |    TABLE SCAN     |t1  |1        |36  |
|6 |    MATERIAL       |    |2        |39  |
|7 |     TABLE SCAN    |t2  |2        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil)
  7 - output([t2.c1]), filter([t2.c2 IN (1, 2)]), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |117 |
|1 | SUBPLAN FILTER          |    |1        |116 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |79  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |79  |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    MATERIAL             |    |6        |40  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 IN (1, 2) OR t2.c2 = NULL]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 in (1, 2, NULL) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL);
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |18       |94  |
|1 | TABLE SCAN           |t1  |6        |37  |
|2 | MATERIAL             |    |6        |38  |
|3 |  TABLE SCAN          |t2  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), startup_filter([0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1]), filter(nil)
  3 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL);
+----+----+
| a1 | a2 |
+----+----+
+----+----+
EXPLAIN select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL);
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |0        |96  |
|1 | TABLE SCAN           |t1  |6        |37  |
|2 | MATERIAL             |    |6        |40  |
|3 |  TABLE SCAN          |t2  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter([(T_OP_NOT_IN, t2.c2, (1, 2)) AND t2.c2 != NULL]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL);
+----+----+
| a1 | a2 |
+----+----+
+----+----+
EXPLAIN insert into t11_temp (select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |18       |99  |
|1 | SUBPLAN SCAN           |VIEW1|18       |97  |
|2 |  NESTED-LOOP OUTER JOIN|     |18       |94  |
|3 |   TABLE SCAN           |t1   |6        |37  |
|4 |   MATERIAL             |     |6        |38  |
|5 |    TABLE SCAN          |t2   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.a2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.a1], [VIEW1.a2]), filter(nil), startup_filter([0]), 
      access([VIEW1.a1], [VIEW1.a2])
  2 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1]), filter(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

insert into t11_temp (select t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL));

rollback;
EXPLAIN insert into t11_temp (select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |0        |96  |
|1 | SUBPLAN SCAN           |VIEW1|0        |96  |
|2 |  NESTED-LOOP OUTER JOIN|     |0        |96  |
|3 |   TABLE SCAN           |t1   |6        |37  |
|4 |   MATERIAL             |     |6        |40  |
|5 |    TABLE SCAN          |t2   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.a2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.a1], [VIEW1.a2]), filter(nil), 
      access([VIEW1.a1], [VIEW1.a2])
  2 - output([t1.c1], [t2.c1]), filter([(T_OP_NOT_IN, t2.c2, (1, 2)) AND t2.c2 != NULL]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t11_temp (select /*+ NO_REWRITE */t1.c1 as a1, t2.c1 as a2 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL) limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                   |     |6        |119 |
|1 | SUBPLAN FILTER          |     |6        |113 |
|2 |  TABLE SCAN             |t1   |6        |37  |
|3 |  LIMIT                  |     |1        |75  |
|4 |   NESTED-LOOP OUTER JOIN|     |1        |75  |
|5 |    SUBPLAN SCAN         |VIEW1|1        |36  |
|6 |     TABLE SCAN          |t1   |1        |36  |
|7 |    MATERIAL             |     |6        |38  |
|8 |     TABLE SCAN          |t2   |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      conds([VIEW1.t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |140 |
|1 | SUBPLAN FILTER          |    |6        |134 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |0        |96  |
|4 |   NESTED-LOOP OUTER JOIN|    |0        |96  |
|5 |    TABLE SCAN           |t1  |6        |37  |
|6 |    MATERIAL             |    |6        |40  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_IN, t2.c2, (1, 2)) AND t2.c2 != NULL]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL) limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                   |     |1        |114 |
|1 | SUBPLAN FILTER          |     |1        |113 |
|2 |  TABLE SCAN             |t1   |1        |38  |
|3 |  LIMIT                  |     |1        |75  |
|4 |   NESTED-LOOP OUTER JOIN|     |1        |75  |
|5 |    SUBPLAN SCAN         |VIEW1|1        |36  |
|6 |     TABLE SCAN          |t1   |1        |36  |
|7 |    MATERIAL             |     |6        |38  |
|8 |     TABLE SCAN          |t2   |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      conds([VIEW1.t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |134 |
|1 | SUBPLAN FILTER          |    |1        |133 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |0        |96  |
|4 |   NESTED-LOOP OUTER JOIN|    |0        |96  |
|5 |    TABLE SCAN           |t1  |6        |37  |
|6 |    MATERIAL             |    |6        |40  |
|7 |     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_IN, t2.c2, (1, 2)) AND t2.c2 != NULL]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 as a1 from t1 left join t2 on t1.c1 != t2.c1 where t2.c2 not in (1, 2, NULL) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN  |    |1        |205 |
|1 | NESTED-LOOP OUTER JOIN |    |2        |156 |
|2 |  NESTED-LOOP OUTER JOIN|    |3        |102 |
|3 |   TABLE SCAN           |t1  |6        |37  |
|4 |   MATERIAL             |    |6        |44  |
|5 |    TABLE SCAN          |t2  |6        |37  |
|6 |  MATERIAL              |    |6        |44  |
|7 |   TABLE SCAN           |t3  |6        |37  |
|8 | MATERIAL               |    |6        |44  |
|9 |  TABLE SCAN            |t4  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN  |    |1        |205 |
|1 | NESTED-LOOP OUTER JOIN |    |2        |156 |
|2 |  NESTED-LOOP OUTER JOIN|    |3        |102 |
|3 |   TABLE SCAN           |t1  |6        |37  |
|4 |   MATERIAL             |    |6        |44  |
|5 |    TABLE SCAN          |t2  |6        |37  |
|6 |  MATERIAL              |    |6        |44  |
|7 |   TABLE SCAN           |t3  |6        |37  |
|8 | MATERIAL               |    |6        |44  |
|9 |  TABLE SCAN            |t4  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT                    |     |1        |205 |
|1 | SUBPLAN SCAN             |VIEW1|1        |205 |
|2 |  NESTED-LOOP OUTER JOIN  |     |1        |205 |
|3 |   NESTED-LOOP OUTER JOIN |     |2        |156 |
|4 |    NESTED-LOOP OUTER JOIN|     |3        |102 |
|5 |     TABLE SCAN           |t1   |6        |37  |
|6 |     MATERIAL             |     |6        |44  |
|7 |      TABLE SCAN          |t2   |6        |37  |
|8 |    MATERIAL              |     |6        |44  |
|9 |     TABLE SCAN           |t3   |6        |37  |
|10|   MATERIAL               |     |6        |44  |
|11|    TABLE SCAN            |t4   |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  11 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT                    |     |1        |205 |
|1 | SUBPLAN SCAN             |VIEW1|1        |205 |
|2 |  NESTED-LOOP OUTER JOIN  |     |1        |205 |
|3 |   NESTED-LOOP OUTER JOIN |     |2        |156 |
|4 |    NESTED-LOOP OUTER JOIN|     |3        |102 |
|5 |     TABLE SCAN           |t1   |6        |37  |
|6 |     MATERIAL             |     |6        |44  |
|7 |      TABLE SCAN          |t2   |6        |37  |
|8 |    MATERIAL              |     |6        |44  |
|9 |     TABLE SCAN           |t3   |6        |37  |
|10|   MATERIAL               |     |6        |44  |
|11|    TABLE SCAN            |t4   |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  11 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                     |    |6        |228 |
|1 | SUBPLAN FILTER            |    |6        |222 |
|2 |  TABLE SCAN               |t1  |6        |37  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                     |    |6        |228 |
|1 | SUBPLAN FILTER            |    |6        |222 |
|2 |  TABLE SCAN               |t1  |6        |37  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                     |    |1        |223 |
|1 | SUBPLAN FILTER            |    |1        |222 |
|2 |  TABLE SCAN               |t1  |1        |38  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                     |    |1        |223 |
|1 | SUBPLAN FILTER            |    |1        |222 |
|2 |  TABLE SCAN               |t1  |1        |38  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN |    |1        |195 |
|1 | NESTED-LOOP OUTER JOIN|    |2        |147 |
|2 |  NESTED-LOOP JOIN     |    |3        |92  |
|3 |   TABLE GET           |t4  |1        |53  |
|4 |   TABLE SCAN          |t1  |6        |37  |
|5 |  MATERIAL             |    |6        |44  |
|6 |   TABLE SCAN          |t2  |6        |37  |
|7 | MATERIAL              |    |6        |44  |
|8 |  TABLE SCAN           |t3  |6        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN  |    |1        |205 |
|1 | NESTED-LOOP OUTER JOIN |    |2        |156 |
|2 |  NESTED-LOOP OUTER JOIN|    |3        |102 |
|3 |   TABLE SCAN           |t1  |6        |37  |
|4 |   MATERIAL             |    |6        |44  |
|5 |    TABLE SCAN          |t2  |6        |37  |
|6 |  MATERIAL              |    |6        |44  |
|7 |   TABLE SCAN           |t3  |6        |37  |
|8 | MATERIAL               |    |6        |44  |
|9 |  TABLE SCAN            |t4  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |1        |196 |
|1 | SUBPLAN SCAN            |VIEW1|1        |196 |
|2 |  NESTED-LOOP OUTER JOIN |     |1        |195 |
|3 |   NESTED-LOOP OUTER JOIN|     |2        |147 |
|4 |    NESTED-LOOP JOIN     |     |3        |92  |
|5 |     TABLE GET           |t4   |1        |53  |
|6 |     TABLE SCAN          |t1   |6        |37  |
|7 |    MATERIAL             |     |6        |44  |
|8 |     TABLE SCAN          |t2   |6        |37  |
|9 |   MATERIAL              |     |6        |44  |
|10|    TABLE SCAN           |t3   |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  10 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT                    |     |1        |205 |
|1 | SUBPLAN SCAN             |VIEW1|1        |205 |
|2 |  NESTED-LOOP OUTER JOIN  |     |1        |205 |
|3 |   NESTED-LOOP OUTER JOIN |     |2        |156 |
|4 |    NESTED-LOOP OUTER JOIN|     |3        |102 |
|5 |     TABLE SCAN           |t1   |6        |37  |
|6 |     MATERIAL             |     |6        |44  |
|7 |      TABLE SCAN          |t2   |6        |37  |
|8 |    MATERIAL              |     |6        |44  |
|9 |     TABLE SCAN           |t3   |6        |37  |
|10|   MATERIAL               |     |6        |44  |
|11|    TABLE SCAN            |t4   |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  11 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |6        |226 |
|1 | SUBPLAN FILTER           |    |6        |220 |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  LIMIT                   |    |1        |182 |
|4 |   NESTED-LOOP OUTER JOIN |    |1        |182 |
|5 |    NESTED-LOOP OUTER JOIN|    |2        |140 |
|6 |     NESTED-LOOP JOIN     |    |3        |92  |
|7 |      TABLE GET           |t4  |1        |52  |
|8 |      TABLE SCAN          |t1  |6        |37  |
|9 |     MATERIAL             |    |6        |38  |
|10|      TABLE SCAN          |t2  |6        |37  |
|11|    MATERIAL              |    |6        |38  |
|12|     TABLE SCAN           |t3  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([t3.c1]), filter(nil)
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                     |    |6        |228 |
|1 | SUBPLAN FILTER            |    |6        |222 |
|2 |  TABLE SCAN               |t1  |6        |37  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |221 |
|1 | SUBPLAN FILTER           |    |1        |220 |
|2 |  TABLE SCAN              |t1  |1        |38  |
|3 |  LIMIT                   |    |1        |182 |
|4 |   NESTED-LOOP OUTER JOIN |    |1        |182 |
|5 |    NESTED-LOOP OUTER JOIN|    |2        |140 |
|6 |     NESTED-LOOP JOIN     |    |3        |92  |
|7 |      TABLE GET           |t4  |1        |52  |
|8 |      TABLE SCAN          |t1  |6        |37  |
|9 |     MATERIAL             |    |6        |38  |
|10|      TABLE SCAN          |t2  |6        |37  |
|11|    MATERIAL              |    |6        |38  |
|12|     TABLE SCAN           |t3  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([t3.c1]), filter(nil)
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                     |    |1        |223 |
|1 | SUBPLAN FILTER            |    |1        |222 |
|2 |  TABLE SCAN               |t1  |1        |38  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN |    |1        |195 |
|1 | NESTED-LOOP OUTER JOIN|    |2        |147 |
|2 |  NESTED-LOOP JOIN     |    |3        |92  |
|3 |   TABLE GET           |t3  |1        |53  |
|4 |   TABLE SCAN          |t1  |6        |37  |
|5 |  MATERIAL             |    |6        |44  |
|6 |   TABLE SCAN          |t2  |6        |37  |
|7 | MATERIAL              |    |6        |44  |
|8 |  TABLE SCAN           |t4  |6        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN  |    |1        |205 |
|1 | NESTED-LOOP OUTER JOIN |    |2        |156 |
|2 |  NESTED-LOOP OUTER JOIN|    |3        |102 |
|3 |   TABLE SCAN           |t1  |6        |37  |
|4 |   MATERIAL             |    |6        |44  |
|5 |    TABLE SCAN          |t2  |6        |37  |
|6 |  MATERIAL              |    |6        |44  |
|7 |   TABLE SCAN           |t3  |6        |37  |
|8 | MATERIAL               |    |6        |44  |
|9 |  TABLE SCAN            |t4  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |1        |196 |
|1 | SUBPLAN SCAN            |VIEW1|1        |196 |
|2 |  NESTED-LOOP OUTER JOIN |     |1        |195 |
|3 |   NESTED-LOOP OUTER JOIN|     |2        |147 |
|4 |    NESTED-LOOP JOIN     |     |3        |92  |
|5 |     TABLE GET           |t3   |1        |53  |
|6 |     TABLE SCAN          |t1   |6        |37  |
|7 |    MATERIAL             |     |6        |44  |
|8 |     TABLE SCAN          |t2   |6        |37  |
|9 |   MATERIAL              |     |6        |44  |
|10|    TABLE SCAN           |t4   |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT                    |     |1        |205 |
|1 | SUBPLAN SCAN             |VIEW1|1        |205 |
|2 |  NESTED-LOOP OUTER JOIN  |     |1        |205 |
|3 |   NESTED-LOOP OUTER JOIN |     |2        |156 |
|4 |    NESTED-LOOP OUTER JOIN|     |3        |102 |
|5 |     TABLE SCAN           |t1   |6        |37  |
|6 |     MATERIAL             |     |6        |44  |
|7 |      TABLE SCAN          |t2   |6        |37  |
|8 |    MATERIAL              |     |6        |44  |
|9 |     TABLE SCAN           |t3   |6        |37  |
|10|   MATERIAL               |     |6        |44  |
|11|    TABLE SCAN            |t4   |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  11 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |6        |226 |
|1 | SUBPLAN FILTER           |    |6        |220 |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  LIMIT                   |    |1        |182 |
|4 |   NESTED-LOOP OUTER JOIN |    |1        |182 |
|5 |    NESTED-LOOP OUTER JOIN|    |2        |140 |
|6 |     NESTED-LOOP JOIN     |    |3        |92  |
|7 |      TABLE GET           |t3  |1        |52  |
|8 |      TABLE SCAN          |t1  |6        |37  |
|9 |     MATERIAL             |    |6        |38  |
|10|      TABLE SCAN          |t2  |6        |37  |
|11|    MATERIAL              |    |6        |38  |
|12|     TABLE SCAN           |t4  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil)
  12 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                     |    |6        |228 |
|1 | SUBPLAN FILTER            |    |6        |222 |
|2 |  TABLE SCAN               |t1  |6        |37  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |221 |
|1 | SUBPLAN FILTER           |    |1        |220 |
|2 |  TABLE SCAN              |t1  |1        |38  |
|3 |  LIMIT                   |    |1        |182 |
|4 |   NESTED-LOOP OUTER JOIN |    |1        |182 |
|5 |    NESTED-LOOP OUTER JOIN|    |2        |140 |
|6 |     NESTED-LOOP JOIN     |    |3        |92  |
|7 |      TABLE GET           |t3  |1        |52  |
|8 |      TABLE SCAN          |t1  |6        |37  |
|9 |     MATERIAL             |    |6        |38  |
|10|      TABLE SCAN          |t2  |6        |37  |
|11|    MATERIAL              |    |6        |38  |
|12|     TABLE SCAN           |t4  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil)
  12 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                     |    |1        |223 |
|1 | SUBPLAN FILTER            |    |1        |222 |
|2 |  TABLE SCAN               |t1  |1        |38  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |1        |195 |
|1 | NESTED-LOOP JOIN     |    |2        |146 |
|2 |  TABLE GET           |t4  |1        |53  |
|3 |  NESTED-LOOP JOIN    |    |3        |92  |
|4 |   TABLE GET          |t3  |1        |53  |
|5 |   TABLE SCAN         |t1  |6        |37  |
|6 | MATERIAL             |    |6        |44  |
|7 |  TABLE SCAN          |t2  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN  |    |1        |205 |
|1 | NESTED-LOOP OUTER JOIN |    |2        |156 |
|2 |  NESTED-LOOP OUTER JOIN|    |3        |102 |
|3 |   TABLE SCAN           |t1  |6        |37  |
|4 |   MATERIAL             |    |6        |44  |
|5 |    TABLE SCAN          |t2  |6        |37  |
|6 |  MATERIAL              |    |6        |44  |
|7 |   TABLE SCAN           |t3  |6        |37  |
|8 | MATERIAL               |    |6        |44  |
|9 |  TABLE SCAN            |t4  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |1        |195 |
|1 | SUBPLAN SCAN           |VIEW1|1        |195 |
|2 |  NESTED-LOOP OUTER JOIN|     |1        |195 |
|3 |   NESTED-LOOP JOIN     |     |2        |146 |
|4 |    TABLE GET           |t4   |1        |53  |
|5 |    NESTED-LOOP JOIN    |     |3        |92  |
|6 |     TABLE GET          |t3   |1        |53  |
|7 |     TABLE SCAN         |t1   |6        |37  |
|8 |   MATERIAL             |     |6        |44  |
|9 |    TABLE SCAN          |t2   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  5 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT                    |     |1        |205 |
|1 | SUBPLAN SCAN             |VIEW1|1        |205 |
|2 |  NESTED-LOOP OUTER JOIN  |     |1        |205 |
|3 |   NESTED-LOOP OUTER JOIN |     |2        |156 |
|4 |    NESTED-LOOP OUTER JOIN|     |3        |102 |
|5 |     TABLE SCAN           |t1   |6        |37  |
|6 |     MATERIAL             |     |6        |44  |
|7 |      TABLE SCAN          |t2   |6        |37  |
|8 |    MATERIAL              |     |6        |44  |
|9 |     TABLE SCAN           |t3   |6        |37  |
|10|   MATERIAL               |     |6        |44  |
|11|    TABLE SCAN            |t4   |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  11 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |232 |
|1 | SUBPLAN FILTER          |    |6        |226 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |188 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |188 |
|5 |    NESTED-LOOP JOIN     |    |2        |145 |
|6 |     TABLE GET           |t4  |1        |52  |
|7 |     NESTED-LOOP JOIN    |    |3        |92  |
|8 |      TABLE GET          |t3  |1        |52  |
|9 |      TABLE SCAN         |t1  |6        |37  |
|10|    MATERIAL             |    |6        |38  |
|11|     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  7 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                     |    |6        |228 |
|1 | SUBPLAN FILTER            |    |6        |222 |
|2 |  TABLE SCAN               |t1  |6        |37  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |227 |
|1 | SUBPLAN FILTER          |    |1        |226 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |188 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |188 |
|5 |    NESTED-LOOP JOIN     |    |2        |145 |
|6 |     TABLE GET           |t4  |1        |52  |
|7 |     NESTED-LOOP JOIN    |    |3        |92  |
|8 |      TABLE GET          |t3  |1        |52  |
|9 |      TABLE SCAN         |t1  |6        |37  |
|10|    MATERIAL             |    |6        |38  |
|11|     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  7 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                     |    |1        |223 |
|1 | SUBPLAN FILTER            |    |1        |222 |
|2 |  TABLE SCAN               |t1  |1        |38  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN |    |1        |195 |
|1 | NESTED-LOOP OUTER JOIN|    |2        |147 |
|2 |  NESTED-LOOP JOIN     |    |3        |92  |
|3 |   TABLE GET           |t2  |1        |53  |
|4 |   TABLE SCAN          |t1  |6        |37  |
|5 |  MATERIAL             |    |6        |44  |
|6 |   TABLE SCAN          |t3  |6        |37  |
|7 | MATERIAL              |    |6        |44  |
|8 |  TABLE SCAN           |t4  |6        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN  |    |1        |205 |
|1 | NESTED-LOOP OUTER JOIN |    |2        |156 |
|2 |  NESTED-LOOP OUTER JOIN|    |3        |102 |
|3 |   TABLE SCAN           |t1  |6        |37  |
|4 |   MATERIAL             |    |6        |44  |
|5 |    TABLE SCAN          |t2  |6        |37  |
|6 |  MATERIAL              |    |6        |44  |
|7 |   TABLE SCAN           |t3  |6        |37  |
|8 | MATERIAL               |    |6        |44  |
|9 |  TABLE SCAN            |t4  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |1        |196 |
|1 | SUBPLAN SCAN            |VIEW1|1        |196 |
|2 |  NESTED-LOOP OUTER JOIN |     |1        |195 |
|3 |   NESTED-LOOP OUTER JOIN|     |2        |147 |
|4 |    NESTED-LOOP JOIN     |     |3        |92  |
|5 |     TABLE GET           |t2   |1        |53  |
|6 |     TABLE SCAN          |t1   |6        |37  |
|7 |    MATERIAL             |     |6        |44  |
|8 |     TABLE SCAN          |t3   |6        |37  |
|9 |   MATERIAL              |     |6        |44  |
|10|    TABLE SCAN           |t4   |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT                    |     |1        |205 |
|1 | SUBPLAN SCAN             |VIEW1|1        |205 |
|2 |  NESTED-LOOP OUTER JOIN  |     |1        |205 |
|3 |   NESTED-LOOP OUTER JOIN |     |2        |156 |
|4 |    NESTED-LOOP OUTER JOIN|     |3        |102 |
|5 |     TABLE SCAN           |t1   |6        |37  |
|6 |     MATERIAL             |     |6        |44  |
|7 |      TABLE SCAN          |t2   |6        |37  |
|8 |    MATERIAL              |     |6        |44  |
|9 |     TABLE SCAN           |t3   |6        |37  |
|10|   MATERIAL               |     |6        |44  |
|11|    TABLE SCAN            |t4   |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  11 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |6        |226 |
|1 | SUBPLAN FILTER           |    |6        |220 |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  LIMIT                   |    |1        |182 |
|4 |   NESTED-LOOP OUTER JOIN |    |1        |182 |
|5 |    NESTED-LOOP OUTER JOIN|    |2        |140 |
|6 |     NESTED-LOOP JOIN     |    |3        |92  |
|7 |      TABLE GET           |t2  |1        |52  |
|8 |      TABLE SCAN          |t1  |6        |37  |
|9 |     MATERIAL             |    |6        |38  |
|10|      TABLE SCAN          |t3  |6        |37  |
|11|    MATERIAL              |    |6        |38  |
|12|     TABLE SCAN           |t4  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil)
  12 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                     |    |6        |228 |
|1 | SUBPLAN FILTER            |    |6        |222 |
|2 |  TABLE SCAN               |t1  |6        |37  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |221 |
|1 | SUBPLAN FILTER           |    |1        |220 |
|2 |  TABLE SCAN              |t1  |1        |38  |
|3 |  LIMIT                   |    |1        |182 |
|4 |   NESTED-LOOP OUTER JOIN |    |1        |182 |
|5 |    NESTED-LOOP OUTER JOIN|    |2        |140 |
|6 |     NESTED-LOOP JOIN     |    |3        |92  |
|7 |      TABLE GET           |t2  |1        |52  |
|8 |      TABLE SCAN          |t1  |6        |37  |
|9 |     MATERIAL             |    |6        |38  |
|10|      TABLE SCAN          |t3  |6        |37  |
|11|    MATERIAL              |    |6        |38  |
|12|     TABLE SCAN           |t4  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil)
  12 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                     |    |1        |223 |
|1 | SUBPLAN FILTER            |    |1        |222 |
|2 |  TABLE SCAN               |t1  |1        |38  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |1        |195 |
|1 | NESTED-LOOP JOIN     |    |2        |146 |
|2 |  TABLE GET           |t4  |1        |53  |
|3 |  NESTED-LOOP JOIN    |    |3        |92  |
|4 |   TABLE GET          |t2  |1        |53  |
|5 |   TABLE SCAN         |t1  |6        |37  |
|6 | MATERIAL             |    |6        |44  |
|7 |  TABLE SCAN          |t3  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN  |    |1        |205 |
|1 | NESTED-LOOP OUTER JOIN |    |2        |156 |
|2 |  NESTED-LOOP OUTER JOIN|    |3        |102 |
|3 |   TABLE SCAN           |t1  |6        |37  |
|4 |   MATERIAL             |    |6        |44  |
|5 |    TABLE SCAN          |t2  |6        |37  |
|6 |  MATERIAL              |    |6        |44  |
|7 |   TABLE SCAN           |t3  |6        |37  |
|8 | MATERIAL               |    |6        |44  |
|9 |  TABLE SCAN            |t4  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |1        |195 |
|1 | SUBPLAN SCAN           |VIEW1|1        |195 |
|2 |  NESTED-LOOP OUTER JOIN|     |1        |195 |
|3 |   NESTED-LOOP JOIN     |     |2        |146 |
|4 |    TABLE GET           |t4   |1        |53  |
|5 |    NESTED-LOOP JOIN    |     |3        |92  |
|6 |     TABLE GET          |t2   |1        |53  |
|7 |     TABLE SCAN         |t1   |6        |37  |
|8 |   MATERIAL             |     |6        |44  |
|9 |    TABLE SCAN          |t3   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT                    |     |1        |205 |
|1 | SUBPLAN SCAN             |VIEW1|1        |205 |
|2 |  NESTED-LOOP OUTER JOIN  |     |1        |205 |
|3 |   NESTED-LOOP OUTER JOIN |     |2        |156 |
|4 |    NESTED-LOOP OUTER JOIN|     |3        |102 |
|5 |     TABLE SCAN           |t1   |6        |37  |
|6 |     MATERIAL             |     |6        |44  |
|7 |      TABLE SCAN          |t2   |6        |37  |
|8 |    MATERIAL              |     |6        |44  |
|9 |     TABLE SCAN           |t3   |6        |37  |
|10|   MATERIAL               |     |6        |44  |
|11|    TABLE SCAN            |t4   |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  11 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |232 |
|1 | SUBPLAN FILTER          |    |6        |226 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |188 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |188 |
|5 |    NESTED-LOOP JOIN     |    |2        |145 |
|6 |     TABLE GET           |t4  |1        |52  |
|7 |     NESTED-LOOP JOIN    |    |3        |92  |
|8 |      TABLE GET          |t2  |1        |52  |
|9 |      TABLE SCAN         |t1  |6        |37  |
|10|    MATERIAL             |    |6        |38  |
|11|     TABLE SCAN          |t3  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  7 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                     |    |6        |228 |
|1 | SUBPLAN FILTER            |    |6        |222 |
|2 |  TABLE SCAN               |t1  |6        |37  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |227 |
|1 | SUBPLAN FILTER          |    |1        |226 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |188 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |188 |
|5 |    NESTED-LOOP JOIN     |    |2        |145 |
|6 |     TABLE GET           |t4  |1        |52  |
|7 |     NESTED-LOOP JOIN    |    |3        |92  |
|8 |      TABLE GET          |t2  |1        |52  |
|9 |      TABLE SCAN         |t1  |6        |37  |
|10|    MATERIAL             |    |6        |38  |
|11|     TABLE SCAN          |t3  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  7 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                     |    |1        |223 |
|1 | SUBPLAN FILTER            |    |1        |222 |
|2 |  TABLE SCAN               |t1  |1        |38  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |1        |195 |
|1 | NESTED-LOOP JOIN     |    |2        |146 |
|2 |  TABLE GET           |t2  |1        |53  |
|3 |  NESTED-LOOP JOIN    |    |3        |92  |
|4 |   TABLE GET          |t3  |1        |53  |
|5 |   TABLE SCAN         |t1  |6        |37  |
|6 | MATERIAL             |    |6        |44  |
|7 |  TABLE SCAN          |t4  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN  |    |1        |205 |
|1 | NESTED-LOOP OUTER JOIN |    |2        |156 |
|2 |  NESTED-LOOP OUTER JOIN|    |3        |102 |
|3 |   TABLE SCAN           |t1  |6        |37  |
|4 |   MATERIAL             |    |6        |44  |
|5 |    TABLE SCAN          |t2  |6        |37  |
|6 |  MATERIAL              |    |6        |44  |
|7 |   TABLE SCAN           |t3  |6        |37  |
|8 | MATERIAL               |    |6        |44  |
|9 |  TABLE SCAN            |t4  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |1        |195 |
|1 | SUBPLAN SCAN           |VIEW1|1        |195 |
|2 |  NESTED-LOOP OUTER JOIN|     |1        |195 |
|3 |   NESTED-LOOP JOIN     |     |2        |146 |
|4 |    TABLE GET           |t2   |1        |53  |
|5 |    NESTED-LOOP JOIN    |     |3        |92  |
|6 |     TABLE GET          |t3   |1        |53  |
|7 |     TABLE SCAN         |t1   |6        |37  |
|8 |   MATERIAL             |     |6        |44  |
|9 |    TABLE SCAN          |t4   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  5 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT                    |     |1        |205 |
|1 | SUBPLAN SCAN             |VIEW1|1        |205 |
|2 |  NESTED-LOOP OUTER JOIN  |     |1        |205 |
|3 |   NESTED-LOOP OUTER JOIN |     |2        |156 |
|4 |    NESTED-LOOP OUTER JOIN|     |3        |102 |
|5 |     TABLE SCAN           |t1   |6        |37  |
|6 |     MATERIAL             |     |6        |44  |
|7 |      TABLE SCAN          |t2   |6        |37  |
|8 |    MATERIAL              |     |6        |44  |
|9 |     TABLE SCAN           |t3   |6        |37  |
|10|   MATERIAL               |     |6        |44  |
|11|    TABLE SCAN            |t4   |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  11 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |232 |
|1 | SUBPLAN FILTER          |    |6        |226 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |188 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |188 |
|5 |    NESTED-LOOP JOIN     |    |2        |145 |
|6 |     TABLE GET           |t2  |1        |52  |
|7 |     NESTED-LOOP JOIN    |    |3        |92  |
|8 |      TABLE GET          |t3  |1        |52  |
|9 |      TABLE SCAN         |t1  |6        |37  |
|10|    MATERIAL             |    |6        |38  |
|11|     TABLE SCAN          |t4  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                     |    |6        |228 |
|1 | SUBPLAN FILTER            |    |6        |222 |
|2 |  TABLE SCAN               |t1  |6        |37  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |227 |
|1 | SUBPLAN FILTER          |    |1        |226 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |188 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |188 |
|5 |    NESTED-LOOP JOIN     |    |2        |145 |
|6 |     TABLE GET           |t2  |1        |52  |
|7 |     NESTED-LOOP JOIN    |    |3        |92  |
|8 |      TABLE GET          |t3  |1        |52  |
|9 |      TABLE SCAN         |t1  |6        |37  |
|10|    MATERIAL             |    |6        |38  |
|11|     TABLE SCAN          |t4  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                     |    |1        |223 |
|1 | SUBPLAN FILTER            |    |1        |222 |
|2 |  TABLE SCAN               |t1  |1        |38  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |NESTED-LOOP JOIN  |    |1        |199 |
|1 | TABLE GET        |t4  |1        |53  |
|2 | NESTED-LOOP JOIN |    |2        |146 |
|3 |  TABLE GET       |t3  |1        |53  |
|4 |  NESTED-LOOP JOIN|    |3        |92  |
|5 |   TABLE GET      |t2  |1        |53  |
|6 |   TABLE SCAN     |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN  |    |1        |205 |
|1 | NESTED-LOOP OUTER JOIN |    |2        |156 |
|2 |  NESTED-LOOP OUTER JOIN|    |3        |102 |
|3 |   TABLE SCAN           |t1  |6        |37  |
|4 |   MATERIAL             |    |6        |44  |
|5 |    TABLE SCAN          |t2  |6        |37  |
|6 |  MATERIAL              |    |6        |44  |
|7 |   TABLE SCAN           |t3  |6        |37  |
|8 | MATERIAL               |    |6        |44  |
|9 |  TABLE SCAN            |t4  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);
Query Plan
==============================================
|ID|OPERATOR            |NAME |EST. ROWS|COST|
----------------------------------------------
|0 |INSERT              |     |1        |199 |
|1 | SUBPLAN SCAN       |VIEW1|1        |199 |
|2 |  NESTED-LOOP JOIN  |     |1        |199 |
|3 |   TABLE GET        |t4   |1        |53  |
|4 |   NESTED-LOOP JOIN |     |2        |146 |
|5 |    TABLE GET       |t3   |1        |53  |
|6 |    NESTED-LOOP JOIN|     |3        |92  |
|7 |     TABLE GET      |t2   |1        |53  |
|8 |     TABLE SCAN     |t1   |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t7_temp (select * from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT                    |     |1        |205 |
|1 | SUBPLAN SCAN             |VIEW1|1        |205 |
|2 |  NESTED-LOOP OUTER JOIN  |     |1        |205 |
|3 |   NESTED-LOOP OUTER JOIN |     |2        |156 |
|4 |    NESTED-LOOP OUTER JOIN|     |3        |102 |
|5 |     TABLE SCAN           |t1   |6        |37  |
|6 |     MATERIAL             |     |6        |44  |
|7 |      TABLE SCAN          |t2   |6        |37  |
|8 |    MATERIAL              |     |6        |44  |
|9 |     TABLE SCAN           |t3   |6        |37  |
|10|   MATERIAL               |     |6        |44  |
|11|    TABLE SCAN            |t4   |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  11 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |UPDATE               |    |6        |242 |
|1 | SUBPLAN FILTER      |    |6        |236 |
|2 |  TABLE SCAN         |t1  |6        |37  |
|3 |  LIMIT              |    |1        |198 |
|4 |   NESTED-LOOP JOIN  |    |1        |198 |
|5 |    TABLE GET        |t4  |1        |52  |
|6 |    NESTED-LOOP JOIN |    |2        |145 |
|7 |     TABLE GET       |t3  |1        |52  |
|8 |     NESTED-LOOP JOIN|    |3        |92  |
|9 |      TABLE GET      |t2  |1        |52  |
|10|      TABLE SCAN     |t1  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                     |    |6        |228 |
|1 | SUBPLAN FILTER            |    |6        |222 |
|2 |  TABLE SCAN               |t1  |6        |37  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |DELETE               |    |1        |237 |
|1 | SUBPLAN FILTER      |    |1        |236 |
|2 |  TABLE SCAN         |t1  |1        |38  |
|3 |  LIMIT              |    |1        |198 |
|4 |   NESTED-LOOP JOIN  |    |1        |198 |
|5 |    TABLE GET        |t4  |1        |52  |
|6 |    NESTED-LOOP JOIN |    |2        |145 |
|7 |     TABLE GET       |t3  |1        |52  |
|8 |     NESTED-LOOP JOIN|    |3        |92  |
|9 |      TABLE GET      |t2  |1        |52  |
|10|      TABLE SCAN     |t1  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                     |    |1        |223 |
|1 | SUBPLAN FILTER            |    |1        |222 |
|2 |  TABLE SCAN               |t1  |1        |38  |
|3 |  LIMIT                    |    |1        |185 |
|4 |   NESTED-LOOP OUTER JOIN  |    |1        |184 |
|5 |    NESTED-LOOP OUTER JOIN |    |2        |142 |
|6 |     NESTED-LOOP OUTER JOIN|    |3        |94  |
|7 |      TABLE SCAN           |t1  |6        |37  |
|8 |      MATERIAL             |    |6        |38  |
|9 |       TABLE SCAN          |t2  |6        |37  |
|10|     MATERIAL              |    |6        |38  |
|11|      TABLE SCAN           |t3  |6        |37  |
|12|    MATERIAL               |    |6        |38  |
|13|     TABLE SCAN            |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t4.c1 = 0]), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter([t3.c1 = 0]), 
      conds([t1.c1 != t3.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter([t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 != t2.c1 left join t3 on t1.c1 != t3.c1 left join t4 on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN |    |0        |484 |
|1 | NESTED-LOOP OUTER JOIN|    |54       |249 |
|2 |  TABLE SCAN           |t1  |6        |37  |
|3 |  MATERIAL             |    |18       |142 |
|4 |   NESTED-LOOP JOIN    |    |18       |102 |
|5 |    TABLE SCAN         |t4  |6        |37  |
|6 |    MATERIAL           |    |6        |44  |
|7 |     TABLE SCAN        |t3  |6        |37  |
|8 | MATERIAL              |    |6        |44  |
|9 |  TABLE SCAN           |t2  |6        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |    |0        |484 |
|1 | NESTED-LOOP OUTER JOIN  |    |54       |249 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  MATERIAL               |    |18       |142 |
|4 |   NESTED-LOOP OUTER JOIN|    |18       |102 |
|5 |    TABLE SCAN           |t3  |6        |37  |
|6 |    MATERIAL             |    |6        |44  |
|7 |     TABLE SCAN          |t4  |6        |37  |
|8 | MATERIAL                |    |6        |44  |
|9 |  TABLE SCAN             |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |0        |484 |
|1 | SUBPLAN SCAN            |VIEW1|0        |484 |
|2 |  NESTED-LOOP OUTER JOIN |     |0        |484 |
|3 |   NESTED-LOOP OUTER JOIN|     |54       |249 |
|4 |    TABLE SCAN           |t1   |6        |37  |
|5 |    MATERIAL             |     |18       |142 |
|6 |     NESTED-LOOP JOIN    |     |18       |102 |
|7 |      TABLE SCAN         |t4   |6        |37  |
|8 |      MATERIAL           |     |6        |44  |
|9 |       TABLE SCAN        |t3   |6        |37  |
|10|   MATERIAL              |     |6        |44  |
|11|    TABLE SCAN           |t2   |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |INSERT                     |     |0        |484 |
|1 | SUBPLAN SCAN              |VIEW1|0        |484 |
|2 |  NESTED-LOOP OUTER JOIN   |     |0        |484 |
|3 |   NESTED-LOOP OUTER JOIN  |     |54       |249 |
|4 |    TABLE SCAN             |t1   |6        |37  |
|5 |    MATERIAL               |     |18       |142 |
|6 |     NESTED-LOOP OUTER JOIN|     |18       |102 |
|7 |      TABLE SCAN           |t3   |6        |37  |
|8 |      MATERIAL             |     |6        |44  |
|9 |       TABLE SCAN          |t4   |6        |37  |
|10|   MATERIAL                |     |6        |44  |
|11|    TABLE SCAN             |t2   |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |6        |452 |
|1 | SUBPLAN FILTER           |    |6        |446 |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  LIMIT                   |    |0        |408 |
|4 |   NESTED-LOOP OUTER JOIN |    |0        |408 |
|5 |    NESTED-LOOP OUTER JOIN|    |54       |197 |
|6 |     TABLE SCAN           |t1  |6        |37  |
|7 |     MATERIAL             |    |18       |101 |
|8 |      NESTED-LOOP JOIN    |    |18       |94  |
|9 |       TABLE SCAN         |t4  |6        |37  |
|10|       MATERIAL           |    |6        |38  |
|11|        TABLE SCAN        |t3  |6        |37  |
|12|    MATERIAL              |    |6        |38  |
|13|     TABLE SCAN           |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |UPDATE                      |    |6        |452 |
|1 | SUBPLAN FILTER             |    |6        |446 |
|2 |  TABLE SCAN                |t1  |6        |37  |
|3 |  LIMIT                     |    |0        |408 |
|4 |   NESTED-LOOP OUTER JOIN   |    |0        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |447 |
|1 | SUBPLAN FILTER           |    |1        |446 |
|2 |  TABLE SCAN              |t1  |1        |38  |
|3 |  LIMIT                   |    |0        |408 |
|4 |   NESTED-LOOP OUTER JOIN |    |0        |408 |
|5 |    NESTED-LOOP OUTER JOIN|    |54       |197 |
|6 |     TABLE SCAN           |t1  |6        |37  |
|7 |     MATERIAL             |    |18       |101 |
|8 |      NESTED-LOOP JOIN    |    |18       |94  |
|9 |       TABLE SCAN         |t4  |6        |37  |
|10|       MATERIAL           |    |6        |38  |
|11|        TABLE SCAN        |t3  |6        |37  |
|12|    MATERIAL              |    |6        |38  |
|13|     TABLE SCAN           |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |DELETE                      |    |1        |447 |
|1 | SUBPLAN FILTER             |    |1        |446 |
|2 |  TABLE SCAN                |t1  |1        |38  |
|3 |  LIMIT                     |    |0        |408 |
|4 |   NESTED-LOOP OUTER JOIN   |    |0        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |648      |764 |
|1 | NESTED-LOOP JOIN CARTESIAN|    |108      |228 |
|2 |  NESTED-LOOP OUTER JOIN   |    |18       |102 |
|3 |   TABLE SCAN              |t1  |6        |37  |
|4 |   MATERIAL                |    |6        |44  |
|5 |    TABLE SCAN             |t2  |6        |37  |
|6 |  MATERIAL                 |    |6        |44  |
|7 |   TABLE SCAN              |t3  |6        |37  |
|8 | MATERIAL                  |    |6        |44  |
|9 |  TABLE SCAN               |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |    |0        |484 |
|1 | NESTED-LOOP OUTER JOIN  |    |54       |249 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  MATERIAL               |    |18       |142 |
|4 |   NESTED-LOOP OUTER JOIN|    |18       |102 |
|5 |    TABLE SCAN           |t3  |6        |37  |
|6 |    MATERIAL             |    |6        |44  |
|7 |     TABLE SCAN          |t4  |6        |37  |
|8 | MATERIAL                |    |6        |44  |
|9 |  TABLE SCAN             |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |648      |943 |
|1 | SUBPLAN SCAN                |VIEW1|648      |853 |
|2 |  NESTED-LOOP JOIN CARTESIAN |     |648      |764 |
|3 |   NESTED-LOOP JOIN CARTESIAN|     |108      |228 |
|4 |    NESTED-LOOP OUTER JOIN   |     |18       |102 |
|5 |     TABLE SCAN              |t1   |6        |37  |
|6 |     MATERIAL                |     |6        |44  |
|7 |      TABLE SCAN             |t2   |6        |37  |
|8 |    MATERIAL                 |     |6        |44  |
|9 |     TABLE SCAN              |t3   |6        |37  |
|10|   MATERIAL                  |     |6        |44  |
|11|    TABLE SCAN               |t4   |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  11 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);
Query Plan
=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |INSERT                     |     |0        |484 |
|1 | SUBPLAN SCAN              |VIEW1|0        |484 |
|2 |  NESTED-LOOP OUTER JOIN   |     |0        |484 |
|3 |   NESTED-LOOP OUTER JOIN  |     |54       |249 |
|4 |    TABLE SCAN             |t1   |6        |37  |
|5 |    MATERIAL               |     |18       |142 |
|6 |     NESTED-LOOP OUTER JOIN|     |18       |102 |
|7 |      TABLE SCAN           |t3   |6        |37  |
|8 |      MATERIAL             |     |6        |44  |
|9 |       TABLE SCAN          |t4   |6        |37  |
|10|   MATERIAL                |     |6        |44  |
|11|    TABLE SCAN             |t2   |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |6        |194 |
|1 | SUBPLAN FILTER               |    |6        |188 |
|2 |  TABLE SCAN                  |t1  |6        |37  |
|3 |  LIMIT                       |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |112 |
|6 |     NESTED-LOOP OUTER JOIN   |    |1        |74  |
|7 |      TABLE SCAN              |t1  |1        |36  |
|8 |      MATERIAL                |    |6        |38  |
|9 |       TABLE SCAN             |t2  |6        |37  |
|10|     MATERIAL                 |    |6        |38  |
|11|      TABLE SCAN              |t3  |6        |37  |
|12|    MATERIAL                  |    |6        |38  |
|13|     TABLE SCAN               |t4  |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |UPDATE                      |    |6        |452 |
|1 | SUBPLAN FILTER             |    |6        |446 |
|2 |  TABLE SCAN                |t1  |6        |37  |
|3 |  LIMIT                     |    |0        |408 |
|4 |   NESTED-LOOP OUTER JOIN   |    |0        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |189 |
|1 | SUBPLAN FILTER               |    |1        |188 |
|2 |  TABLE SCAN                  |t1  |1        |38  |
|3 |  LIMIT                       |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |112 |
|6 |     NESTED-LOOP OUTER JOIN   |    |1        |74  |
|7 |      TABLE SCAN              |t1  |1        |36  |
|8 |      MATERIAL                |    |6        |38  |
|9 |       TABLE SCAN             |t2  |6        |37  |
|10|     MATERIAL                 |    |6        |38  |
|11|      TABLE SCAN              |t3  |6        |37  |
|12|    MATERIAL                  |    |6        |38  |
|13|     TABLE SCAN               |t4  |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |DELETE                      |    |1        |447 |
|1 | SUBPLAN FILTER             |    |1        |446 |
|2 |  TABLE SCAN                |t1  |1        |38  |
|3 |  LIMIT                     |    |0        |408 |
|4 |   NESTED-LOOP OUTER JOIN   |    |0        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |648      |764 |
|1 | NESTED-LOOP JOIN CARTESIAN|    |108      |228 |
|2 |  NESTED-LOOP OUTER JOIN   |    |18       |102 |
|3 |   TABLE SCAN              |t1  |6        |37  |
|4 |   MATERIAL                |    |6        |44  |
|5 |    TABLE SCAN             |t2  |6        |37  |
|6 |  MATERIAL                 |    |6        |44  |
|7 |   TABLE SCAN              |t3  |6        |37  |
|8 | MATERIAL                  |    |6        |44  |
|9 |  TABLE SCAN               |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |    |0        |484 |
|1 | NESTED-LOOP OUTER JOIN  |    |54       |249 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  MATERIAL               |    |18       |142 |
|4 |   NESTED-LOOP OUTER JOIN|    |18       |102 |
|5 |    TABLE SCAN           |t3  |6        |37  |
|6 |    MATERIAL             |    |6        |44  |
|7 |     TABLE SCAN          |t4  |6        |37  |
|8 | MATERIAL                |    |6        |44  |
|9 |  TABLE SCAN             |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t3.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |648      |943 |
|1 | SUBPLAN SCAN                |VIEW1|648      |853 |
|2 |  NESTED-LOOP JOIN CARTESIAN |     |648      |764 |
|3 |   NESTED-LOOP JOIN CARTESIAN|     |108      |228 |
|4 |    NESTED-LOOP OUTER JOIN   |     |18       |102 |
|5 |     TABLE SCAN              |t1   |6        |37  |
|6 |     MATERIAL                |     |6        |44  |
|7 |      TABLE SCAN             |t2   |6        |37  |
|8 |    MATERIAL                 |     |6        |44  |
|9 |     TABLE SCAN              |t3   |6        |37  |
|10|   MATERIAL                  |     |6        |44  |
|11|    TABLE SCAN               |t4   |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  11 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);
Query Plan
=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |INSERT                     |     |0        |484 |
|1 | SUBPLAN SCAN              |VIEW1|0        |484 |
|2 |  NESTED-LOOP OUTER JOIN   |     |0        |484 |
|3 |   NESTED-LOOP OUTER JOIN  |     |54       |249 |
|4 |    TABLE SCAN             |t1   |6        |37  |
|5 |    MATERIAL               |     |18       |142 |
|6 |     NESTED-LOOP OUTER JOIN|     |18       |102 |
|7 |      TABLE SCAN           |t3   |6        |37  |
|8 |      MATERIAL             |     |6        |44  |
|9 |       TABLE SCAN          |t4   |6        |37  |
|10|   MATERIAL                |     |6        |44  |
|11|    TABLE SCAN             |t2   |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t3.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |6        |194 |
|1 | SUBPLAN FILTER               |    |6        |188 |
|2 |  TABLE SCAN                  |t1  |6        |37  |
|3 |  LIMIT                       |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |112 |
|6 |     NESTED-LOOP OUTER JOIN   |    |1        |74  |
|7 |      TABLE SCAN              |t1  |1        |36  |
|8 |      MATERIAL                |    |6        |38  |
|9 |       TABLE SCAN             |t2  |6        |37  |
|10|     MATERIAL                 |    |6        |38  |
|11|      TABLE SCAN              |t3  |6        |37  |
|12|    MATERIAL                  |    |6        |38  |
|13|     TABLE SCAN               |t4  |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |UPDATE                      |    |6        |452 |
|1 | SUBPLAN FILTER             |    |6        |446 |
|2 |  TABLE SCAN                |t1  |6        |37  |
|3 |  LIMIT                     |    |0        |408 |
|4 |   NESTED-LOOP OUTER JOIN   |    |0        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t3.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |189 |
|1 | SUBPLAN FILTER               |    |1        |188 |
|2 |  TABLE SCAN                  |t1  |1        |38  |
|3 |  LIMIT                       |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |112 |
|6 |     NESTED-LOOP OUTER JOIN   |    |1        |74  |
|7 |      TABLE SCAN              |t1  |1        |36  |
|8 |      MATERIAL                |    |6        |38  |
|9 |       TABLE SCAN             |t2  |6        |37  |
|10|     MATERIAL                 |    |6        |38  |
|11|      TABLE SCAN              |t3  |6        |37  |
|12|    MATERIAL                  |    |6        |38  |
|13|     TABLE SCAN               |t4  |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |DELETE                      |    |1        |447 |
|1 | SUBPLAN FILTER             |    |1        |446 |
|2 |  TABLE SCAN                |t1  |1        |38  |
|3 |  LIMIT                     |    |0        |408 |
|4 |   NESTED-LOOP OUTER JOIN   |    |0        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t3.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |1        |174 |
|1 | NESTED-LOOP JOIN     |    |2        |125 |
|2 |  NESTED-LOOP JOIN    |    |1        |105 |
|3 |   TABLE GET          |t3  |1        |53  |
|4 |   TABLE GET          |t4  |1        |53  |
|5 |  TABLE SCAN          |t1  |6        |37  |
|6 | MATERIAL             |    |6        |44  |
|7 |  TABLE SCAN          |t2  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  2 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |    |1        |484 |
|1 | NESTED-LOOP OUTER JOIN  |    |54       |249 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  MATERIAL               |    |18       |142 |
|4 |   NESTED-LOOP OUTER JOIN|    |18       |102 |
|5 |    TABLE SCAN           |t3  |6        |37  |
|6 |    MATERIAL             |    |6        |44  |
|7 |     TABLE SCAN          |t4  |6        |37  |
|8 | MATERIAL                |    |6        |44  |
|9 |  TABLE SCAN             |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t3.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |1        |174 |
|1 | SUBPLAN SCAN           |VIEW1|1        |174 |
|2 |  NESTED-LOOP OUTER JOIN|     |1        |174 |
|3 |   NESTED-LOOP JOIN     |     |2        |125 |
|4 |    NESTED-LOOP JOIN    |     |1        |105 |
|5 |     TABLE GET          |t3   |1        |53  |
|6 |     TABLE GET          |t4   |1        |53  |
|7 |    TABLE SCAN          |t1   |6        |37  |
|8 |   MATERIAL             |     |6        |44  |
|9 |    TABLE SCAN          |t2   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);
Query Plan
=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |INSERT                     |     |1        |484 |
|1 | SUBPLAN SCAN              |VIEW1|1        |484 |
|2 |  NESTED-LOOP OUTER JOIN   |     |1        |484 |
|3 |   NESTED-LOOP OUTER JOIN  |     |54       |249 |
|4 |    TABLE SCAN             |t1   |6        |37  |
|5 |    MATERIAL               |     |18       |142 |
|6 |     NESTED-LOOP OUTER JOIN|     |18       |102 |
|7 |      TABLE SCAN           |t3   |6        |37  |
|8 |      MATERIAL             |     |6        |44  |
|9 |       TABLE SCAN          |t4   |6        |37  |
|10|   MATERIAL                |     |6        |44  |
|11|    TABLE SCAN             |t2   |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t3.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |211 |
|1 | SUBPLAN FILTER          |    |6        |205 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |167 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |167 |
|5 |    NESTED-LOOP JOIN     |    |2        |125 |
|6 |     NESTED-LOOP JOIN    |    |1        |105 |
|7 |      TABLE GET          |t3  |1        |52  |
|8 |      TABLE GET          |t4  |1        |52  |
|9 |     TABLE SCAN          |t1  |6        |37  |
|10|    MATERIAL             |    |6        |38  |
|11|     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |UPDATE                      |    |6        |452 |
|1 | SUBPLAN FILTER             |    |6        |446 |
|2 |  TABLE SCAN                |t1  |6        |37  |
|3 |  LIMIT                     |    |1        |409 |
|4 |   NESTED-LOOP OUTER JOIN   |    |1        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t3.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |206 |
|1 | SUBPLAN FILTER          |    |1        |205 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |167 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |167 |
|5 |    NESTED-LOOP JOIN     |    |2        |125 |
|6 |     NESTED-LOOP JOIN    |    |1        |105 |
|7 |      TABLE GET          |t3  |1        |52  |
|8 |      TABLE GET          |t4  |1        |52  |
|9 |     TABLE SCAN          |t1  |6        |37  |
|10|    MATERIAL             |    |6        |38  |
|11|     TABLE SCAN          |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |DELETE                      |    |1        |447 |
|1 | SUBPLAN FILTER             |    |1        |446 |
|2 |  TABLE SCAN                |t1  |1        |38  |
|3 |  LIMIT                     |    |1        |409 |
|4 |   NESTED-LOOP OUTER JOIN   |    |1        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t3.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |NESTED-LOOP JOIN       |    |0        |322 |
|1 | TABLE GET             |t2  |1        |53  |
|2 | NESTED-LOOP OUTER JOIN|    |54       |249 |
|3 |  TABLE SCAN           |t1  |6        |37  |
|4 |  MATERIAL             |    |18       |142 |
|5 |   NESTED-LOOP JOIN    |    |18       |102 |
|6 |    TABLE SCAN         |t3  |6        |37  |
|7 |    MATERIAL           |    |6        |44  |
|8 |     TABLE SCAN        |t4  |6        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t2.c1], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |    |0        |484 |
|1 | NESTED-LOOP OUTER JOIN  |    |54       |249 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  MATERIAL               |    |18       |142 |
|4 |   NESTED-LOOP OUTER JOIN|    |18       |102 |
|5 |    TABLE SCAN           |t3  |6        |37  |
|6 |    MATERIAL             |    |6        |44  |
|7 |     TABLE SCAN          |t4  |6        |37  |
|8 | MATERIAL                |    |6        |44  |
|9 |  TABLE SCAN             |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |0        |322 |
|1 | SUBPLAN SCAN            |VIEW1|0        |322 |
|2 |  NESTED-LOOP JOIN       |     |0        |322 |
|3 |   TABLE GET             |t2   |1        |53  |
|4 |   NESTED-LOOP OUTER JOIN|     |54       |249 |
|5 |    TABLE SCAN           |t1   |6        |37  |
|6 |    MATERIAL             |     |18       |142 |
|7 |     NESTED-LOOP JOIN    |     |18       |102 |
|8 |      TABLE SCAN         |t3   |6        |37  |
|9 |      MATERIAL           |     |6        |44  |
|10|       TABLE SCAN        |t4   |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t2.c1], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |INSERT                     |     |0        |484 |
|1 | SUBPLAN SCAN              |VIEW1|0        |484 |
|2 |  NESTED-LOOP OUTER JOIN   |     |0        |484 |
|3 |   NESTED-LOOP OUTER JOIN  |     |54       |249 |
|4 |    TABLE SCAN             |t1   |6        |37  |
|5 |    MATERIAL               |     |18       |142 |
|6 |     NESTED-LOOP OUTER JOIN|     |18       |102 |
|7 |      TABLE SCAN           |t3   |6        |37  |
|8 |      MATERIAL             |     |6        |44  |
|9 |       TABLE SCAN          |t4   |6        |37  |
|10|   MATERIAL                |     |6        |44  |
|11|    TABLE SCAN             |t2   |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |6        |313 |
|1 | SUBPLAN FILTER           |    |6        |307 |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  LIMIT                   |    |0        |270 |
|4 |   NESTED-LOOP JOIN       |    |0        |270 |
|5 |    TABLE GET             |t2  |1        |52  |
|6 |    NESTED-LOOP OUTER JOIN|    |54       |197 |
|7 |     TABLE SCAN           |t1  |6        |37  |
|8 |     MATERIAL             |    |18       |101 |
|9 |      NESTED-LOOP JOIN    |    |18       |94  |
|10|       TABLE SCAN         |t3  |6        |37  |
|11|       MATERIAL           |    |6        |38  |
|12|        TABLE SCAN        |t4  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), nl_params_(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t3.c1], [t4.c1]), filter(nil)
  9 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil)
  12 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |UPDATE                      |    |6        |452 |
|1 | SUBPLAN FILTER             |    |6        |446 |
|2 |  TABLE SCAN                |t1  |6        |37  |
|3 |  LIMIT                     |    |0        |408 |
|4 |   NESTED-LOOP OUTER JOIN   |    |0        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |308 |
|1 | SUBPLAN FILTER           |    |1        |307 |
|2 |  TABLE SCAN              |t1  |1        |38  |
|3 |  LIMIT                   |    |0        |270 |
|4 |   NESTED-LOOP JOIN       |    |0        |270 |
|5 |    TABLE GET             |t2  |1        |52  |
|6 |    NESTED-LOOP OUTER JOIN|    |54       |197 |
|7 |     TABLE SCAN           |t1  |6        |37  |
|8 |     MATERIAL             |    |18       |101 |
|9 |      NESTED-LOOP JOIN    |    |18       |94  |
|10|       TABLE SCAN         |t3  |6        |37  |
|11|       MATERIAL           |    |6        |38  |
|12|        TABLE SCAN        |t4  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), nl_params_(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t3.c1], [t4.c1]), filter(nil)
  9 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil)
  12 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |DELETE                      |    |1        |447 |
|1 | SUBPLAN FILTER             |    |1        |446 |
|2 |  TABLE SCAN                |t1  |1        |38  |
|3 |  LIMIT                     |    |0        |408 |
|4 |   NESTED-LOOP OUTER JOIN   |    |0        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN  |    |1296     |1286|
|1 | NESTED-LOOP JOIN CARTESIAN |    |216      |316 |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |36       |108 |
|3 |   TABLE SCAN               |t2  |6        |37  |
|4 |   MATERIAL                 |    |6        |44  |
|5 |    TABLE SCAN              |t3  |6        |37  |
|6 |  MATERIAL                  |    |6        |44  |
|7 |   TABLE SCAN               |t4  |6        |37  |
|8 | MATERIAL                   |    |6        |40  |
|9 |  TABLE SCAN                |t1  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |    |0        |484 |
|1 | NESTED-LOOP OUTER JOIN  |    |54       |249 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  MATERIAL               |    |18       |142 |
|4 |   NESTED-LOOP OUTER JOIN|    |18       |102 |
|5 |    TABLE SCAN           |t3  |6        |37  |
|6 |    MATERIAL             |    |6        |44  |
|7 |     TABLE SCAN          |t4  |6        |37  |
|8 | MATERIAL                |    |6        |44  |
|9 |  TABLE SCAN             |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t2.c1 = 0], [t4.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);
Query Plan
========================================================
|ID|OPERATOR                      |NAME |EST. ROWS|COST|
--------------------------------------------------------
|0 |INSERT                        |     |1296     |1644|
|1 | SUBPLAN SCAN                 |VIEW1|1296     |1465|
|2 |  NESTED-LOOP JOIN CARTESIAN  |     |1296     |1286|
|3 |   NESTED-LOOP JOIN CARTESIAN |     |216      |316 |
|4 |    NESTED-LOOP JOIN CARTESIAN|     |36       |108 |
|5 |     TABLE SCAN               |t2   |6        |37  |
|6 |     MATERIAL                 |     |6        |44  |
|7 |      TABLE SCAN              |t3   |6        |37  |
|8 |    MATERIAL                  |     |6        |44  |
|9 |     TABLE SCAN               |t4   |6        |37  |
|10|   MATERIAL                   |     |6        |40  |
|11|    TABLE SCAN                |t1   |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);
Query Plan
=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |INSERT                     |     |0        |484 |
|1 | SUBPLAN SCAN              |VIEW1|0        |484 |
|2 |  NESTED-LOOP OUTER JOIN   |     |0        |484 |
|3 |   NESTED-LOOP OUTER JOIN  |     |54       |249 |
|4 |    TABLE SCAN             |t1   |6        |37  |
|5 |    MATERIAL               |     |18       |142 |
|6 |     NESTED-LOOP OUTER JOIN|     |18       |102 |
|7 |      TABLE SCAN           |t3   |6        |37  |
|8 |      MATERIAL             |     |6        |44  |
|9 |       TABLE SCAN          |t4   |6        |37  |
|10|   MATERIAL                |     |6        |44  |
|11|    TABLE SCAN             |t2   |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t2.c1 = 0], [t4.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |UPDATE                         |    |6        |194 |
|1 | SUBPLAN FILTER                |    |6        |188 |
|2 |  TABLE SCAN                   |t1  |6        |37  |
|3 |  LIMIT                        |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |112 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|7 |      TABLE SCAN               |t1  |1        |36  |
|8 |      MATERIAL                 |    |6        |38  |
|9 |       TABLE SCAN              |t2  |6        |37  |
|10|     MATERIAL                  |    |6        |38  |
|11|      TABLE SCAN               |t3  |6        |37  |
|12|    MATERIAL                   |    |6        |38  |
|13|     TABLE SCAN                |t4  |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |UPDATE                      |    |6        |452 |
|1 | SUBPLAN FILTER             |    |6        |446 |
|2 |  TABLE SCAN                |t1  |6        |37  |
|3 |  LIMIT                     |    |0        |408 |
|4 |   NESTED-LOOP OUTER JOIN   |    |0        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t2.c1 = 0], [t4.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |DELETE                         |    |1        |189 |
|1 | SUBPLAN FILTER                |    |1        |188 |
|2 |  TABLE SCAN                   |t1  |1        |38  |
|3 |  LIMIT                        |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |112 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|7 |      TABLE SCAN               |t1  |1        |36  |
|8 |      MATERIAL                 |    |6        |38  |
|9 |       TABLE SCAN              |t2  |6        |37  |
|10|     MATERIAL                  |    |6        |38  |
|11|      TABLE SCAN               |t3  |6        |37  |
|12|    MATERIAL                   |    |6        |38  |
|13|     TABLE SCAN                |t4  |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |DELETE                      |    |1        |447 |
|1 | SUBPLAN FILTER             |    |1        |446 |
|2 |  TABLE SCAN                |t1  |1        |38  |
|3 |  LIMIT                     |    |0        |408 |
|4 |   NESTED-LOOP OUTER JOIN   |    |0        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t2.c1 = 0], [t4.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN  |    |1296     |1286|
|1 | NESTED-LOOP JOIN CARTESIAN |    |216      |316 |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |36       |108 |
|3 |   TABLE SCAN               |t2  |6        |37  |
|4 |   MATERIAL                 |    |6        |44  |
|5 |    TABLE SCAN              |t3  |6        |37  |
|6 |  MATERIAL                  |    |6        |44  |
|7 |   TABLE SCAN               |t4  |6        |37  |
|8 | MATERIAL                   |    |6        |40  |
|9 |  TABLE SCAN                |t1  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |    |0        |484 |
|1 | NESTED-LOOP OUTER JOIN  |    |54       |249 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  MATERIAL               |    |18       |142 |
|4 |   NESTED-LOOP OUTER JOIN|    |18       |102 |
|5 |    TABLE SCAN           |t3  |6        |37  |
|6 |    MATERIAL             |    |6        |44  |
|7 |     TABLE SCAN          |t4  |6        |37  |
|8 | MATERIAL                |    |6        |44  |
|9 |  TABLE SCAN             |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0], [t3.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);
Query Plan
========================================================
|ID|OPERATOR                      |NAME |EST. ROWS|COST|
--------------------------------------------------------
|0 |INSERT                        |     |1296     |1644|
|1 | SUBPLAN SCAN                 |VIEW1|1296     |1465|
|2 |  NESTED-LOOP JOIN CARTESIAN  |     |1296     |1286|
|3 |   NESTED-LOOP JOIN CARTESIAN |     |216      |316 |
|4 |    NESTED-LOOP JOIN CARTESIAN|     |36       |108 |
|5 |     TABLE SCAN               |t2   |6        |37  |
|6 |     MATERIAL                 |     |6        |44  |
|7 |      TABLE SCAN              |t3   |6        |37  |
|8 |    MATERIAL                  |     |6        |44  |
|9 |     TABLE SCAN               |t4   |6        |37  |
|10|   MATERIAL                   |     |6        |40  |
|11|    TABLE SCAN                |t1   |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);
Query Plan
=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |INSERT                     |     |0        |484 |
|1 | SUBPLAN SCAN              |VIEW1|0        |484 |
|2 |  NESTED-LOOP OUTER JOIN   |     |0        |484 |
|3 |   NESTED-LOOP OUTER JOIN  |     |54       |249 |
|4 |    TABLE SCAN             |t1   |6        |37  |
|5 |    MATERIAL               |     |18       |142 |
|6 |     NESTED-LOOP OUTER JOIN|     |18       |102 |
|7 |      TABLE SCAN           |t3   |6        |37  |
|8 |      MATERIAL             |     |6        |44  |
|9 |       TABLE SCAN          |t4   |6        |37  |
|10|   MATERIAL                |     |6        |44  |
|11|    TABLE SCAN             |t2   |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0], [t3.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |UPDATE                         |    |6        |194 |
|1 | SUBPLAN FILTER                |    |6        |188 |
|2 |  TABLE SCAN                   |t1  |6        |37  |
|3 |  LIMIT                        |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |112 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|7 |      TABLE SCAN               |t1  |1        |36  |
|8 |      MATERIAL                 |    |6        |38  |
|9 |       TABLE SCAN              |t2  |6        |37  |
|10|     MATERIAL                  |    |6        |38  |
|11|      TABLE SCAN               |t3  |6        |37  |
|12|    MATERIAL                   |    |6        |38  |
|13|     TABLE SCAN                |t4  |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |UPDATE                      |    |6        |452 |
|1 | SUBPLAN FILTER             |    |6        |446 |
|2 |  TABLE SCAN                |t1  |6        |37  |
|3 |  LIMIT                     |    |0        |408 |
|4 |   NESTED-LOOP OUTER JOIN   |    |0        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0], [t3.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |DELETE                         |    |1        |189 |
|1 | SUBPLAN FILTER                |    |1        |188 |
|2 |  TABLE SCAN                   |t1  |1        |38  |
|3 |  LIMIT                        |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |112 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|7 |      TABLE SCAN               |t1  |1        |36  |
|8 |      MATERIAL                 |    |6        |38  |
|9 |       TABLE SCAN              |t2  |6        |37  |
|10|     MATERIAL                  |    |6        |38  |
|11|      TABLE SCAN               |t3  |6        |37  |
|12|    MATERIAL                   |    |6        |38  |
|13|     TABLE SCAN                |t4  |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |DELETE                      |    |1        |447 |
|1 | SUBPLAN FILTER             |    |1        |446 |
|2 |  TABLE SCAN                |t1  |1        |38  |
|3 |  LIMIT                     |    |0        |408 |
|4 |   NESTED-LOOP OUTER JOIN   |    |0        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0], [t3.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
Query Plan
===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |NESTED-LOOP JOIN  |    |1        |178 |
|1 | TABLE GET        |t2  |1        |53  |
|2 | NESTED-LOOP JOIN |    |2        |125 |
|3 |  NESTED-LOOP JOIN|    |1        |105 |
|4 |   TABLE GET      |t3  |1        |53  |
|5 |   TABLE GET      |t4  |1        |53  |
|6 |  TABLE SCAN      |t1  |6        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |    |1        |484 |
|1 | NESTED-LOOP OUTER JOIN  |    |54       |249 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  MATERIAL               |    |18       |142 |
|4 |   NESTED-LOOP OUTER JOIN|    |18       |102 |
|5 |    TABLE SCAN           |t3  |6        |37  |
|6 |    MATERIAL             |    |6        |44  |
|7 |     TABLE SCAN          |t4  |6        |37  |
|8 | MATERIAL                |    |6        |44  |
|9 |  TABLE SCAN             |t2  |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t2.c1 = 0], [t3.c1 = 0], [t4.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);
Query Plan
==============================================
|ID|OPERATOR            |NAME |EST. ROWS|COST|
----------------------------------------------
|0 |INSERT              |     |1        |178 |
|1 | SUBPLAN SCAN       |VIEW1|1        |178 |
|2 |  NESTED-LOOP JOIN  |     |1        |178 |
|3 |   TABLE GET        |t2   |1        |53  |
|4 |   NESTED-LOOP JOIN |     |2        |125 |
|5 |    NESTED-LOOP JOIN|     |1        |105 |
|6 |     TABLE GET      |t3   |1        |53  |
|7 |     TABLE GET      |t4   |1        |53  |
|8 |    TABLE SCAN      |t1   |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);
Query Plan
=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |INSERT                     |     |1        |484 |
|1 | SUBPLAN SCAN              |VIEW1|1        |484 |
|2 |  NESTED-LOOP OUTER JOIN   |     |1        |484 |
|3 |   NESTED-LOOP OUTER JOIN  |     |54       |249 |
|4 |    TABLE SCAN             |t1   |6        |37  |
|5 |    MATERIAL               |     |18       |142 |
|6 |     NESTED-LOOP OUTER JOIN|     |18       |102 |
|7 |      TABLE SCAN           |t3   |6        |37  |
|8 |      MATERIAL             |     |6        |44  |
|9 |       TABLE SCAN          |t4   |6        |37  |
|10|   MATERIAL                |     |6        |44  |
|11|    TABLE SCAN             |t2   |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t2.c1 = 0], [t3.c1 = 0], [t4.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |UPDATE               |    |6        |221 |
|1 | SUBPLAN FILTER      |    |6        |215 |
|2 |  TABLE SCAN         |t1  |6        |37  |
|3 |  LIMIT              |    |1        |178 |
|4 |   NESTED-LOOP JOIN  |    |1        |177 |
|5 |    TABLE GET        |t2  |1        |52  |
|6 |    NESTED-LOOP JOIN |    |2        |125 |
|7 |     NESTED-LOOP JOIN|    |1        |105 |
|8 |      TABLE GET      |t3  |1        |52  |
|9 |      TABLE GET      |t4  |1        |52  |
|10|     TABLE SCAN      |t1  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  7 - output([t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |UPDATE                      |    |6        |452 |
|1 | SUBPLAN FILTER             |    |6        |446 |
|2 |  TABLE SCAN                |t1  |6        |37  |
|3 |  LIMIT                     |    |1        |409 |
|4 |   NESTED-LOOP OUTER JOIN   |    |1        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 = 0], [t3.c1 = 0], [t4.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |DELETE               |    |1        |216 |
|1 | SUBPLAN FILTER      |    |1        |215 |
|2 |  TABLE SCAN         |t1  |1        |38  |
|3 |  LIMIT              |    |1        |178 |
|4 |   NESTED-LOOP JOIN  |    |1        |177 |
|5 |    TABLE GET        |t2  |1        |52  |
|6 |    NESTED-LOOP JOIN |    |2        |125 |
|7 |     NESTED-LOOP JOIN|    |1        |105 |
|8 |      TABLE GET      |t3  |1        |52  |
|9 |      TABLE GET      |t4  |1        |52  |
|10|     TABLE SCAN      |t1  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  7 - output([t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |DELETE                      |    |1        |447 |
|1 | SUBPLAN FILTER             |    |1        |446 |
|2 |  TABLE SCAN                |t1  |1        |38  |
|3 |  LIMIT                     |    |1        |409 |
|4 |   NESTED-LOOP OUTER JOIN   |    |1        |408 |
|5 |    NESTED-LOOP OUTER JOIN  |    |54       |197 |
|6 |     TABLE SCAN             |t1  |6        |37  |
|7 |     MATERIAL               |    |18       |101 |
|8 |      NESTED-LOOP OUTER JOIN|    |18       |94  |
|9 |       TABLE SCAN           |t3  |6        |37  |
|10|       MATERIAL             |    |6        |38  |
|11|        TABLE SCAN          |t4  |6        |37  |
|12|    MATERIAL                |    |6        |38  |
|13|     TABLE SCAN             |t2  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 = 0], [t3.c1 = 0], [t4.c1 = 0]), 
      conds([t1.c1 != t2.c1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 != t4.c1]), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      conds([t4.c1 != t3.c1]), nl_params_(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 != t2.c1) left join (t3 left join t4 on t4.c1 != t3.c1) on t1.c1 != t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

## case full outer join el
EXPLAIN select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |MERGE FULL OUTER JOIN|    |10       |164 |
|1 | MERGE OUTER JOIN    |    |6        |122 |
|2 |  TABLE SCAN         |t1  |6        |37  |
|3 |  MERGE JOIN         |    |6        |80  |
|4 |   TABLE SCAN        |t4  |6        |37  |
|5 |   TABLE SCAN        |t3  |6        |37  |
|6 | TABLE SCAN          |t2  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |MERGE FULL OUTER JOIN|    |10       |181 |
|1 | MERGE OUTER JOIN    |    |6        |139 |
|2 |  TABLE SCAN         |t1  |6        |37  |
|3 |  SORT               |    |6        |97  |
|4 |   MERGE OUTER JOIN  |    |6        |80  |
|5 |    TABLE SCAN       |t3  |6        |37  |
|6 |    TABLE SCAN       |t4  |6        |37  |
|7 | TABLE SCAN          |t2  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |10       |167 |
|1 | SUBPLAN SCAN          |VIEW1|10       |165 |
|2 |  MERGE FULL OUTER JOIN|     |10       |164 |
|3 |   MERGE OUTER JOIN    |     |6        |122 |
|4 |    TABLE SCAN         |t1   |6        |37  |
|5 |    MERGE JOIN         |     |6        |80  |
|6 |     TABLE SCAN        |t4   |6        |37  |
|7 |     TABLE SCAN        |t3   |6        |37  |
|8 |   TABLE SCAN          |t2   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |10       |184 |
|1 | SUBPLAN SCAN          |VIEW1|10       |183 |
|2 |  MERGE FULL OUTER JOIN|     |10       |181 |
|3 |   MERGE OUTER JOIN    |     |6        |139 |
|4 |    TABLE SCAN         |t1   |6        |37  |
|5 |    SORT               |     |6        |97  |
|6 |     MERGE OUTER JOIN  |     |6        |80  |
|7 |      TABLE SCAN       |t3   |6        |37  |
|8 |      TABLE SCAN       |t4   |6        |37  |
|9 |   TABLE SCAN          |t2   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |6        |196 |
|1 | SUBPLAN FILTER         |    |6        |190 |
|2 |  TABLE SCAN            |t1  |6        |37  |
|3 |  LIMIT                 |    |1        |152 |
|4 |   MERGE FULL OUTER JOIN|    |1        |152 |
|5 |    MERGE OUTER JOIN    |    |2        |115 |
|6 |     TABLE SCAN         |t1  |4        |37  |
|7 |     MERGE JOIN         |    |4        |77  |
|8 |      TABLE SCAN        |t4  |5        |37  |
|9 |      TABLE SCAN        |t3  |5        |37  |
|10|    TABLE SCAN          |t2  |2        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |6        |204 |
|1 | SUBPLAN FILTER         |    |6        |198 |
|2 |  TABLE SCAN            |t1  |6        |37  |
|3 |  LIMIT                 |    |1        |160 |
|4 |   MERGE FULL OUTER JOIN|    |1        |160 |
|5 |    MERGE OUTER JOIN    |    |2        |123 |
|6 |     TABLE SCAN         |t1  |4        |37  |
|7 |     SORT               |    |4        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |2        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |191 |
|1 | SUBPLAN FILTER         |    |1        |190 |
|2 |  TABLE SCAN            |t1  |1        |38  |
|3 |  LIMIT                 |    |1        |152 |
|4 |   MERGE FULL OUTER JOIN|    |1        |152 |
|5 |    MERGE OUTER JOIN    |    |2        |115 |
|6 |     TABLE SCAN         |t1  |4        |37  |
|7 |     MERGE JOIN         |    |4        |77  |
|8 |      TABLE SCAN        |t4  |5        |37  |
|9 |      TABLE SCAN        |t3  |5        |37  |
|10|    TABLE SCAN          |t2  |2        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |199 |
|1 | SUBPLAN FILTER         |    |1        |198 |
|2 |  TABLE SCAN            |t1  |1        |38  |
|3 |  LIMIT                 |    |1        |160 |
|4 |   MERGE FULL OUTER JOIN|    |1        |160 |
|5 |    MERGE OUTER JOIN    |    |2        |123 |
|6 |     TABLE SCAN         |t1  |4        |37  |
|7 |     SORT               |    |4        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |2        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |216      |370 |
|1 | NESTED-LOOP JOIN CARTESIAN|    |36       |162 |
|2 |  MERGE OUTER JOIN         |    |6        |91  |
|3 |   TABLE SCAN              |t1  |6        |37  |
|4 |   TABLE GET               |t2  |1        |53  |
|5 |  MATERIAL                 |    |6        |44  |
|6 |   TABLE SCAN              |t3  |6        |37  |
|7 | MATERIAL                  |    |6        |44  |
|8 |  TABLE SCAN               |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |MERGE FULL OUTER JOIN|    |2        |181 |
|1 | MERGE OUTER JOIN    |    |6        |139 |
|2 |  TABLE SCAN         |t1  |6        |37  |
|3 |  SORT               |    |6        |97  |
|4 |   MERGE OUTER JOIN  |    |6        |80  |
|5 |    TABLE SCAN       |t3  |6        |37  |
|6 |    TABLE SCAN       |t4  |6        |37  |
|7 | TABLE SCAN          |t2  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t3.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |216      |429 |
|1 | SUBPLAN SCAN                |VIEW1|216      |399 |
|2 |  NESTED-LOOP JOIN CARTESIAN |     |216      |370 |
|3 |   NESTED-LOOP JOIN CARTESIAN|     |36       |162 |
|4 |    MERGE OUTER JOIN         |     |6        |91  |
|5 |     TABLE SCAN              |t1   |6        |37  |
|6 |     TABLE GET               |t2   |1        |53  |
|7 |    MATERIAL                 |     |6        |44  |
|8 |     TABLE SCAN              |t3   |6        |37  |
|9 |   MATERIAL                  |     |6        |44  |
|10|    TABLE SCAN               |t4   |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |2        |182 |
|1 | SUBPLAN SCAN          |VIEW1|2        |181 |
|2 |  MERGE FULL OUTER JOIN|     |2        |181 |
|3 |   MERGE OUTER JOIN    |     |6        |139 |
|4 |    TABLE SCAN         |t1   |6        |37  |
|5 |    SORT               |     |6        |97  |
|6 |     MERGE OUTER JOIN  |     |6        |80  |
|7 |      TABLE SCAN       |t3   |6        |37  |
|8 |      TABLE SCAN       |t4   |6        |37  |
|9 |   TABLE SCAN          |t2   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t3.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |6        |156 |
|1 | SUBPLAN FILTER               |    |6        |150 |
|2 |  TABLE SCAN                  |t1  |6        |37  |
|3 |  LIMIT                       |    |1        |113 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |113 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|6 |     TABLE SCAN               |t1  |1        |36  |
|7 |     MATERIAL                 |    |6        |38  |
|8 |      TABLE SCAN              |t3  |6        |37  |
|9 |    MATERIAL                  |    |6        |38  |
|10|     TABLE SCAN               |t4  |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([1]), filter(nil)
  8 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |6        |209 |
|1 | SUBPLAN FILTER         |    |6        |203 |
|2 |  TABLE SCAN            |t1  |6        |37  |
|3 |  LIMIT                 |    |1        |166 |
|4 |   MERGE FULL OUTER JOIN|    |1        |165 |
|5 |    MERGE OUTER JOIN    |    |5        |126 |
|6 |     TABLE SCAN         |t1  |6        |37  |
|7 |     SORT               |    |6        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |5        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t3.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |151 |
|1 | SUBPLAN FILTER               |    |1        |150 |
|2 |  TABLE SCAN                  |t1  |1        |38  |
|3 |  LIMIT                       |    |1        |113 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |113 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|6 |     TABLE SCAN               |t1  |1        |36  |
|7 |     MATERIAL                 |    |6        |38  |
|8 |      TABLE SCAN              |t3  |6        |37  |
|9 |    MATERIAL                  |    |6        |38  |
|10|     TABLE SCAN               |t4  |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([1]), filter(nil)
  8 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |204 |
|1 | SUBPLAN FILTER         |    |1        |203 |
|2 |  TABLE SCAN            |t1  |1        |38  |
|3 |  LIMIT                 |    |1        |166 |
|4 |   MERGE FULL OUTER JOIN|    |1        |165 |
|5 |    MERGE OUTER JOIN    |    |5        |126 |
|6 |     TABLE SCAN         |t1  |6        |37  |
|7 |     SORT               |    |6        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |5        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t3.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |216      |370 |
|1 | NESTED-LOOP JOIN CARTESIAN|    |36       |162 |
|2 |  MERGE OUTER JOIN         |    |6        |91  |
|3 |   TABLE SCAN              |t1  |6        |37  |
|4 |   TABLE GET               |t2  |1        |53  |
|5 |  MATERIAL                 |    |6        |44  |
|6 |   TABLE SCAN              |t3  |6        |37  |
|7 | MATERIAL                  |    |6        |44  |
|8 |  TABLE SCAN               |t4  |6        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |MERGE FULL OUTER JOIN|    |2        |181 |
|1 | MERGE OUTER JOIN    |    |6        |139 |
|2 |  TABLE SCAN         |t1  |6        |37  |
|3 |  SORT               |    |6        |97  |
|4 |   MERGE OUTER JOIN  |    |6        |80  |
|5 |    TABLE SCAN       |t3  |6        |37  |
|6 |    TABLE SCAN       |t4  |6        |37  |
|7 | TABLE SCAN          |t2  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t3.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |216      |429 |
|1 | SUBPLAN SCAN                |VIEW1|216      |399 |
|2 |  NESTED-LOOP JOIN CARTESIAN |     |216      |370 |
|3 |   NESTED-LOOP JOIN CARTESIAN|     |36       |162 |
|4 |    MERGE OUTER JOIN         |     |6        |91  |
|5 |     TABLE SCAN              |t1   |6        |37  |
|6 |     TABLE GET               |t2   |1        |53  |
|7 |    MATERIAL                 |     |6        |44  |
|8 |     TABLE SCAN              |t3   |6        |37  |
|9 |   MATERIAL                  |     |6        |44  |
|10|    TABLE SCAN               |t4   |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  10 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |2        |182 |
|1 | SUBPLAN SCAN          |VIEW1|2        |181 |
|2 |  MERGE FULL OUTER JOIN|     |2        |181 |
|3 |   MERGE OUTER JOIN    |     |6        |139 |
|4 |    TABLE SCAN         |t1   |6        |37  |
|5 |    SORT               |     |6        |97  |
|6 |     MERGE OUTER JOIN  |     |6        |80  |
|7 |      TABLE SCAN       |t3   |6        |37  |
|8 |      TABLE SCAN       |t4   |6        |37  |
|9 |   TABLE SCAN          |t2   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t3.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |6        |156 |
|1 | SUBPLAN FILTER               |    |6        |150 |
|2 |  TABLE SCAN                  |t1  |6        |37  |
|3 |  LIMIT                       |    |1        |113 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |113 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|6 |     TABLE SCAN               |t1  |1        |36  |
|7 |     MATERIAL                 |    |6        |38  |
|8 |      TABLE SCAN              |t3  |6        |37  |
|9 |    MATERIAL                  |    |6        |38  |
|10|     TABLE SCAN               |t4  |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([1]), filter(nil)
  8 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |6        |209 |
|1 | SUBPLAN FILTER         |    |6        |203 |
|2 |  TABLE SCAN            |t1  |6        |37  |
|3 |  LIMIT                 |    |1        |166 |
|4 |   MERGE FULL OUTER JOIN|    |1        |165 |
|5 |    MERGE OUTER JOIN    |    |5        |126 |
|6 |     TABLE SCAN         |t1  |6        |37  |
|7 |     SORT               |    |6        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |5        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t3.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |151 |
|1 | SUBPLAN FILTER               |    |1        |150 |
|2 |  TABLE SCAN                  |t1  |1        |38  |
|3 |  LIMIT                       |    |1        |113 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |113 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|6 |     TABLE SCAN               |t1  |1        |36  |
|7 |     MATERIAL                 |    |6        |38  |
|8 |      TABLE SCAN              |t3  |6        |37  |
|9 |    MATERIAL                  |    |6        |38  |
|10|     TABLE SCAN               |t4  |6        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([1]), filter(nil)
  8 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |204 |
|1 | SUBPLAN FILTER         |    |1        |203 |
|2 |  TABLE SCAN            |t1  |1        |38  |
|3 |  LIMIT                 |    |1        |166 |
|4 |   MERGE FULL OUTER JOIN|    |1        |165 |
|5 |    MERGE OUTER JOIN    |    |5        |126 |
|6 |     TABLE SCAN         |t1  |6        |37  |
|7 |     SORT               |    |6        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |5        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t3.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |0        |105 |
|1 | NESTED-LOOP JOIN CARTESIAN|    |0        |105 |
|2 |  NESTED-LOOP OUTER JOIN   |    |0        |105 |
|3 |   TABLE GET               |t1  |1        |52  |
|4 |   TABLE GET               |t2  |1        |53  |
|5 |  TABLE GET                |t3  |1        |53  |
|6 | TABLE GET                 |t4  |1        |53  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |MERGE FULL OUTER JOIN|    |1        |181 |
|1 | MERGE OUTER JOIN    |    |6        |139 |
|2 |  TABLE SCAN         |t1  |6        |37  |
|3 |  SORT               |    |6        |97  |
|4 |   MERGE OUTER JOIN  |    |6        |80  |
|5 |    TABLE SCAN       |t3  |6        |37  |
|6 |    TABLE SCAN       |t4  |6        |37  |
|7 | TABLE SCAN          |t2  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t3.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |0        |105 |
|1 | SUBPLAN SCAN                |VIEW1|0        |105 |
|2 |  NESTED-LOOP JOIN CARTESIAN |     |0        |105 |
|3 |   NESTED-LOOP JOIN CARTESIAN|     |0        |105 |
|4 |    NESTED-LOOP OUTER JOIN   |     |0        |105 |
|5 |     TABLE GET               |t1   |1        |52  |
|6 |     TABLE GET               |t2   |1        |53  |
|7 |    TABLE GET                |t3   |1        |53  |
|8 |   TABLE GET                 |t4   |1        |53  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |1        |181 |
|1 | SUBPLAN SCAN          |VIEW1|1        |181 |
|2 |  MERGE FULL OUTER JOIN|     |1        |181 |
|3 |   MERGE OUTER JOIN    |     |6        |139 |
|4 |    TABLE SCAN         |t1   |6        |37  |
|5 |    SORT               |     |6        |97  |
|6 |     MERGE OUTER JOIN  |     |6        |80  |
|7 |      TABLE SCAN       |t3   |6        |37  |
|8 |      TABLE SCAN       |t4   |6        |37  |
|9 |   TABLE SCAN          |t2   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t3.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |6        |149 |
|1 | SUBPLAN FILTER               |    |6        |143 |
|2 |  TABLE SCAN                  |t1  |6        |37  |
|3 |  LIMIT                       |    |0        |105 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |0        |105 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |0        |105 |
|6 |     NESTED-LOOP OUTER JOIN   |    |0        |105 |
|7 |      TABLE GET               |t1  |1        |52  |
|8 |      TABLE GET               |t2  |1        |52  |
|9 |     TABLE GET                |t3  |1        |52  |
|10|    TABLE GET                 |t4  |1        |52  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |6        |212 |
|1 | SUBPLAN FILTER         |    |6        |206 |
|2 |  TABLE SCAN            |t1  |6        |37  |
|3 |  LIMIT                 |    |1        |169 |
|4 |   MERGE FULL OUTER JOIN|    |1        |169 |
|5 |    MERGE OUTER JOIN    |    |6        |127 |
|6 |     TABLE SCAN         |t1  |6        |37  |
|7 |     SORT               |    |6        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t3.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |143 |
|1 | SUBPLAN FILTER               |    |1        |142 |
|2 |  TABLE SCAN                  |t1  |1        |38  |
|3 |  LIMIT                       |    |0        |105 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |0        |105 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |0        |105 |
|6 |     NESTED-LOOP OUTER JOIN   |    |0        |105 |
|7 |      TABLE GET               |t1  |1        |52  |
|8 |      TABLE GET               |t2  |1        |52  |
|9 |     TABLE GET                |t3  |1        |52  |
|10|    TABLE GET                 |t4  |1        |52  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |207 |
|1 | SUBPLAN FILTER         |    |1        |206 |
|2 |  TABLE SCAN            |t1  |1        |38  |
|3 |  LIMIT                 |    |1        |169 |
|4 |   MERGE FULL OUTER JOIN|    |1        |169 |
|5 |    MERGE OUTER JOIN    |    |6        |127 |
|6 |     TABLE SCAN         |t1  |6        |37  |
|7 |     SORT               |    |6        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t3.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |MERGE OUTER JOIN |    |0        |186 |
|1 | TABLE GET       |t2  |1        |53  |
|2 | MERGE OUTER JOIN|    |1        |133 |
|3 |  TABLE GET      |t1  |1        |52  |
|4 |  MERGE JOIN     |    |6        |80  |
|5 |   TABLE SCAN    |t3  |6        |37  |
|6 |   TABLE SCAN    |t4  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |MERGE FULL OUTER JOIN|    |1        |181 |
|1 | MERGE OUTER JOIN    |    |6        |139 |
|2 |  TABLE SCAN         |t1  |6        |37  |
|3 |  SORT               |    |6        |97  |
|4 |   MERGE OUTER JOIN  |    |6        |80  |
|5 |    TABLE SCAN       |t3  |6        |37  |
|6 |    TABLE SCAN       |t4  |6        |37  |
|7 | TABLE SCAN          |t2  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t2.c1 = 0], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |0        |186 |
|1 | SUBPLAN SCAN      |VIEW1|0        |186 |
|2 |  MERGE OUTER JOIN |     |0        |186 |
|3 |   TABLE GET       |t2   |1        |53  |
|4 |   MERGE OUTER JOIN|     |1        |133 |
|5 |    TABLE GET      |t1   |1        |52  |
|6 |    MERGE JOIN     |     |6        |80  |
|7 |     TABLE SCAN    |t3   |6        |37  |
|8 |     TABLE SCAN    |t4   |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |1        |181 |
|1 | SUBPLAN SCAN          |VIEW1|1        |181 |
|2 |  MERGE FULL OUTER JOIN|     |1        |181 |
|3 |   MERGE OUTER JOIN    |     |6        |139 |
|4 |    TABLE SCAN         |t1   |6        |37  |
|5 |    SORT               |     |6        |97  |
|6 |     MERGE OUTER JOIN  |     |6        |80  |
|7 |      TABLE SCAN       |t3   |6        |37  |
|8 |      TABLE SCAN       |t4   |6        |37  |
|9 |   TABLE SCAN          |t2   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t2.c1 = 0], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |6        |229 |
|1 | SUBPLAN FILTER     |    |6        |223 |
|2 |  TABLE SCAN        |t1  |6        |37  |
|3 |  LIMIT             |    |0        |185 |
|4 |   MERGE OUTER JOIN |    |0        |185 |
|5 |    TABLE GET       |t2  |1        |52  |
|6 |    MERGE OUTER JOIN|    |1        |133 |
|7 |     TABLE GET      |t1  |1        |52  |
|8 |     MERGE JOIN     |    |6        |79  |
|9 |      TABLE SCAN    |t3  |6        |37  |
|10|      TABLE SCAN    |t4  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |6        |212 |
|1 | SUBPLAN FILTER         |    |6        |206 |
|2 |  TABLE SCAN            |t1  |6        |37  |
|3 |  LIMIT                 |    |1        |169 |
|4 |   MERGE FULL OUTER JOIN|    |1        |169 |
|5 |    MERGE OUTER JOIN    |    |6        |127 |
|6 |     TABLE SCAN         |t1  |6        |37  |
|7 |     SORT               |    |6        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 = 0], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |224 |
|1 | SUBPLAN FILTER     |    |1        |223 |
|2 |  TABLE SCAN        |t1  |1        |38  |
|3 |  LIMIT             |    |0        |185 |
|4 |   MERGE OUTER JOIN |    |0        |185 |
|5 |    TABLE GET       |t2  |1        |52  |
|6 |    MERGE OUTER JOIN|    |1        |133 |
|7 |     TABLE GET      |t1  |1        |52  |
|8 |     MERGE JOIN     |    |6        |79  |
|9 |      TABLE SCAN    |t3  |6        |37  |
|10|      TABLE SCAN    |t4  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |207 |
|1 | SUBPLAN FILTER         |    |1        |206 |
|2 |  TABLE SCAN            |t1  |1        |38  |
|3 |  LIMIT                 |    |1        |169 |
|4 |   MERGE FULL OUTER JOIN|    |1        |169 |
|5 |    MERGE OUTER JOIN    |    |6        |127 |
|6 |     TABLE SCAN         |t1  |6        |37  |
|7 |     SORT               |    |6        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 = 0], [(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN  |    |1296     |1286|
|1 | NESTED-LOOP JOIN CARTESIAN |    |216      |316 |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |36       |108 |
|3 |   TABLE SCAN               |t2  |6        |37  |
|4 |   MATERIAL                 |    |6        |44  |
|5 |    TABLE SCAN              |t3  |6        |37  |
|6 |  MATERIAL                  |    |6        |44  |
|7 |   TABLE SCAN               |t4  |6        |37  |
|8 | MATERIAL                   |    |6        |40  |
|9 |  TABLE SCAN                |t1  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |MERGE FULL OUTER JOIN|    |1        |181 |
|1 | MERGE OUTER JOIN    |    |6        |139 |
|2 |  TABLE SCAN         |t1  |6        |37  |
|3 |  SORT               |    |6        |97  |
|4 |   MERGE OUTER JOIN  |    |6        |80  |
|5 |    TABLE SCAN       |t3  |6        |37  |
|6 |    TABLE SCAN       |t4  |6        |37  |
|7 | TABLE SCAN          |t2  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t2.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t3.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);
Query Plan
========================================================
|ID|OPERATOR                      |NAME |EST. ROWS|COST|
--------------------------------------------------------
|0 |INSERT                        |     |1296     |1644|
|1 | SUBPLAN SCAN                 |VIEW1|1296     |1465|
|2 |  NESTED-LOOP JOIN CARTESIAN  |     |1296     |1286|
|3 |   NESTED-LOOP JOIN CARTESIAN |     |216      |316 |
|4 |    NESTED-LOOP JOIN CARTESIAN|     |36       |108 |
|5 |     TABLE SCAN               |t2   |6        |37  |
|6 |     MATERIAL                 |     |6        |44  |
|7 |      TABLE SCAN              |t3   |6        |37  |
|8 |    MATERIAL                  |     |6        |44  |
|9 |     TABLE SCAN               |t4   |6        |37  |
|10|   MATERIAL                   |     |6        |40  |
|11|    TABLE SCAN                |t1   |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |1        |181 |
|1 | SUBPLAN SCAN          |VIEW1|1        |181 |
|2 |  MERGE FULL OUTER JOIN|     |1        |181 |
|3 |   MERGE OUTER JOIN    |     |6        |139 |
|4 |    TABLE SCAN         |t1   |6        |37  |
|5 |    SORT               |     |6        |97  |
|6 |     MERGE OUTER JOIN  |     |6        |80  |
|7 |      TABLE SCAN       |t3   |6        |37  |
|8 |      TABLE SCAN       |t4   |6        |37  |
|9 |   TABLE SCAN          |t2   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t2.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t3.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |UPDATE                         |    |6        |194 |
|1 | SUBPLAN FILTER                |    |6        |188 |
|2 |  TABLE SCAN                   |t1  |6        |37  |
|3 |  LIMIT                        |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |112 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|7 |      TABLE SCAN               |t2  |1        |36  |
|8 |      MATERIAL                 |    |6        |38  |
|9 |       TABLE SCAN              |t1  |6        |37  |
|10|     MATERIAL                  |    |6        |38  |
|11|      TABLE SCAN               |t3  |6        |37  |
|12|    MATERIAL                   |    |6        |38  |
|13|     TABLE SCAN                |t4  |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |6        |212 |
|1 | SUBPLAN FILTER         |    |6        |206 |
|2 |  TABLE SCAN            |t1  |6        |37  |
|3 |  LIMIT                 |    |1        |169 |
|4 |   MERGE FULL OUTER JOIN|    |1        |169 |
|5 |    MERGE OUTER JOIN    |    |6        |127 |
|6 |     TABLE SCAN         |t1  |6        |37  |
|7 |     SORT               |    |6        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t3.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |DELETE                         |    |1        |189 |
|1 | SUBPLAN FILTER                |    |1        |188 |
|2 |  TABLE SCAN                   |t1  |1        |38  |
|3 |  LIMIT                        |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |112 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|7 |      TABLE SCAN               |t2  |1        |36  |
|8 |      MATERIAL                 |    |6        |38  |
|9 |       TABLE SCAN              |t1  |6        |37  |
|10|     MATERIAL                  |    |6        |38  |
|11|      TABLE SCAN               |t3  |6        |37  |
|12|    MATERIAL                   |    |6        |38  |
|13|     TABLE SCAN                |t4  |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |207 |
|1 | SUBPLAN FILTER         |    |1        |206 |
|2 |  TABLE SCAN            |t1  |1        |38  |
|3 |  LIMIT                 |    |1        |169 |
|4 |   MERGE FULL OUTER JOIN|    |1        |169 |
|5 |    MERGE OUTER JOIN    |    |6        |127 |
|6 |     TABLE SCAN         |t1  |6        |37  |
|7 |     SORT               |    |6        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t3.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN  |    |1296     |1286|
|1 | NESTED-LOOP JOIN CARTESIAN |    |216      |316 |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |36       |108 |
|3 |   TABLE SCAN               |t2  |6        |37  |
|4 |   MATERIAL                 |    |6        |44  |
|5 |    TABLE SCAN              |t3  |6        |37  |
|6 |  MATERIAL                  |    |6        |44  |
|7 |   TABLE SCAN               |t4  |6        |37  |
|8 | MATERIAL                   |    |6        |40  |
|9 |  TABLE SCAN                |t1  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |MERGE FULL OUTER JOIN|    |1        |181 |
|1 | MERGE OUTER JOIN    |    |6        |139 |
|2 |  TABLE SCAN         |t1  |6        |37  |
|3 |  SORT               |    |6        |97  |
|4 |   MERGE OUTER JOIN  |    |6        |80  |
|5 |    TABLE SCAN       |t3  |6        |37  |
|6 |    TABLE SCAN       |t4  |6        |37  |
|7 | TABLE SCAN          |t2  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t2.c1 = 0], [t3.c1 = 0], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);
Query Plan
========================================================
|ID|OPERATOR                      |NAME |EST. ROWS|COST|
--------------------------------------------------------
|0 |INSERT                        |     |1296     |1644|
|1 | SUBPLAN SCAN                 |VIEW1|1296     |1465|
|2 |  NESTED-LOOP JOIN CARTESIAN  |     |1296     |1286|
|3 |   NESTED-LOOP JOIN CARTESIAN |     |216      |316 |
|4 |    NESTED-LOOP JOIN CARTESIAN|     |36       |108 |
|5 |     TABLE SCAN               |t2   |6        |37  |
|6 |     MATERIAL                 |     |6        |44  |
|7 |      TABLE SCAN              |t3   |6        |37  |
|8 |    MATERIAL                  |     |6        |44  |
|9 |     TABLE SCAN               |t4   |6        |37  |
|10|   MATERIAL                   |     |6        |40  |
|11|    TABLE SCAN                |t1   |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  9 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |1        |181 |
|1 | SUBPLAN SCAN          |VIEW1|1        |181 |
|2 |  MERGE FULL OUTER JOIN|     |1        |181 |
|3 |   MERGE OUTER JOIN    |     |6        |139 |
|4 |    TABLE SCAN         |t1   |6        |37  |
|5 |    SORT               |     |6        |97  |
|6 |     MERGE OUTER JOIN  |     |6        |80  |
|7 |      TABLE SCAN       |t3   |6        |37  |
|8 |      TABLE SCAN       |t4   |6        |37  |
|9 |   TABLE SCAN          |t2   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t2.c1 = 0], [t3.c1 = 0], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |UPDATE                         |    |6        |194 |
|1 | SUBPLAN FILTER                |    |6        |188 |
|2 |  TABLE SCAN                   |t1  |6        |37  |
|3 |  LIMIT                        |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |112 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|7 |      TABLE SCAN               |t2  |1        |36  |
|8 |      MATERIAL                 |    |6        |38  |
|9 |       TABLE SCAN              |t1  |6        |37  |
|10|     MATERIAL                  |    |6        |38  |
|11|      TABLE SCAN               |t3  |6        |37  |
|12|    MATERIAL                   |    |6        |38  |
|13|     TABLE SCAN                |t4  |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |6        |212 |
|1 | SUBPLAN FILTER         |    |6        |206 |
|2 |  TABLE SCAN            |t1  |6        |37  |
|3 |  LIMIT                 |    |1        |169 |
|4 |   MERGE FULL OUTER JOIN|    |1        |169 |
|5 |    MERGE OUTER JOIN    |    |6        |127 |
|6 |     TABLE SCAN         |t1  |6        |37  |
|7 |     SORT               |    |6        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 = 0], [t3.c1 = 0], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |DELETE                         |    |1        |189 |
|1 | SUBPLAN FILTER                |    |1        |188 |
|2 |  TABLE SCAN                   |t1  |1        |38  |
|3 |  LIMIT                        |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |112 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|7 |      TABLE SCAN               |t2  |1        |36  |
|8 |      MATERIAL                 |    |6        |38  |
|9 |       TABLE SCAN              |t1  |6        |37  |
|10|     MATERIAL                  |    |6        |38  |
|11|      TABLE SCAN               |t3  |6        |37  |
|12|    MATERIAL                   |    |6        |38  |
|13|     TABLE SCAN                |t4  |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |207 |
|1 | SUBPLAN FILTER         |    |1        |206 |
|2 |  TABLE SCAN            |t1  |1        |38  |
|3 |  LIMIT                 |    |1        |169 |
|4 |   MERGE FULL OUTER JOIN|    |1        |169 |
|5 |    MERGE OUTER JOIN    |    |6        |127 |
|6 |     TABLE SCAN         |t1  |6        |37  |
|7 |     SORT               |    |6        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 = 0], [t3.c1 = 0], [(T_OP_IS, t4.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN  |    |1        |211 |
|1 | NESTED-LOOP JOIN CARTESIAN |    |1        |158 |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |1        |105 |
|3 |   TABLE GET                |t2  |1        |53  |
|4 |   TABLE GET                |t1  |1        |52  |
|5 |  TABLE GET                 |t3  |1        |53  |
|6 | TABLE GET                  |t4  |1        |53  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |MERGE FULL OUTER JOIN|    |1        |181 |
|1 | MERGE OUTER JOIN    |    |6        |139 |
|2 |  TABLE SCAN         |t1  |6        |37  |
|3 |  SORT               |    |6        |97  |
|4 |   MERGE OUTER JOIN  |    |6        |80  |
|5 |    TABLE SCAN       |t3  |6        |37  |
|6 |    TABLE SCAN       |t4  |6        |37  |
|7 | TABLE SCAN          |t2  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t2.c1 = 0], [t3.c1 = 0], [t4.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);
Query Plan
========================================================
|ID|OPERATOR                      |NAME |EST. ROWS|COST|
--------------------------------------------------------
|0 |INSERT                        |     |1        |211 |
|1 | SUBPLAN SCAN                 |VIEW1|1        |211 |
|2 |  NESTED-LOOP JOIN CARTESIAN  |     |1        |211 |
|3 |   NESTED-LOOP JOIN CARTESIAN |     |1        |158 |
|4 |    NESTED-LOOP JOIN CARTESIAN|     |1        |105 |
|5 |     TABLE GET                |t2   |1        |53  |
|6 |     TABLE GET                |t1   |1        |52  |
|7 |    TABLE GET                 |t3   |1        |53  |
|8 |   TABLE GET                  |t4   |1        |53  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select * from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |1        |181 |
|1 | SUBPLAN SCAN          |VIEW1|1        |181 |
|2 |  MERGE FULL OUTER JOIN|     |1        |181 |
|3 |   MERGE OUTER JOIN    |     |6        |139 |
|4 |    TABLE SCAN         |t1   |6        |37  |
|5 |    SORT               |     |6        |97  |
|6 |     MERGE OUTER JOIN  |     |6        |80  |
|7 |      TABLE SCAN       |t3   |6        |37  |
|8 |      TABLE SCAN       |t4   |6        |37  |
|9 |   TABLE SCAN          |t2   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t2.c1 = 0], [t3.c1 = 0], [t4.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC])
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |UPDATE                         |    |6        |254 |
|1 | SUBPLAN FILTER                |    |6        |248 |
|2 |  TABLE SCAN                   |t1  |6        |37  |
|3 |  LIMIT                        |    |1        |210 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |210 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |158 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |105 |
|7 |      TABLE GET                |t2  |1        |52  |
|8 |      TABLE GET                |t1  |1        |52  |
|9 |     TABLE GET                 |t3  |1        |52  |
|10|    TABLE GET                  |t4  |1        |52  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |6        |212 |
|1 | SUBPLAN FILTER         |    |6        |206 |
|2 |  TABLE SCAN            |t1  |6        |37  |
|3 |  LIMIT                 |    |1        |169 |
|4 |   MERGE FULL OUTER JOIN|    |1        |169 |
|5 |    MERGE OUTER JOIN    |    |6        |127 |
|6 |     TABLE SCAN         |t1  |6        |37  |
|7 |     SORT               |    |6        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 = 0], [t3.c1 = 0], [t4.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |DELETE                         |    |1        |249 |
|1 | SUBPLAN FILTER                |    |1        |248 |
|2 |  TABLE SCAN                   |t1  |1        |38  |
|3 |  LIMIT                        |    |1        |210 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |210 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |158 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |105 |
|7 |      TABLE GET                |t2  |1        |52  |
|8 |      TABLE GET                |t1  |1        |52  |
|9 |     TABLE GET                 |t3  |1        |52  |
|10|    TABLE GET                  |t4  |1        |52  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |207 |
|1 | SUBPLAN FILTER         |    |1        |206 |
|2 |  TABLE SCAN            |t1  |1        |38  |
|3 |  LIMIT                 |    |1        |169 |
|4 |   MERGE FULL OUTER JOIN|    |1        |169 |
|5 |    MERGE OUTER JOIN    |    |6        |127 |
|6 |     TABLE SCAN         |t1  |6        |37  |
|7 |     SORT               |    |6        |85  |
|8 |      MERGE OUTER JOIN  |    |6        |79  |
|9 |       TABLE SCAN       |t3  |6        |37  |
|10|       TABLE SCAN       |t4  |6        |37  |
|11|    TABLE SCAN          |t2  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 = 0], [t3.c1 = 0], [t4.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 full join t2 on t1.c1 = t2.c1) left join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |0        |184 |
|1 | TABLE SCAN          |t2  |6        |37  |
|2 | HASH FULL OUTER JOIN|    |6        |130 |
|3 |  TABLE SCAN         |t1  |6        |37  |
|4 |  MERGE OUTER JOIN   |    |6        |80  |
|5 |   TABLE SCAN        |t3  |6        |37  |
|6 |   TABLE SCAN        |t4  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |0        |184 |
|1 | TABLE SCAN          |t2  |6        |37  |
|2 | HASH FULL OUTER JOIN|    |6        |130 |
|3 |  TABLE SCAN         |t1  |6        |37  |
|4 |  MERGE OUTER JOIN   |    |6        |80  |
|5 |   TABLE SCAN        |t3  |6        |37  |
|6 |   TABLE SCAN        |t4  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |0        |184 |
|1 | SUBPLAN SCAN          |VIEW1|0        |184 |
|2 |  HASH RIGHT OUTER JOIN|     |0        |184 |
|3 |   TABLE SCAN          |t2   |6        |37  |
|4 |   HASH FULL OUTER JOIN|     |6        |130 |
|5 |    TABLE SCAN         |t1   |6        |37  |
|6 |    MERGE OUTER JOIN   |     |6        |80  |
|7 |     TABLE SCAN        |t3   |6        |37  |
|8 |     TABLE SCAN        |t4   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |0        |184 |
|1 | SUBPLAN SCAN          |VIEW1|0        |184 |
|2 |  HASH RIGHT OUTER JOIN|     |0        |184 |
|3 |   TABLE SCAN          |t2   |6        |37  |
|4 |   HASH FULL OUTER JOIN|     |6        |130 |
|5 |    TABLE SCAN         |t1   |6        |37  |
|6 |    MERGE OUTER JOIN   |     |6        |80  |
|7 |     TABLE SCAN        |t3   |6        |37  |
|8 |     TABLE SCAN        |t4   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |6        |219 |
|1 | SUBPLAN FILTER           |    |6        |213 |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  LIMIT                   |    |0        |175 |
|4 |   MERGE OUTER JOIN       |    |0        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |6        |219 |
|1 | SUBPLAN FILTER           |    |6        |213 |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  LIMIT                   |    |0        |175 |
|4 |   MERGE OUTER JOIN       |    |0        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |214 |
|1 | SUBPLAN FILTER           |    |1        |213 |
|2 |  TABLE SCAN              |t1  |1        |38  |
|3 |  LIMIT                   |    |0        |175 |
|4 |   MERGE OUTER JOIN       |    |0        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |214 |
|1 | SUBPLAN FILTER           |    |1        |213 |
|2 |  TABLE SCAN              |t1  |1        |38  |
|3 |  LIMIT                   |    |0        |175 |
|4 |   MERGE OUTER JOIN       |    |0        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |36       |215 |
|1 | MERGE OUTER JOIN         |    |6        |144 |
|2 |  TABLE SCAN              |t4  |6        |37  |
|3 |  NESTED-LOOP OUTER JOIN  |    |1        |105 |
|4 |   TABLE GET              |t1  |1        |52  |
|5 |   TABLE GET              |t2  |1        |53  |
|6 | MATERIAL                 |    |6        |44  |
|7 |  TABLE SCAN              |t3  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |0        |184 |
|1 | TABLE SCAN          |t2  |6        |37  |
|2 | HASH FULL OUTER JOIN|    |6        |130 |
|3 |  TABLE SCAN         |t1  |6        |37  |
|4 |  MERGE OUTER JOIN   |    |6        |80  |
|5 |   TABLE SCAN        |t3  |6        |37  |
|6 |   TABLE SCAN        |t4  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |36       |225 |
|1 | SUBPLAN SCAN               |VIEW1|36       |220 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |36       |215 |
|3 |   MERGE OUTER JOIN         |     |6        |144 |
|4 |    TABLE SCAN              |t4   |6        |37  |
|5 |    NESTED-LOOP OUTER JOIN  |     |1        |105 |
|6 |     TABLE GET              |t1   |1        |52  |
|7 |     TABLE GET              |t2   |1        |53  |
|8 |   MATERIAL                 |     |6        |44  |
|9 |    TABLE SCAN              |t3   |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |0        |184 |
|1 | SUBPLAN SCAN          |VIEW1|0        |184 |
|2 |  HASH RIGHT OUTER JOIN|     |0        |184 |
|3 |   TABLE SCAN          |t2   |6        |37  |
|4 |   HASH FULL OUTER JOIN|     |6        |130 |
|5 |    TABLE SCAN         |t1   |6        |37  |
|6 |    MERGE OUTER JOIN   |     |6        |80  |
|7 |     TABLE SCAN        |t3   |6        |37  |
|8 |     TABLE SCAN        |t4   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |6        |167 |
|1 | SUBPLAN FILTER              |    |6        |161 |
|2 |  TABLE SCAN                 |t1  |6        |37  |
|3 |  LIMIT                      |    |1        |123 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |123 |
|5 |    MERGE OUTER JOIN         |    |1        |84  |
|6 |     TABLE SCAN              |t4  |1        |36  |
|7 |     TABLE GET               |t1  |1        |48  |
|8 |    MATERIAL                 |    |6        |38  |
|9 |     TABLE SCAN              |t3  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |6        |219 |
|1 | SUBPLAN FILTER           |    |6        |213 |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  LIMIT                   |    |0        |175 |
|4 |   MERGE OUTER JOIN       |    |0        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |161 |
|1 | SUBPLAN FILTER              |    |1        |160 |
|2 |  TABLE SCAN                 |t1  |1        |38  |
|3 |  LIMIT                      |    |1        |123 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |123 |
|5 |    MERGE OUTER JOIN         |    |1        |84  |
|6 |     TABLE SCAN              |t4  |1        |36  |
|7 |     TABLE GET               |t1  |1        |48  |
|8 |    MATERIAL                 |    |6        |38  |
|9 |     TABLE SCAN              |t3  |6        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |214 |
|1 | SUBPLAN FILTER           |    |1        |213 |
|2 |  TABLE SCAN              |t1  |1        |38  |
|3 |  LIMIT                   |    |0        |175 |
|4 |   MERGE OUTER JOIN       |    |0        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN  |    |0        |105 |
|1 | NESTED-LOOP OUTER JOIN |    |0        |105 |
|2 |  NESTED-LOOP OUTER JOIN|    |0        |105 |
|3 |   TABLE GET            |t3  |1        |53  |
|4 |   TABLE GET            |t4  |1        |53  |
|5 |  TABLE GET             |t1  |1        |36  |
|6 | TABLE GET              |t2  |1        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([t4.c1])
  2 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds(nil), nl_params_([t3.c1])
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |0        |184 |
|1 | TABLE SCAN          |t2  |6        |37  |
|2 | HASH FULL OUTER JOIN|    |6        |130 |
|3 |  TABLE SCAN         |t1  |6        |37  |
|4 |  MERGE OUTER JOIN   |    |6        |80  |
|5 |   TABLE SCAN        |t3  |6        |37  |
|6 |   TABLE SCAN        |t4  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t3.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT                    |     |0        |105 |
|1 | SUBPLAN SCAN             |VIEW1|0        |105 |
|2 |  NESTED-LOOP OUTER JOIN  |     |0        |105 |
|3 |   NESTED-LOOP OUTER JOIN |     |0        |105 |
|4 |    NESTED-LOOP OUTER JOIN|     |0        |105 |
|5 |     TABLE GET            |t3   |1        |53  |
|6 |     TABLE GET            |t4   |1        |53  |
|7 |    TABLE GET             |t1   |1        |36  |
|8 |   TABLE GET              |t2   |1        |36  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([t4.c1])
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds(nil), nl_params_([t3.c1])
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |0        |184 |
|1 | SUBPLAN SCAN          |VIEW1|0        |184 |
|2 |  HASH RIGHT OUTER JOIN|     |0        |184 |
|3 |   TABLE SCAN          |t2   |6        |37  |
|4 |   HASH FULL OUTER JOIN|     |6        |130 |
|5 |    TABLE SCAN         |t1   |6        |37  |
|6 |    MERGE OUTER JOIN   |     |6        |80  |
|7 |     TABLE SCAN        |t3   |6        |37  |
|8 |     TABLE SCAN        |t4   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t3.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                     |    |6        |149 |
|1 | SUBPLAN FILTER            |    |6        |143 |
|2 |  TABLE SCAN               |t1  |6        |37  |
|3 |  LIMIT                    |    |0        |105 |
|4 |   NESTED-LOOP OUTER JOIN  |    |0        |105 |
|5 |    NESTED-LOOP OUTER JOIN |    |0        |105 |
|6 |     NESTED-LOOP OUTER JOIN|    |0        |105 |
|7 |      TABLE GET            |t3  |1        |52  |
|8 |      TABLE GET            |t4  |1        |52  |
|9 |     TABLE GET             |t1  |1        |36  |
|10|    TABLE GET              |t2  |1        |36  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t4.c1])
  6 - output([t4.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds(nil), nl_params_([t3.c1])
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |6        |219 |
|1 | SUBPLAN FILTER           |    |6        |213 |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  LIMIT                   |    |0        |175 |
|4 |   MERGE OUTER JOIN       |    |0        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t3.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                     |    |1        |143 |
|1 | SUBPLAN FILTER            |    |1        |142 |
|2 |  TABLE SCAN               |t1  |1        |38  |
|3 |  LIMIT                    |    |0        |105 |
|4 |   NESTED-LOOP OUTER JOIN  |    |0        |105 |
|5 |    NESTED-LOOP OUTER JOIN |    |0        |105 |
|6 |     NESTED-LOOP OUTER JOIN|    |0        |105 |
|7 |      TABLE GET            |t3  |1        |52  |
|8 |      TABLE GET            |t4  |1        |52  |
|9 |     TABLE GET             |t1  |1        |36  |
|10|    TABLE GET              |t2  |1        |36  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds(nil), nl_params_([t1.c1])
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t4.c1])
  6 - output([t4.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)]), 
      conds(nil), nl_params_([t3.c1])
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |214 |
|1 | SUBPLAN FILTER           |    |1        |213 |
|2 |  TABLE SCAN              |t1  |1        |38  |
|3 |  LIMIT                   |    |0        |175 |
|4 |   MERGE OUTER JOIN       |    |0        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t3.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |NESTED-LOOP JOIN        |    |0        |211 |
|1 | NESTED-LOOP OUTER JOIN |    |1        |158 |
|2 |  NESTED-LOOP OUTER JOIN|    |1        |105 |
|3 |   TABLE GET            |t4  |1        |53  |
|4 |   TABLE GET            |t1  |1        |52  |
|5 |  TABLE GET             |t2  |1        |53  |
|6 | TABLE GET              |t3  |1        |53  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([(T_OP_IS, t2.c1, NULL, 0)]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  2 - output([t1.c1], [t1.c2], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([t4.c1])
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |1        |184 |
|1 | TABLE SCAN          |t2  |6        |37  |
|2 | HASH FULL OUTER JOIN|    |6        |130 |
|3 |  TABLE SCAN         |t1  |6        |37  |
|4 |  MERGE OUTER JOIN   |    |6        |80  |
|5 |   TABLE SCAN        |t3  |6        |37  |
|6 |   TABLE SCAN        |t4  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t3.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT                    |     |0        |211 |
|1 | SUBPLAN SCAN             |VIEW1|0        |211 |
|2 |  NESTED-LOOP JOIN        |     |0        |211 |
|3 |   NESTED-LOOP OUTER JOIN |     |1        |158 |
|4 |    NESTED-LOOP OUTER JOIN|     |1        |105 |
|5 |     TABLE GET            |t4   |1        |53  |
|6 |     TABLE GET            |t1   |1        |52  |
|7 |    TABLE GET             |t2   |1        |53  |
|8 |   TABLE GET              |t3   |1        |53  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([(T_OP_IS, t2.c1, NULL, 0)]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  4 - output([t1.c1], [t1.c2], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([t4.c1])
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |1        |184 |
|1 | SUBPLAN SCAN          |VIEW1|1        |184 |
|2 |  HASH RIGHT OUTER JOIN|     |1        |184 |
|3 |   TABLE SCAN          |t2   |6        |37  |
|4 |   HASH FULL OUTER JOIN|     |6        |130 |
|5 |    TABLE SCAN         |t1   |6        |37  |
|6 |    MERGE OUTER JOIN   |     |6        |80  |
|7 |     TABLE SCAN        |t3   |6        |37  |
|8 |     TABLE SCAN        |t4   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t3.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                     |    |6        |254 |
|1 | SUBPLAN FILTER            |    |6        |248 |
|2 |  TABLE SCAN               |t1  |6        |37  |
|3 |  LIMIT                    |    |0        |210 |
|4 |   NESTED-LOOP JOIN        |    |0        |210 |
|5 |    NESTED-LOOP OUTER JOIN |    |1        |158 |
|6 |     NESTED-LOOP OUTER JOIN|    |1        |105 |
|7 |      TABLE GET            |t4  |1        |52  |
|8 |      TABLE GET            |t1  |1        |52  |
|9 |     TABLE GET             |t2  |1        |52  |
|10|    TABLE GET              |t3  |1        |52  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([(T_OP_IS, t2.c1, NULL, 0)]), nl_params_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  6 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t4.c1])
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |6        |219 |
|1 | SUBPLAN FILTER           |    |6        |213 |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  LIMIT                   |    |1        |175 |
|4 |   MERGE OUTER JOIN       |    |1        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t3.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                     |    |1        |248 |
|1 | SUBPLAN FILTER            |    |1        |247 |
|2 |  TABLE SCAN               |t1  |1        |38  |
|3 |  LIMIT                    |    |0        |210 |
|4 |   NESTED-LOOP JOIN        |    |0        |210 |
|5 |    NESTED-LOOP OUTER JOIN |    |1        |158 |
|6 |     NESTED-LOOP OUTER JOIN|    |1        |105 |
|7 |      TABLE GET            |t4  |1        |52  |
|8 |      TABLE GET            |t1  |1        |52  |
|9 |     TABLE GET             |t2  |1        |52  |
|10|    TABLE GET              |t3  |1        |52  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([(T_OP_IS, t2.c1, NULL, 0)]), nl_params_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  6 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t4.c1])
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |214 |
|1 | SUBPLAN FILTER           |    |1        |213 |
|2 |  TABLE SCAN              |t1  |1        |38  |
|3 |  LIMIT                   |    |1        |175 |
|4 |   MERGE OUTER JOIN       |    |1        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t3.c1 = 0], [t4.c1 = 0], [(T_OP_IS, t2.c1, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 is NULL and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP JOIN            |    |0        |211 |
|1 | TABLE GET                  |t2  |1        |53  |
|2 | MERGE OUTER JOIN           |    |1        |158 |
|3 |  TABLE GET                 |t1  |1        |52  |
|4 |  NESTED-LOOP JOIN CARTESIAN|    |1        |105 |
|5 |   TABLE GET                |t4  |1        |53  |
|6 |   TABLE GET                |t3  |1        |53  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |0        |184 |
|1 | TABLE SCAN          |t2  |6        |37  |
|2 | HASH FULL OUTER JOIN|    |6        |130 |
|3 |  TABLE SCAN         |t1  |6        |37  |
|4 |  MERGE OUTER JOIN   |    |6        |80  |
|5 |   TABLE SCAN        |t3  |6        |37  |
|6 |   TABLE SCAN        |t4  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
========================================================
|ID|OPERATOR                      |NAME |EST. ROWS|COST|
--------------------------------------------------------
|0 |INSERT                        |     |0        |211 |
|1 | SUBPLAN SCAN                 |VIEW1|0        |211 |
|2 |  NESTED-LOOP JOIN            |     |0        |211 |
|3 |   TABLE GET                  |t2   |1        |53  |
|4 |   MERGE OUTER JOIN           |     |1        |158 |
|5 |    TABLE GET                 |t1   |1        |52  |
|6 |    NESTED-LOOP JOIN CARTESIAN|     |1        |105 |
|7 |     TABLE GET                |t3   |1        |53  |
|8 |     TABLE GET                |t4   |1        |53  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |0        |184 |
|1 | SUBPLAN SCAN          |VIEW1|0        |184 |
|2 |  HASH RIGHT OUTER JOIN|     |0        |184 |
|3 |   TABLE SCAN          |t2   |6        |37  |
|4 |   HASH FULL OUTER JOIN|     |6        |130 |
|5 |    TABLE SCAN         |t1   |6        |37  |
|6 |    MERGE OUTER JOIN   |     |6        |80  |
|7 |     TABLE SCAN        |t3   |6        |37  |
|8 |     TABLE SCAN        |t4   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |UPDATE                         |    |6        |254 |
|1 | SUBPLAN FILTER                |    |6        |248 |
|2 |  TABLE SCAN                   |t1  |6        |37  |
|3 |  LIMIT                        |    |0        |210 |
|4 |   NESTED-LOOP JOIN            |    |0        |210 |
|5 |    MERGE OUTER JOIN           |    |1        |158 |
|6 |     TABLE GET                 |t1  |1        |52  |
|7 |     NESTED-LOOP JOIN CARTESIAN|    |1        |105 |
|8 |      TABLE GET                |t4  |1        |52  |
|9 |      TABLE GET                |t3  |1        |52  |
|10|    TABLE GET                  |t2  |1        |52  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |6        |219 |
|1 | SUBPLAN FILTER           |    |6        |213 |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  LIMIT                   |    |0        |175 |
|4 |   MERGE OUTER JOIN       |    |0        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |DELETE                         |    |1        |249 |
|1 | SUBPLAN FILTER                |    |1        |248 |
|2 |  TABLE SCAN                   |t1  |1        |38  |
|3 |  LIMIT                        |    |0        |210 |
|4 |   NESTED-LOOP JOIN            |    |0        |210 |
|5 |    MERGE OUTER JOIN           |    |1        |158 |
|6 |     TABLE GET                 |t1  |1        |52  |
|7 |     NESTED-LOOP JOIN CARTESIAN|    |1        |105 |
|8 |      TABLE GET                |t4  |1        |52  |
|9 |      TABLE GET                |t3  |1        |52  |
|10|    TABLE GET                  |t2  |1        |52  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t3.c1], [t4.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |214 |
|1 | SUBPLAN FILTER           |    |1        |213 |
|2 |  TABLE SCAN              |t1  |1        |38  |
|3 |  LIMIT                   |    |0        |175 |
|4 |   MERGE OUTER JOIN       |    |0        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 is NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN  |    |1296     |1286|
|1 | NESTED-LOOP JOIN CARTESIAN |    |216      |316 |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |36       |108 |
|3 |   TABLE SCAN               |t3  |6        |37  |
|4 |   MATERIAL                 |    |6        |44  |
|5 |    TABLE SCAN              |t4  |6        |37  |
|6 |  MATERIAL                  |    |6        |44  |
|7 |   TABLE SCAN               |t2  |6        |37  |
|8 | MATERIAL                   |    |6        |40  |
|9 |  TABLE SCAN                |t1  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |0        |184 |
|1 | TABLE SCAN          |t2  |6        |37  |
|2 | HASH FULL OUTER JOIN|    |6        |130 |
|3 |  TABLE SCAN         |t1  |6        |37  |
|4 |  MERGE OUTER JOIN   |    |6        |80  |
|5 |   TABLE SCAN        |t3  |6        |37  |
|6 |   TABLE SCAN        |t4  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t2.c1 = 0], [t4.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);
Query Plan
========================================================
|ID|OPERATOR                      |NAME |EST. ROWS|COST|
--------------------------------------------------------
|0 |INSERT                        |     |1296     |1644|
|1 | SUBPLAN SCAN                 |VIEW1|1296     |1465|
|2 |  NESTED-LOOP JOIN CARTESIAN  |     |1296     |1286|
|3 |   NESTED-LOOP JOIN CARTESIAN |     |216      |316 |
|4 |    NESTED-LOOP JOIN CARTESIAN|     |36       |108 |
|5 |     TABLE SCAN               |t3   |6        |37  |
|6 |     MATERIAL                 |     |6        |44  |
|7 |      TABLE SCAN              |t4   |6        |37  |
|8 |    MATERIAL                  |     |6        |44  |
|9 |     TABLE SCAN               |t2   |6        |37  |
|10|   MATERIAL                   |     |6        |40  |
|11|    TABLE SCAN                |t1   |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |0        |184 |
|1 | SUBPLAN SCAN          |VIEW1|0        |184 |
|2 |  HASH RIGHT OUTER JOIN|     |0        |184 |
|3 |   TABLE SCAN          |t2   |6        |37  |
|4 |   HASH FULL OUTER JOIN|     |6        |130 |
|5 |    TABLE SCAN         |t1   |6        |37  |
|6 |    MERGE OUTER JOIN   |     |6        |80  |
|7 |     TABLE SCAN        |t3   |6        |37  |
|8 |     TABLE SCAN        |t4   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t2.c1 = 0], [t4.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |UPDATE                         |    |6        |194 |
|1 | SUBPLAN FILTER                |    |6        |188 |
|2 |  TABLE SCAN                   |t1  |6        |37  |
|3 |  LIMIT                        |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |112 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|7 |      TABLE SCAN               |t3  |1        |36  |
|8 |      MATERIAL                 |    |6        |38  |
|9 |       TABLE SCAN              |t4  |6        |37  |
|10|     MATERIAL                  |    |6        |38  |
|11|      TABLE SCAN               |t1  |6        |37  |
|12|    MATERIAL                   |    |6        |38  |
|13|     TABLE SCAN                |t2  |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([t1.c1]), filter(nil)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |6        |219 |
|1 | SUBPLAN FILTER           |    |6        |213 |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  LIMIT                   |    |0        |175 |
|4 |   MERGE OUTER JOIN       |    |0        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t2.c1 = 0], [t4.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |DELETE                         |    |1        |189 |
|1 | SUBPLAN FILTER                |    |1        |188 |
|2 |  TABLE SCAN                   |t1  |1        |38  |
|3 |  LIMIT                        |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |112 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|7 |      TABLE SCAN               |t3  |1        |36  |
|8 |      MATERIAL                 |    |6        |38  |
|9 |       TABLE SCAN              |t4  |6        |37  |
|10|     MATERIAL                  |    |6        |38  |
|11|      TABLE SCAN               |t1  |6        |37  |
|12|    MATERIAL                   |    |6        |38  |
|13|     TABLE SCAN                |t2  |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([t1.c1]), filter(nil)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |214 |
|1 | SUBPLAN FILTER           |    |1        |213 |
|2 |  TABLE SCAN              |t1  |1        |38  |
|3 |  LIMIT                   |    |0        |175 |
|4 |   MERGE OUTER JOIN       |    |0        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t3.c1, NULL, 0)], [t2.c1 = 0], [t4.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 is NULL and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN  |    |1296     |1286|
|1 | NESTED-LOOP JOIN CARTESIAN |    |216      |316 |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |36       |108 |
|3 |   TABLE SCAN               |t3  |6        |37  |
|4 |   MATERIAL                 |    |6        |44  |
|5 |    TABLE SCAN              |t4  |6        |37  |
|6 |  MATERIAL                  |    |6        |44  |
|7 |   TABLE SCAN               |t2  |6        |37  |
|8 | MATERIAL                   |    |6        |40  |
|9 |  TABLE SCAN                |t1  |6        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |0        |184 |
|1 | TABLE SCAN          |t2  |6        |37  |
|2 | HASH FULL OUTER JOIN|    |6        |130 |
|3 |  TABLE SCAN         |t1  |6        |37  |
|4 |  MERGE OUTER JOIN   |    |6        |80  |
|5 |   TABLE SCAN        |t3  |6        |37  |
|6 |   TABLE SCAN        |t4  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0], [t3.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);
Query Plan
========================================================
|ID|OPERATOR                      |NAME |EST. ROWS|COST|
--------------------------------------------------------
|0 |INSERT                        |     |1296     |1644|
|1 | SUBPLAN SCAN                 |VIEW1|1296     |1465|
|2 |  NESTED-LOOP JOIN CARTESIAN  |     |1296     |1286|
|3 |   NESTED-LOOP JOIN CARTESIAN |     |216      |316 |
|4 |    NESTED-LOOP JOIN CARTESIAN|     |36       |108 |
|5 |     TABLE SCAN               |t3   |6        |37  |
|6 |     MATERIAL                 |     |6        |44  |
|7 |      TABLE SCAN              |t4   |6        |37  |
|8 |    MATERIAL                  |     |6        |44  |
|9 |     TABLE SCAN               |t2   |6        |37  |
|10|   MATERIAL                   |     |6        |40  |
|11|    TABLE SCAN                |t1   |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |0        |184 |
|1 | SUBPLAN SCAN          |VIEW1|0        |184 |
|2 |  HASH RIGHT OUTER JOIN|     |0        |184 |
|3 |   TABLE SCAN          |t2   |6        |37  |
|4 |   HASH FULL OUTER JOIN|     |6        |130 |
|5 |    TABLE SCAN         |t1   |6        |37  |
|6 |    MERGE OUTER JOIN   |     |6        |80  |
|7 |     TABLE SCAN        |t3   |6        |37  |
|8 |     TABLE SCAN        |t4   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0], [t3.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |UPDATE                         |    |6        |194 |
|1 | SUBPLAN FILTER                |    |6        |188 |
|2 |  TABLE SCAN                   |t1  |6        |37  |
|3 |  LIMIT                        |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |112 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|7 |      TABLE SCAN               |t3  |1        |36  |
|8 |      MATERIAL                 |    |6        |38  |
|9 |       TABLE SCAN              |t4  |6        |37  |
|10|     MATERIAL                  |    |6        |38  |
|11|      TABLE SCAN               |t1  |6        |37  |
|12|    MATERIAL                   |    |6        |38  |
|13|     TABLE SCAN                |t2  |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([t1.c1]), filter(nil)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |6        |219 |
|1 | SUBPLAN FILTER           |    |6        |213 |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  LIMIT                   |    |0        |175 |
|4 |   MERGE OUTER JOIN       |    |0        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0], [t3.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |DELETE                         |    |1        |189 |
|1 | SUBPLAN FILTER                |    |1        |188 |
|2 |  TABLE SCAN                   |t1  |1        |38  |
|3 |  LIMIT                        |    |1        |151 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |151 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |112 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |74  |
|7 |      TABLE SCAN               |t3  |1        |36  |
|8 |      MATERIAL                 |    |6        |38  |
|9 |       TABLE SCAN              |t4  |6        |37  |
|10|     MATERIAL                  |    |6        |38  |
|11|      TABLE SCAN               |t1  |6        |37  |
|12|    MATERIAL                   |    |6        |38  |
|13|     TABLE SCAN                |t2  |6        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), startup_filter([0]), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([t1.c1]), filter(nil)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |214 |
|1 | SUBPLAN FILTER           |    |1        |213 |
|2 |  TABLE SCAN              |t1  |1        |38  |
|3 |  LIMIT                   |    |0        |175 |
|4 |   MERGE OUTER JOIN       |    |0        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t4.c1, NULL, 0)], [t2.c1 = 0], [t3.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 IS NULL limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN  |    |1        |211 |
|1 | NESTED-LOOP JOIN CARTESIAN |    |1        |158 |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |1        |105 |
|3 |   TABLE GET                |t3  |1        |53  |
|4 |   TABLE GET                |t4  |1        |53  |
|5 |  TABLE GET                 |t1  |1        |52  |
|6 | TABLE GET                  |t2  |1        |53  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |1        |184 |
|1 | TABLE SCAN          |t2  |6        |37  |
|2 | HASH FULL OUTER JOIN|    |6        |130 |
|3 |  TABLE SCAN         |t1  |6        |37  |
|4 |  MERGE OUTER JOIN   |    |6        |80  |
|5 |   TABLE SCAN        |t3  |6        |37  |
|6 |   TABLE SCAN        |t4  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t2.c1 = 0], [t3.c1 = 0], [t4.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0;
+----+------+----+------+------+----+------+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   | c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+----+------+------+----+------+------+----+------+------+
+----+------+----+------+------+----+------+------+----+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);
Query Plan
========================================================
|ID|OPERATOR                      |NAME |EST. ROWS|COST|
--------------------------------------------------------
|0 |INSERT                        |     |1        |211 |
|1 | SUBPLAN SCAN                 |VIEW1|1        |211 |
|2 |  NESTED-LOOP JOIN CARTESIAN  |     |1        |211 |
|3 |   NESTED-LOOP JOIN CARTESIAN |     |1        |158 |
|4 |    NESTED-LOOP JOIN CARTESIAN|     |1        |105 |
|5 |     TABLE GET                |t3   |1        |53  |
|6 |     TABLE GET                |t4   |1        |53  |
|7 |    TABLE GET                 |t1   |1        |52  |
|8 |   TABLE GET                  |t2   |1        |53  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |1        |184 |
|1 | SUBPLAN SCAN          |VIEW1|1        |184 |
|2 |  HASH RIGHT OUTER JOIN|     |1        |184 |
|3 |   TABLE SCAN          |t2   |6        |37  |
|4 |   HASH FULL OUTER JOIN|     |6        |130 |
|5 |    TABLE SCAN         |t1   |6        |37  |
|6 |    MERGE OUTER JOIN   |     |6        |80  |
|7 |     TABLE SCAN        |t3   |6        |37  |
|8 |     TABLE SCAN        |t4   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.e, t7_temp.f, t7_temp.g, t7_temp.h, t7_temp.i, t7_temp.j, t7_temp.k)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter([t2.c1 = 0], [t3.c1 = 0], [t4.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

insert into t7_temp (select /*+ NO_REWRITE */* from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |UPDATE                         |    |6        |254 |
|1 | SUBPLAN FILTER                |    |6        |248 |
|2 |  TABLE SCAN                   |t1  |6        |37  |
|3 |  LIMIT                        |    |1        |210 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |210 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |158 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |105 |
|7 |      TABLE GET                |t3  |1        |52  |
|8 |      TABLE GET                |t4  |1        |52  |
|9 |     TABLE GET                 |t1  |1        |52  |
|10|    TABLE GET                  |t2  |1        |52  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |6        |219 |
|1 | SUBPLAN FILTER           |    |6        |213 |
|2 |  TABLE SCAN              |t1  |6        |37  |
|3 |  LIMIT                   |    |1        |175 |
|4 |   MERGE OUTER JOIN       |    |1        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 = 0], [t3.c1 = 0], [t4.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
========================================================
|ID|OPERATOR                       |NAME|EST. ROWS|COST|
--------------------------------------------------------
|0 |DELETE                         |    |1        |249 |
|1 | SUBPLAN FILTER                |    |1        |248 |
|2 |  TABLE SCAN                   |t1  |1        |38  |
|3 |  LIMIT                        |    |1        |210 |
|4 |   NESTED-LOOP JOIN CARTESIAN  |    |1        |210 |
|5 |    NESTED-LOOP JOIN CARTESIAN |    |1        |158 |
|6 |     NESTED-LOOP JOIN CARTESIAN|    |1        |105 |
|7 |      TABLE GET                |t3  |1        |52  |
|8 |      TABLE GET                |t4  |1        |52  |
|9 |     TABLE GET                 |t1  |1        |52  |
|10|    TABLE GET                  |t2  |1        |52  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |214 |
|1 | SUBPLAN FILTER           |    |1        |213 |
|2 |  TABLE SCAN              |t1  |1        |38  |
|3 |  LIMIT                   |    |1        |175 |
|4 |   MERGE OUTER JOIN       |    |1        |175 |
|5 |    SORT                  |    |6        |133 |
|6 |     MERGE FULL OUTER JOIN|    |6        |127 |
|7 |      SORT                |    |6        |85  |
|8 |       MERGE OUTER JOIN   |    |6        |79  |
|9 |        TABLE SCAN        |t3  |6        |37  |
|10|        TABLE SCAN        |t4  |6        |37  |
|11|      TABLE SCAN          |t1  |6        |37  |
|12|    TABLE SCAN            |t2  |6        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 = 0], [t3.c1 = 0], [t4.c1 = 0]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1], [t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1 = t2.c1) full join (t3 left join t4 on t4.c1 = t3.c1) on t1.c1 = t4.c1 where t2.c1 = 0 and t3.c1 = 0 and t4.c1 = 0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_OR, abs(cast(t2.c2, BIGINT(-1, 0))) > 2, sqrt(cast(t2.c2, DOUBLE(-1, -1))) > ?, log2(cast(t2.c2, DOUBLE(-1, -1))) > ?, t2.c2 XOR t2.c1 > 2)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_OR, abs(cast(t2.c2, BIGINT(-1, 0))) > 2, sqrt(cast(t2.c2, DOUBLE(-1, -1))) > ?, log2(cast(t2.c2, DOUBLE(-1, -1))) > ?, t2.c2 XOR t2.c1 > 2)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |81  |
|1 | SUBPLAN SCAN     |VIEW1|6        |80  |
|2 |  MERGE OUTER JOIN|     |6        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_OR, abs(cast(t2.c2, BIGINT(-1, 0))) > 2, sqrt(cast(t2.c2, DOUBLE(-1, -1))) > ?, log2(cast(t2.c2, DOUBLE(-1, -1))) > ?, t2.c2 XOR t2.c1 > 2)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2));

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |81  |
|1 | SUBPLAN SCAN     |VIEW1|6        |80  |
|2 |  MERGE OUTER JOIN|     |6        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_OR, abs(cast(t2.c2, BIGINT(-1, 0))) > 2, sqrt(cast(t2.c2, DOUBLE(-1, -1))) > ?, log2(cast(t2.c2, DOUBLE(-1, -1))) > ?, t2.c2 XOR t2.c1 > 2)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |118 |
|1 | SUBPLAN FILTER    |    |6        |112 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |74  |
|4 |   MERGE OUTER JOIN|    |1        |74  |
|5 |    TABLE SCAN     |t1  |3        |37  |
|6 |    TABLE SCAN     |t2  |3        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_OR, abs(cast(t2.c2, BIGINT(-1, 0))) > 2, sqrt(cast(t2.c2, DOUBLE(-1, -1))) > ?, log2(cast(t2.c2, DOUBLE(-1, -1))) > ?, t2.c2 XOR t2.c1 > 2)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |118 |
|1 | SUBPLAN FILTER    |    |6        |112 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |74  |
|4 |   MERGE OUTER JOIN|    |1        |74  |
|5 |    TABLE SCAN     |t1  |3        |37  |
|6 |    TABLE SCAN     |t2  |3        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_OR, abs(cast(t2.c2, BIGINT(-1, 0))) > 2, sqrt(cast(t2.c2, DOUBLE(-1, -1))) > ?, log2(cast(t2.c2, DOUBLE(-1, -1))) > ?, t2.c2 XOR t2.c1 > 2)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |113 |
|1 | SUBPLAN FILTER    |    |1        |112 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |74  |
|4 |   MERGE OUTER JOIN|    |1        |74  |
|5 |    TABLE SCAN     |t1  |3        |37  |
|6 |    TABLE SCAN     |t2  |3        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_OR, abs(cast(t2.c2, BIGINT(-1, 0))) > 2, sqrt(cast(t2.c2, DOUBLE(-1, -1))) > ?, log2(cast(t2.c2, DOUBLE(-1, -1))) > ?, t2.c2 XOR t2.c1 > 2)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |113 |
|1 | SUBPLAN FILTER    |    |1        |112 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |74  |
|4 |   MERGE OUTER JOIN|    |1        |74  |
|5 |    TABLE SCAN     |t1  |3        |37  |
|6 |    TABLE SCAN     |t2  |3        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_OR, abs(cast(t2.c2, BIGINT(-1, 0))) > 2, sqrt(cast(t2.c2, DOUBLE(-1, -1))) > ?, log2(cast(t2.c2, DOUBLE(-1, -1))) > ?, t2.c2 XOR t2.c1 > 2)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where abs(t2.c2) > 2 or sqrt(t2.c2) > 2 or log2(t2.c2) > 2 or (t2.c2 xor t2.c1 > 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |2        |77  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |2        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > 4 OR t2.c2 < 1]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |2        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > 4 OR t2.c2 < 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |2        |77  |
|1 | SUBPLAN SCAN|VIEW1|2        |77  |
|2 |  MERGE JOIN |     |2        |77  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |2        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > 4 OR t2.c2 < 1]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |2        |80  |
|1 | SUBPLAN SCAN     |VIEW1|2        |80  |
|2 |  MERGE OUTER JOIN|     |2        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > 4 OR t2.c2 < 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |118 |
|1 | SUBPLAN FILTER    |    |6        |112 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |74  |
|4 |   NESTED-LOOP JOIN|    |1        |74  |
|5 |    TABLE SCAN     |t2  |1        |38  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([t2.c2 > 4 OR t2.c2 < 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |122 |
|1 | SUBPLAN FILTER    |    |6        |116 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |78  |
|4 |   MERGE OUTER JOIN|    |1        |78  |
|5 |    TABLE SCAN     |t1  |6        |37  |
|6 |    TABLE SCAN     |t2  |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 > 4 OR t2.c2 < 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |113 |
|1 | SUBPLAN FILTER    |    |1        |112 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |74  |
|4 |   NESTED-LOOP JOIN|    |1        |74  |
|5 |    TABLE SCAN     |t2  |1        |38  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([t2.c2 > 4 OR t2.c2 < 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |117 |
|1 | SUBPLAN FILTER    |    |1        |116 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |78  |
|4 |   MERGE OUTER JOIN|    |1        |78  |
|5 |    TABLE SCAN     |t1  |6        |37  |
|6 |    TABLE SCAN     |t2  |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 > 4 OR t2.c2 < 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or t2.c2 < 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |5        |79  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |5        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c2, 1, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |5        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c2, 1, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |5        |81  |
|1 | SUBPLAN SCAN|VIEW1|5        |80  |
|2 |  MERGE JOIN |     |5        |79  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |5        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c2, 1, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |5        |81  |
|1 | SUBPLAN SCAN     |VIEW1|5        |80  |
|2 |  MERGE OUTER JOIN|     |5        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c2, 1, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([(T_OP_IS, t2.c2, 1, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |118 |
|1 | SUBPLAN FILTER    |    |6        |112 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |74  |
|5 |    TABLE SCAN     |t1  |3        |37  |
|6 |    TABLE SCAN     |t2  |3        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c2, 1, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |73  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([(T_OP_IS, t2.c2, 1, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |113 |
|1 | SUBPLAN FILTER    |    |1        |112 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |74  |
|5 |    TABLE SCAN     |t1  |3        |37  |
|6 |    TABLE SCAN     |t2  |3        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c2, 1, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 is true limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1);
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |MERGE JOIN            |    |2        |126 |
|1 | NESTED-LOOP SEMI JOIN|    |2        |87  |
|2 |  TABLE SCAN          |t2  |6        |37  |
|3 |  MATERIAL            |    |6        |38  |
|4 |   TABLE SCAN         |t1  |6        |37  |
|5 | TABLE SCAN           |t1  |6        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t2.c2 > t1.c2]), nl_params_(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  3 - output([t1.c2]), filter(nil)
  4 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER   |    |3        |126 |
|1 | MERGE OUTER JOIN|    |6        |80  |
|2 |  TABLE SCAN     |t1  |6        |37  |
|3 |  TABLE SCAN     |t2  |6        |37  |
|4 | TABLE SCAN      |t1  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |2        |126 |
|1 | SUBPLAN SCAN           |VIEW1|2        |126 |
|2 |  MERGE JOIN            |     |2        |126 |
|3 |   NESTED-LOOP SEMI JOIN|     |2        |87  |
|4 |    TABLE SCAN          |t2   |6        |37  |
|5 |    MATERIAL            |     |6        |38  |
|6 |     TABLE SCAN         |t1   |6        |37  |
|7 |   TABLE SCAN           |t1   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t2.c2 > t1.c2]), nl_params_(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  5 - output([t1.c2]), filter(nil)
  6 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1));

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1));
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |3        |127 |
|1 | SUBPLAN SCAN      |VIEW1|3        |127 |
|2 |  SUBPLAN FILTER   |     |3        |126 |
|3 |   MERGE OUTER JOIN|     |6        |80  |
|4 |    TABLE SCAN     |t1   |6        |37  |
|5 |    TABLE SCAN     |t2   |6        |37  |
|6 |   TABLE SCAN      |t1   |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |161 |
|1 | SUBPLAN FILTER          |    |6        |155 |
|2 |  TABLE SCAN             |t1  |6        |37  |
|3 |  LIMIT                  |    |1        |117 |
|4 |   NESTED-LOOP JOIN      |    |1        |117 |
|5 |    NESTED-LOOP SEMI JOIN|    |1        |80  |
|6 |     TABLE SCAN          |t2  |3        |37  |
|7 |     MATERIAL            |    |6        |38  |
|8 |      TABLE SCAN         |t1  |6        |37  |
|9 |    TABLE GET            |t1  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      conds([t2.c2 > t1.c2]), nl_params_(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t1.c2]), filter(nil)
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |6        |161 |
|1 | SUBPLAN FILTER     |    |6        |155 |
|2 |  TABLE SCAN        |t1  |6        |37  |
|3 |  LIMIT             |    |1        |117 |
|4 |   SUBPLAN FILTER   |    |1        |117 |
|5 |    MERGE OUTER JOIN|    |2        |75  |
|6 |     TABLE SCAN     |t1  |4        |37  |
|7 |     TABLE SCAN     |t2  |4        |37  |
|8 |    TABLE SCAN      |t1  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 > ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |156 |
|1 | SUBPLAN FILTER          |    |1        |155 |
|2 |  TABLE SCAN             |t1  |1        |38  |
|3 |  LIMIT                  |    |1        |117 |
|4 |   NESTED-LOOP JOIN      |    |1        |117 |
|5 |    NESTED-LOOP SEMI JOIN|    |1        |80  |
|6 |     TABLE SCAN          |t2  |3        |37  |
|7 |     MATERIAL            |    |6        |38  |
|8 |      TABLE SCAN         |t1  |6        |37  |
|9 |    TABLE GET            |t1  |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      conds([t2.c2 > t1.c2]), nl_params_(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t1.c2]), filter(nil)
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |155 |
|1 | SUBPLAN FILTER     |    |1        |154 |
|2 |  TABLE SCAN        |t1  |1        |38  |
|3 |  LIMIT             |    |1        |117 |
|4 |   SUBPLAN FILTER   |    |1        |117 |
|5 |    MERGE OUTER JOIN|    |2        |75  |
|6 |     TABLE SCAN     |t1  |4        |37  |
|7 |     TABLE SCAN     |t2  |4        |37  |
|8 |    TABLE SCAN      |t1  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 > ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > any (select c2 from t1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000);
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |MERGE JOIN            |     |3        |118 |
|1 | NESTED-LOOP SEMI JOIN|     |3        |78  |
|2 |  TABLE SCAN          |t2   |6        |37  |
|3 |  MATERIAL            |     |1        |39  |
|4 |   SUBPLAN SCAN       |VIEW1|1        |38  |
|5 |    TABLE SCAN        |t1   |1        |38  |
|6 | TABLE SCAN           |t1   |6        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t2.c2 != VIEW1.c2]), nl_params_(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  3 - output([VIEW1.c2]), filter(nil)
  4 - output([VIEW1.c2]), filter(nil), 
      access([VIEW1.c2])
  5 - output([t1.c2]), filter([t1.c2 > 1000]), 
      access([t1.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER   |    |3        |119 |
|1 | MERGE OUTER JOIN|    |6        |80  |
|2 |  TABLE SCAN     |t1  |6        |37  |
|3 |  TABLE SCAN     |t2  |6        |37  |
|4 | TABLE SCAN      |t1  |1        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 != ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c2]), filter([t1.c2 > 1000]), 
      access([t1.c2]), partitions(p0)

select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |3        |119 |
|1 | SUBPLAN SCAN           |VIEW1|3        |118 |
|2 |  MERGE JOIN            |     |3        |118 |
|3 |   NESTED-LOOP SEMI JOIN|     |3        |78  |
|4 |    TABLE SCAN          |t2   |6        |37  |
|5 |    MATERIAL            |     |1        |39  |
|6 |     SUBPLAN SCAN       |VIEW2|1        |38  |
|7 |      TABLE SCAN        |t1   |1        |38  |
|8 |   TABLE SCAN           |t1   |6        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t2.c2 != VIEW2.c2]), nl_params_(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  5 - output([VIEW2.c2]), filter(nil)
  6 - output([VIEW2.c2]), filter(nil), 
      access([VIEW2.c2])
  7 - output([t1.c2]), filter([t1.c2 > 1000]), 
      access([t1.c2]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000));

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000));
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |3        |120 |
|1 | SUBPLAN SCAN      |VIEW1|3        |120 |
|2 |  SUBPLAN FILTER   |     |3        |119 |
|3 |   MERGE OUTER JOIN|     |6        |80  |
|4 |    TABLE SCAN     |t1   |6        |37  |
|5 |    TABLE SCAN     |t2   |6        |37  |
|6 |   TABLE SCAN      |t1   |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 != ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c2]), filter([t1.c2 > 1000]), 
      access([t1.c2]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000) limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                   |     |6        |156 |
|1 | SUBPLAN FILTER          |     |6        |150 |
|2 |  TABLE SCAN             |t1   |6        |37  |
|3 |  LIMIT                  |     |1        |112 |
|4 |   NESTED-LOOP JOIN      |     |1        |112 |
|5 |    NESTED-LOOP SEMI JOIN|     |1        |75  |
|6 |     TABLE SCAN          |t2   |2        |37  |
|7 |     MATERIAL            |     |1        |39  |
|8 |      SUBPLAN SCAN       |VIEW1|1        |38  |
|9 |       TABLE SCAN        |t1   |1        |38  |
|10|    TABLE GET            |t1   |1        |36  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      conds([t2.c2 != VIEW1.c2]), nl_params_(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([VIEW1.c2]), filter(nil)
  8 - output([VIEW1.c2]), filter(nil), 
      access([VIEW1.c2])
  9 - output([t1.c2]), filter([t1.c2 > 1000]), 
      access([t1.c2]), partitions(p0)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |6        |158 |
|1 | SUBPLAN FILTER     |    |6        |152 |
|2 |  TABLE SCAN        |t1  |6        |37  |
|3 |  LIMIT             |    |1        |114 |
|4 |   SUBPLAN FILTER   |    |1        |114 |
|5 |    MERGE OUTER JOIN|    |2        |75  |
|6 |     TABLE SCAN     |t1  |4        |37  |
|7 |     TABLE SCAN     |t2  |4        |37  |
|8 |    TABLE SCAN      |t1  |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 != ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c2]), filter([t1.c2 > 1000]), 
      access([t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000) limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                   |     |1        |151 |
|1 | SUBPLAN FILTER          |     |1        |150 |
|2 |  TABLE SCAN             |t1   |1        |38  |
|3 |  LIMIT                  |     |1        |112 |
|4 |   NESTED-LOOP JOIN      |     |1        |112 |
|5 |    NESTED-LOOP SEMI JOIN|     |1        |75  |
|6 |     TABLE SCAN          |t2   |2        |37  |
|7 |     MATERIAL            |     |1        |39  |
|8 |      SUBPLAN SCAN       |VIEW1|1        |38  |
|9 |       TABLE SCAN        |t1   |1        |38  |
|10|    TABLE GET            |t1   |1        |36  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter(nil), 
      conds([t2.c2 != VIEW1.c2]), nl_params_(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([VIEW1.c2]), filter(nil)
  8 - output([VIEW1.c2]), filter(nil), 
      access([VIEW1.c2])
  9 - output([t1.c2]), filter([t1.c2 > 1000]), 
      access([t1.c2]), partitions(p0)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |152 |
|1 | SUBPLAN FILTER     |    |1        |151 |
|2 |  TABLE SCAN        |t1  |1        |38  |
|3 |  LIMIT             |    |1        |114 |
|4 |   SUBPLAN FILTER   |    |1        |114 |
|5 |    MERGE OUTER JOIN|    |2        |75  |
|6 |     TABLE SCAN     |t1  |4        |37  |
|7 |     TABLE SCAN     |t2  |4        |37  |
|8 |    TABLE SCAN      |t1  |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 != ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c2]), filter([t1.c2 > 1000]), 
      access([t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 != any (select c2 from t1 where c2 > 1000) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_OR, (T_OP_NOT_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_LIKE, cast(t2.c2, VARCHAR(1048576)), ?, '\\'))]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_OR, (T_OP_NOT_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_LIKE, cast(t2.c2, VARCHAR(1048576)), ?, '\\'))]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |81  |
|1 | SUBPLAN SCAN     |VIEW1|6        |80  |
|2 |  MERGE OUTER JOIN|     |6        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_OR, (T_OP_NOT_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_LIKE, cast(t2.c2, VARCHAR(1048576)), ?, '\\'))]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2));

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |81  |
|1 | SUBPLAN SCAN     |VIEW1|6        |80  |
|2 |  MERGE OUTER JOIN|     |6        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_OR, (T_OP_NOT_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_LIKE, cast(t2.c2, VARCHAR(1048576)), ?, '\\'))]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |118 |
|1 | SUBPLAN FILTER    |    |6        |112 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |74  |
|4 |   MERGE OUTER JOIN|    |1        |74  |
|5 |    TABLE SCAN     |t1  |3        |37  |
|6 |    TABLE SCAN     |t2  |3        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_OR, (T_OP_NOT_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_LIKE, cast(t2.c2, VARCHAR(1048576)), ?, '\\'))]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |118 |
|1 | SUBPLAN FILTER    |    |6        |112 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |74  |
|4 |   MERGE OUTER JOIN|    |1        |74  |
|5 |    TABLE SCAN     |t1  |3        |37  |
|6 |    TABLE SCAN     |t2  |3        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_OR, (T_OP_NOT_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_LIKE, cast(t2.c2, VARCHAR(1048576)), ?, '\\'))]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |113 |
|1 | SUBPLAN FILTER    |    |1        |112 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |74  |
|4 |   MERGE OUTER JOIN|    |1        |74  |
|5 |    TABLE SCAN     |t1  |3        |37  |
|6 |    TABLE SCAN     |t2  |3        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_OR, (T_OP_NOT_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_LIKE, cast(t2.c2, VARCHAR(1048576)), ?, '\\'))]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |113 |
|1 | SUBPLAN FILTER    |    |1        |112 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |74  |
|4 |   MERGE OUTER JOIN|    |1        |74  |
|5 |    TABLE SCAN     |t1  |3        |37  |
|6 |    TABLE SCAN     |t2  |3        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_OR, (T_OP_NOT_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_BTW, cast(t2.c2, DECIMAL(11, 0)), ?, ?), (T_OP_LIKE, cast(t2.c2, VARCHAR(1048576)), ?, '\\'))]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (t2.c2 not between 1 and 4) or (t2.c2 between 3 and 3) or (t2.c2 like 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |3        |78  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |3        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 1, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |3        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 1, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |3        |79  |
|1 | SUBPLAN SCAN|VIEW1|3        |78  |
|2 |  MERGE JOIN |     |3        |78  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |3        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 1, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |3        |80  |
|1 | SUBPLAN SCAN     |VIEW1|3        |80  |
|2 |  MERGE OUTER JOIN|     |3        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 1, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |74  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 1, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |119 |
|1 | SUBPLAN FILTER    |    |6        |113 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 1, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |74  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 1, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |114 |
|1 | SUBPLAN FILTER    |    |1        |113 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 1, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is true limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |3        |78  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |3        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 1, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |3        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 1, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |3        |79  |
|1 | SUBPLAN SCAN|VIEW1|3        |78  |
|2 |  MERGE JOIN |     |3        |78  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |3        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 1, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |3        |80  |
|1 | SUBPLAN SCAN     |VIEW1|3        |80  |
|2 |  MERGE OUTER JOIN|     |3        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 1, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |74  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 1, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |119 |
|1 | SUBPLAN FILTER    |    |6        |113 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 1, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |74  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 1, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |114 |
|1 | SUBPLAN FILTER    |    |1        |113 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 1, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is true limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |3        |78  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |3        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 0, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |3        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 0, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |3        |79  |
|1 | SUBPLAN SCAN|VIEW1|3        |78  |
|2 |  MERGE JOIN |     |3        |78  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |3        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 0, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |3        |80  |
|1 | SUBPLAN SCAN     |VIEW1|3        |80  |
|2 |  MERGE OUTER JOIN|     |3        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 0, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |74  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 0, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |119 |
|1 | SUBPLAN FILTER    |    |6        |113 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 0, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |74  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 0, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |114 |
|1 | SUBPLAN FILTER    |    |1        |113 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c2 > 2 OR t2.c2 < 4, 0, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is false limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |3        |78  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |3        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2 > 2 OR t2.c2 < 4, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |3        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2 > 2 OR t2.c2 < 4, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |3        |79  |
|1 | SUBPLAN SCAN|VIEW1|3        |78  |
|2 |  MERGE JOIN |     |3        |78  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |3        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2 > 2 OR t2.c2 < 4, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |3        |80  |
|1 | SUBPLAN SCAN     |VIEW1|3        |80  |
|2 |  MERGE OUTER JOIN|     |3        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2 > 2 OR t2.c2 < 4, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |74  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([(T_OP_IS_NOT, t2.c2 > 2 OR t2.c2 < 4, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |119 |
|1 | SUBPLAN FILTER    |    |6        |113 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t2.c2 > 2 OR t2.c2 < 4, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |74  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([(T_OP_IS_NOT, t2.c2 > 2 OR t2.c2 < 4, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |114 |
|1 | SUBPLAN FILTER    |    |1        |113 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t2.c2 > 2 OR t2.c2 < 4, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c2 > 2) or (t2.c2 < 4)) is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |3        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_NOT_BTW, ?, cast(t2.c2, DECIMAL(11, 0)), ?)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |3        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_NOT_BTW, ?, cast(t2.c2, DECIMAL(11, 0)), ?)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |3        |80  |
|1 | SUBPLAN SCAN     |VIEW1|3        |80  |
|2 |  MERGE OUTER JOIN|     |3        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_NOT_BTW, ?, cast(t2.c2, DECIMAL(11, 0)), ?)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4));

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |3        |80  |
|1 | SUBPLAN SCAN     |VIEW1|3        |80  |
|2 |  MERGE OUTER JOIN|     |3        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_NOT_BTW, ?, cast(t2.c2, DECIMAL(11, 0)), ?)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |119 |
|1 | SUBPLAN FILTER    |    |6        |113 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_BTW, ?, cast(t2.c2, DECIMAL(11, 0)), ?)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |119 |
|1 | SUBPLAN FILTER    |    |6        |113 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_BTW, ?, cast(t2.c2, DECIMAL(11, 0)), ?)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |114 |
|1 | SUBPLAN FILTER    |    |1        |113 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_BTW, ?, cast(t2.c2, DECIMAL(11, 0)), ?)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |114 |
|1 | SUBPLAN FILTER    |    |1        |113 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_BTW, ?, cast(t2.c2, DECIMAL(11, 0)), ?)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (3 not between t2.c2 and 4) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+-----------------+
| stddev(c2)      |
+-----------------+
| 2.0591260281974 |
+-----------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |4        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > 4 OR nvl(cast(t2.c2, BIGINT(1, 0)), 1)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE */ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |4        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > 4 OR nvl(cast(t2.c2, BIGINT(1, 0)), 1)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE */ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |4        |80  |
|1 | SUBPLAN SCAN     |VIEW1|4        |80  |
|2 |  MERGE OUTER JOIN|     |4        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > 4 OR nvl(cast(t2.c2, BIGINT(1, 0)), 1)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1));

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE */ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |4        |80  |
|1 | SUBPLAN SCAN     |VIEW1|4        |80  |
|2 |  MERGE OUTER JOIN|     |4        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > 4 OR nvl(cast(t2.c2, BIGINT(1, 0)), 1)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE */ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |119 |
|1 | SUBPLAN FILTER    |    |6        |113 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 > 4 OR nvl(cast(t2.c2, BIGINT(1, 0)), 1)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */ t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |119 |
|1 | SUBPLAN FILTER    |    |6        |113 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 > 4 OR nvl(cast(t2.c2, BIGINT(1, 0)), 1)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */ t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |114 |
|1 | SUBPLAN FILTER    |    |1        |113 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 > 4 OR nvl(cast(t2.c2, BIGINT(1, 0)), 1)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */ t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |114 |
|1 | SUBPLAN FILTER    |    |1        |113 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 > 4 OR nvl(cast(t2.c2, BIGINT(1, 0)), 1)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */ t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > 4 or nvl(t2.c2, 1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |3        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE 0 END]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |3        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE 0 END]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |3        |80  |
|1 | SUBPLAN SCAN     |VIEW1|3        |80  |
|2 |  MERGE OUTER JOIN|     |3        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE 0 END]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end));

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |3        |80  |
|1 | SUBPLAN SCAN     |VIEW1|3        |80  |
|2 |  MERGE OUTER JOIN|     |3        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE 0 END]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |119 |
|1 | SUBPLAN FILTER    |    |6        |113 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE 0 END]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |119 |
|1 | SUBPLAN FILTER    |    |6        |113 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE 0 END]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |114 |
|1 | SUBPLAN FILTER    |    |1        |113 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE 0 END]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |114 |
|1 | SUBPLAN FILTER    |    |1        |113 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([CASE WHEN t2.c2 = 0 THEN 1 ELSE 0 END]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where (case t2.c2 when 0 then 1 else 0 end) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1147629234082532 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1);
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|    |4        |129 |
|1 | MERGE OUTER JOIN    |    |6        |80  |
|2 |  TABLE SCAN         |t1  |6        |37  |
|3 |  TABLE SCAN         |t2  |6        |37  |
|4 | MATERIAL            |    |6        |38  |
|5 |  TABLE SCAN         |t1  |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([(T_OP_OR, t2.c2 <= t1.c2, (T_OP_IS, t2.c2, NULL, 0), (T_OP_IS, t1.c2, NULL, 0))]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c2]), filter(nil)
  5 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER   |    |3        |126 |
|1 | MERGE OUTER JOIN|    |6        |80  |
|2 |  TABLE SCAN     |t1  |6        |37  |
|3 |  TABLE SCAN     |t2  |6        |37  |
|4 | TABLE SCAN      |t1  |6        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1);
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1));
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |4        |130 |
|1 | SUBPLAN SCAN          |VIEW1|4        |129 |
|2 |  NESTED-LOOP ANTI JOIN|     |4        |129 |
|3 |   MERGE OUTER JOIN    |     |6        |80  |
|4 |    TABLE SCAN         |t1   |6        |37  |
|5 |    TABLE SCAN         |t2   |6        |37  |
|6 |   MATERIAL            |     |6        |38  |
|7 |    TABLE SCAN         |t1   |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([(T_OP_OR, t2.c2 <= t1.c2, (T_OP_IS, t2.c2, NULL, 0), (T_OP_IS, t1.c2, NULL, 0))]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c2]), filter(nil)
  7 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1));

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1));
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |3        |127 |
|1 | SUBPLAN SCAN      |VIEW1|3        |127 |
|2 |  SUBPLAN FILTER   |     |3        |126 |
|3 |   MERGE OUTER JOIN|     |6        |80  |
|4 |    TABLE SCAN     |t1   |6        |37  |
|5 |    TABLE SCAN     |t2   |6        |37  |
|6 |   TABLE SCAN      |t1   |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1) limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |6        |159 |
|1 | SUBPLAN FILTER         |    |6        |153 |
|2 |  TABLE SCAN            |t1  |6        |37  |
|3 |  LIMIT                 |    |1        |116 |
|4 |   NESTED-LOOP ANTI JOIN|    |1        |115 |
|5 |    MERGE OUTER JOIN    |    |2        |75  |
|6 |     TABLE SCAN         |t1  |3        |37  |
|7 |     TABLE SCAN         |t2  |3        |37  |
|8 |    MATERIAL            |    |6        |38  |
|9 |     TABLE SCAN         |t1  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([(T_OP_OR, t2.c2 <= t1.c2, (T_OP_IS, t2.c2, NULL, 0), (T_OP_IS, t1.c2, NULL, 0))]), nl_params_(nil)
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c2]), filter(nil)
  9 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |6        |161 |
|1 | SUBPLAN FILTER     |    |6        |155 |
|2 |  TABLE SCAN        |t1  |6        |37  |
|3 |  LIMIT             |    |1        |117 |
|4 |   SUBPLAN FILTER   |    |1        |117 |
|5 |    MERGE OUTER JOIN|    |2        |75  |
|6 |     TABLE SCAN     |t1  |4        |37  |
|7 |     TABLE SCAN     |t2  |4        |37  |
|8 |    TABLE SCAN      |t1  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 > ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1) limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |154 |
|1 | SUBPLAN FILTER         |    |1        |153 |
|2 |  TABLE SCAN            |t1  |1        |38  |
|3 |  LIMIT                 |    |1        |116 |
|4 |   NESTED-LOOP ANTI JOIN|    |1        |115 |
|5 |    MERGE OUTER JOIN    |    |2        |75  |
|6 |     TABLE SCAN         |t1  |3        |37  |
|7 |     TABLE SCAN         |t2  |3        |37  |
|8 |    MATERIAL            |    |6        |38  |
|9 |     TABLE SCAN         |t1  |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([(T_OP_OR, t2.c2 <= t1.c2, (T_OP_IS, t2.c2, NULL, 0), (T_OP_IS, t1.c2, NULL, 0))]), nl_params_(nil)
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c2]), filter(nil)
  9 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1354156504062622 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |155 |
|1 | SUBPLAN FILTER     |    |1        |154 |
|2 |  TABLE SCAN        |t1  |1        |38  |
|3 |  LIMIT             |    |1        |117 |
|4 |   SUBPLAN FILTER   |    |1        |117 |
|5 |    MERGE OUTER JOIN|    |2        |75  |
|6 |     TABLE SCAN     |t1  |4        |37  |
|7 |     TABLE SCAN     |t2  |4        |37  |
|8 |    TABLE SCAN      |t1  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c2 > ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where t2.c2 > all (select c2 from t1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.1354156504062622 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |3        |78  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |3        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 0, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |3        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 0, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |3        |79  |
|1 | SUBPLAN SCAN|VIEW1|3        |78  |
|2 |  MERGE JOIN |     |3        |78  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |3        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 0, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |3        |80  |
|1 | SUBPLAN SCAN     |VIEW1|3        |80  |
|2 |  MERGE OUTER JOIN|     |3        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 0, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |74  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 0, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |119 |
|1 | SUBPLAN FILTER    |    |6        |113 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 0, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |74  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 0, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |114 |
|1 | SUBPLAN FILTER    |    |1        |113 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS, t2.c1 > 2 AND t2.c2 < 4, 0, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is false limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |3        |78  |
|1 | TABLE SCAN|t1  |6        |37  |
|2 | TABLE SCAN|t2  |3        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1 > 2 AND t2.c2 < 4, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |3        |80  |
|1 | TABLE SCAN     |t1  |6        |37  |
|2 | TABLE SCAN     |t2  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1 > 2 AND t2.c2 < 4, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null;
+----+------+----+------+------+
| c1 | c2   | c1 | c2   | c3   |
+----+------+----+------+------+
|  1 |    1 |  1 |    1 | o    |
|  2 |    5 |  2 |    5 | c    |
|  3 |    2 |  3 |    5 | b    |
|  4 |    6 |  4 |    6 | o    |
|  5 |    4 |  5 |    7 | d    |
|  6 |    7 |  6 |    8 | c    |
+----+------+----+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |3        |79  |
|1 | SUBPLAN SCAN|VIEW1|3        |78  |
|2 |  MERGE JOIN |     |3        |78  |
|3 |   TABLE SCAN|t1   |6        |37  |
|4 |   TABLE SCAN|t2   |3        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1 > 2 AND t2.c2 < 4, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null);

rollback;
EXPLAIN insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |3        |80  |
|1 | SUBPLAN SCAN     |VIEW1|3        |80  |
|2 |  MERGE OUTER JOIN|     |3        |80  |
|3 |   TABLE SCAN     |t1   |6        |37  |
|4 |   TABLE SCAN     |t2   |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d, t4_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c1 > 2 AND t2.c2 < 4, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

insert into t4_temp (select /*+ NO_REWRITE*/ * from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |117 |
|1 | SUBPLAN FILTER    |    |6        |111 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |74  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([(T_OP_IS_NOT, t2.c1 > 2 AND t2.c2 < 4, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |6        |119 |
|1 | SUBPLAN FILTER    |    |6        |113 |
|2 |  TABLE SCAN       |t1  |6        |37  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t2.c1 > 2 AND t2.c2 < 4, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |112 |
|1 | SUBPLAN FILTER    |    |1        |111 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |74  |
|4 |   NESTED-LOOP JOIN|    |1        |73  |
|5 |    TABLE SCAN     |t2  |1        |37  |
|6 |    TABLE GET      |t1  |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  5 - output([t2.c1]), filter([(T_OP_IS_NOT, t2.c1 > 2 AND t2.c2 < 4, NULL, 0)]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |114 |
|1 | SUBPLAN FILTER    |    |1        |113 |
|2 |  TABLE SCAN       |t1  |1        |38  |
|3 |  LIMIT            |    |1        |75  |
|4 |   MERGE OUTER JOIN|    |1        |75  |
|5 |    TABLE SCAN     |t1  |4        |37  |
|6 |    TABLE SCAN     |t2  |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.c1, t1.c2)})}])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_IS_NOT, t2.c1 > 2 AND t2.c2 < 4, NULL, 0)]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where ((t2.c1 > 2) and (t2.c2 < 4)) is not null limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 1.7204650534085253 |
+--------------------+
rollback;

set autocommit=1;

drop table if exists t1, t2, t3, t4, t5, t6;
drop table t1_temp, t2_temp, t3_temp, t4_temp, t5_temp, t6_temp, t7_temp, t8_temp, t9_temp, t10_temp, t11_temp, t12_temp, t13_temp, t14_temp, t15_temp;
create table t1 (c1 int, c2 int);
create table t2 (c1 int, c2 int);
create table t3 (c1 int, c2 int);
create table t4 (c1 int, c2 int);
create table t5 (c1 int, c2 int);
create table t6 (c1 int, c2 int);

create table t1_temp(a int, b int, d int, e int);
create table t2_temp(a int, b int);
create table t3_temp(a int, b int, c int);
create table t4_temp(a int, b int, c int, d int);
create table t5_temp(a int, b int, c int, d int, f int, g int);
create table t6_temp(a int, b int, c int, d int, e int, f int);
create table t7_temp(a int, b int, c int, d int, f int, g int, i int, j int);
create table t8_temp(a int, b int, c int, d int);
create table t9_temp(a int, b int, c int, d int, f int, g int, i int, j int);
create table t10_temp(a int, b int, c int, d int, f int, g int, i int, j int, l int, m int);
create table t11_temp(a int, b int);
create table t12_temp(a int);
create table t13_temp(a int, b int, d int, e int);
create table t14_temp(a int, b int, c int);
create table t15_temp(a int, b int, c int, d int, f int, g int, i int, j int, l int, m int);

set autocommit=0;

EXPLAIN select * from t1 right join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |HASH OUTER JOIN|    |990      |97554|
|1 | HASH JOIN     |    |1        |75   |
|2 |  TABLE SCAN   |t2  |1        |36   |
|3 |  TABLE SCAN   |t3  |1        |36   |
|4 | TABLE SCAN    |t1  |100000   |64066|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 right join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
| NULL | NULL |    1 |    1 |    1 |    1 |
+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/ * from t1 right join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |HASH OUTER JOIN|    |990      |97554|
|1 | HASH JOIN     |    |1        |75   |
|2 |  TABLE SCAN   |t2  |1        |36   |
|3 |  TABLE SCAN   |t3  |1        |36   |
|4 | TABLE SCAN    |t1  |100000   |64066|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+NO_REWRITE*/ * from t1 right join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
| NULL | NULL |    1 |    1 |    1 |    1 |
+------+------+------+------+------+------+

## t1 is the right table for outer join,
## subquery unnest will add a invalid-null-reject condition: t3.c2 = t1.c2
EXPLAIN select * from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2);
Query Plan
==============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST |
----------------------------------------------
|0 |HASH RIGHT ANTI JOIN|    |981      |97883|
|1 | TABLE SCAN         |t3  |1        |36   |
|2 | HASH OUTER JOIN    |    |990      |97516|
|3 |  TABLE SCAN        |t2  |1        |36   |
|4 |  TABLE SCAN        |t1  |100000   |64066|
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t3.c2 = t1.c2]), other_conds(nil)
  1 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 | NULL | NULL |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/ * from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2);
Query Plan
===========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST  |
-------------------------------------------
|0 |SUBPLAN FILTER  |    |495      |133440|
|1 | HASH OUTER JOIN|    |990      |97516 |
|2 |  TABLE SCAN    |t2  |1        |36    |
|3 |  TABLE SCAN    |t1  |100000   |64066 |
|4 | TABLE SCAN     |t3  |1        |37    |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t1.c1], [t1.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t2.c1], [t2.c2], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([1]), filter([t3.c2 = ?]), 
      access([t3.c2]), partitions(p0)

select /*+NO_REWRITE*/ * from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 | NULL | NULL |
+------+------+------+------+
EXPLAIN insert into t1_temp (select * from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2));
Query Plan
=================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST |
-------------------------------------------------
|0 |INSERT                |     |981      |98154|
|1 | SUBPLAN SCAN         |VIEW1|981      |98019|
|2 |  HASH RIGHT ANTI JOIN|     |981      |97883|
|3 |   TABLE SCAN         |t3   |1        |36   |
|4 |   HASH OUTER JOIN    |     |990      |97516|
|5 |    TABLE SCAN        |t2   |1        |36   |
|6 |    TABLE SCAN        |t1   |100000   |64066|
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t3.c2 = t1.c2]), other_conds(nil)
  3 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select * from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2));

rollback;
EXPLAIN insert into t1_temp (select /*+NO_REWRITE*/ * from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2));
Query Plan
==============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST  |
----------------------------------------------
|0 |INSERT            |     |495      |133577|
|1 | SUBPLAN SCAN     |VIEW1|495      |133509|
|2 |  SUBPLAN FILTER  |     |495      |133440|
|3 |   HASH OUTER JOIN|     |990      |97516 |
|4 |    TABLE SCAN    |t2   |1        |36    |
|5 |    TABLE SCAN    |t1   |100000   |64066 |
|6 |   TABLE SCAN     |t3   |1        |37    |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t1.c1], [t1.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t2.c1], [t2.c2], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([1]), filter([t3.c2 = ?]), 
      access([t3.c2]), partitions(p0)

insert into t1_temp (select /*+NO_REWRITE*/ * from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
Query Plan
==================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST  |
--------------------------------------------------
|0 |UPDATE                 |    |100000   |178069|
|1 | SUBPLAN FILTER        |    |100000   |78069 |
|2 |  TABLE SCAN           |t1  |100000   |64066 |
|3 |  LIMIT                |    |1        |201   |
|4 |   HASH RIGHT ANTI JOIN|    |1        |201   |
|5 |    TABLE SCAN         |t3  |1        |36    |
|6 |    HASH OUTER JOIN    |    |2        |164   |
|7 |     TABLE SCAN        |t2  |1        |36    |
|8 |     TABLE SCAN        |t1  |103      |93    |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t3.c2 = t1.c2]), other_conds(nil)
  5 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |96858|
|1 | TABLE SCAN    |t1  |100000   |61860|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+NO_REWRITE*/t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
Query Plan
==============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST  |
----------------------------------------------
|0 |UPDATE             |    |100000   |178194|
|1 | SUBPLAN FILTER    |    |100000   |78194 |
|2 |  TABLE SCAN       |t1  |100000   |64066 |
|3 |  LIMIT            |    |1        |326   |
|4 |   SUBPLAN FILTER  |    |1        |326   |
|5 |    HASH OUTER JOIN|    |2        |254   |
|6 |     TABLE SCAN    |t2  |1        |36    |
|7 |     TABLE SCAN    |t1  |203      |149   |
|8 |    TABLE SCAN     |t3  |1        |37    |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([1]), filter([t3.c2 = ?]), 
      access([t3.c2]), partitions(p0)

update t1 set c2 = (select /*+NO_REWRITE*/t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |96858|
|1 | TABLE SCAN    |t1  |100000   |61860|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
Query Plan
=================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST |
-------------------------------------------------
|0 |DELETE                 |    |990      |73766|
|1 | SUBPLAN FILTER        |    |990      |72776|
|2 |  TABLE SCAN           |t1  |990      |72438|
|3 |  LIMIT                |    |1        |201  |
|4 |   HASH RIGHT ANTI JOIN|    |1        |201  |
|5 |    TABLE SCAN         |t3  |1        |36   |
|6 |    HASH OUTER JOIN    |    |2        |164  |
|7 |     TABLE SCAN        |t2  |1        |36   |
|8 |     TABLE SCAN        |t1  |103      |93   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t3.c2 = t1.c2]), other_conds(nil)
  5 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |96858|
|1 | TABLE SCAN    |t1  |100000   |61860|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+NO_REWRITE*/t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
Query Plan
=============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST |
---------------------------------------------
|0 |DELETE             |    |990      |73891|
|1 | SUBPLAN FILTER    |    |990      |72901|
|2 |  TABLE SCAN       |t1  |990      |72438|
|3 |  LIMIT            |    |1        |326  |
|4 |   SUBPLAN FILTER  |    |1        |326  |
|5 |    HASH OUTER JOIN|    |2        |254  |
|6 |     TABLE SCAN    |t2  |1        |36   |
|7 |     TABLE SCAN    |t1  |203      |149  |
|8 |    TABLE SCAN     |t3  |1        |37   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([1]), filter([t3.c2 = ?]), 
      access([t3.c2]), partitions(p0)

delete from t1 where c2 = (select /*+NO_REWRITE*/t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where not exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |96858|
|1 | TABLE SCAN    |t1  |100000   |61860|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;

EXPLAIN select * from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2);
Query Plan
===============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST |
-----------------------------------------------
|0 |HASH JOIN            |    |10       |97874|
|1 | TABLE SCAN          |t2  |1        |36   |
|2 | HASH RIGHT SEMI JOIN|    |981      |97509|
|3 |  TABLE SCAN         |t3  |1        |36   |
|4 |  TABLE SCAN         |t1  |100000   |64066|
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t3.c2 = t1.c2]), other_conds(nil)
  3 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/ * from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2);
Query Plan
===========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST  |
-------------------------------------------
|0 |SUBPLAN FILTER  |    |495      |133440|
|1 | HASH OUTER JOIN|    |990      |97516 |
|2 |  TABLE SCAN    |t2  |1        |36    |
|3 |  TABLE SCAN    |t1  |100000   |64066 |
|4 | TABLE SCAN     |t3  |1        |37    |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t1.c1], [t1.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t2.c1], [t2.c2], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([1]), filter([t3.c2 = ?]), 
      access([t3.c2]), partitions(p0)

select /*+NO_REWRITE*/ * from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
+------+------+------+------+
EXPLAIN insert into t1_temp (select * from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2));
Query Plan
==================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST |
--------------------------------------------------
|0 |INSERT                 |     |10       |97877|
|1 | SUBPLAN SCAN          |VIEW1|10       |97876|
|2 |  HASH JOIN            |     |10       |97874|
|3 |   TABLE SCAN          |t2   |1        |36   |
|4 |   HASH RIGHT SEMI JOIN|     |981      |97509|
|5 |    TABLE SCAN         |t3   |1        |36   |
|6 |    TABLE SCAN         |t1   |100000   |64066|
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t3.c2 = t1.c2]), other_conds(nil)
  5 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t1_temp (select * from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2));

rollback;
EXPLAIN insert into t1_temp (select /*+NO_REWRITE*/ * from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2));
Query Plan
==============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST  |
----------------------------------------------
|0 |INSERT            |     |495      |133577|
|1 | SUBPLAN SCAN     |VIEW1|495      |133509|
|2 |  SUBPLAN FILTER  |     |495      |133440|
|3 |   HASH OUTER JOIN|     |990      |97516 |
|4 |    TABLE SCAN    |t2   |1        |36    |
|5 |    TABLE SCAN    |t1   |100000   |64066 |
|6 |   TABLE SCAN     |t3   |1        |37    |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t1_temp: ({t1_temp: (t1_temp.__pk_increment, t1_temp.a, t1_temp.b, t1_temp.d, t1_temp.e)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t2.c1], [t2.c2], [t1.c1], [t1.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t2.c1], [t2.c2], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([1]), filter([t3.c2 = ?]), 
      access([t3.c2]), partitions(p0)

insert into t1_temp (select /*+NO_REWRITE*/ * from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
Query Plan
===================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST  |
---------------------------------------------------
|0 |UPDATE                  |    |100000   |188027|
|1 | SUBPLAN FILTER         |    |100000   |88027 |
|2 |  TABLE SCAN            |t1  |100000   |64066 |
|3 |  LIMIT                 |    |1        |10160 |
|4 |   HASH JOIN            |    |1        |10160 |
|5 |    TABLE SCAN          |t2  |1        |36    |
|6 |    HASH RIGHT SEMI JOIN|    |102      |10089 |
|7 |     TABLE SCAN         |t3  |1        |36    |
|8 |     TABLE SCAN         |t1  |10307    |6609  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t3.c2 = t1.c2]), other_conds(nil)
  7 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |96858|
|1 | TABLE SCAN    |t1  |100000   |61860|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+NO_REWRITE*/t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
Query Plan
==============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST  |
----------------------------------------------
|0 |UPDATE             |    |100000   |178194|
|1 | SUBPLAN FILTER    |    |100000   |78194 |
|2 |  TABLE SCAN       |t1  |100000   |64066 |
|3 |  LIMIT            |    |1        |326   |
|4 |   SUBPLAN FILTER  |    |1        |326   |
|5 |    HASH OUTER JOIN|    |2        |254   |
|6 |     TABLE SCAN    |t2  |1        |36    |
|7 |     TABLE SCAN    |t1  |203      |149   |
|8 |    TABLE SCAN     |t3  |1        |37    |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([1]), filter([t3.c2 = ?]), 
      access([t3.c2]), partitions(p0)

update t1 set c2 = (select /*+NO_REWRITE*/t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |96858|
|1 | TABLE SCAN    |t1  |100000   |61860|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST |
--------------------------------------------------
|0 |DELETE                  |    |990      |83724|
|1 | SUBPLAN FILTER         |    |990      |82734|
|2 |  TABLE SCAN            |t1  |990      |72438|
|3 |  LIMIT                 |    |1        |10160|
|4 |   HASH JOIN            |    |1        |10160|
|5 |    TABLE SCAN          |t2  |1        |36   |
|6 |    HASH RIGHT SEMI JOIN|    |102      |10089|
|7 |     TABLE SCAN         |t3  |1        |36   |
|8 |     TABLE SCAN         |t1  |10307    |6609 |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t3.c2 = t1.c2]), other_conds(nil)
  7 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |96858|
|1 | TABLE SCAN    |t1  |100000   |61860|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+NO_REWRITE*/t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
Query Plan
=============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST |
---------------------------------------------
|0 |DELETE             |    |990      |73891|
|1 | SUBPLAN FILTER    |    |990      |72901|
|2 |  TABLE SCAN       |t1  |990      |72438|
|3 |  LIMIT            |    |1        |326  |
|4 |   SUBPLAN FILTER  |    |1        |326  |
|5 |    HASH OUTER JOIN|    |2        |254  |
|6 |     TABLE SCAN    |t2  |1        |36   |
|7 |     TABLE SCAN    |t1  |203      |149  |
|8 |    TABLE SCAN     |t3  |1        |37   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([1]), filter([t3.c2 = ?]), 
      access([t3.c2]), partitions(p0)

delete from t1 where c2 = (select /*+NO_REWRITE*/t1.c1 from t2 left join t1 on t1.c1 = t2.c1 where exists (select 1 from t3 where t3.c2 = t1.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |96858|
|1 | TABLE SCAN    |t1  |100000   |61860|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;

set autocommit=1;

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({1, 1})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({NULL, 1})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({5, 5})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({NULL, 5})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({10, 10})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({2, 2})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({3, 2})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({4, 2})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t2: ({t2: (t2.__pk_increment, t2.c1, t2.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({2, 2})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t2: ({t2: (t2.__pk_increment, t2.c1, t2.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({NULL, 2})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t2: ({t2: (t2.__pk_increment, t2.c1, t2.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({6, 6})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t2: ({t2: (t2.__pk_increment, t2.c1, t2.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({NULL, 6})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t2: ({t2: (t2.__pk_increment, t2.c1, t2.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({NULL, NULL})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t2: ({t2: (t2.__pk_increment, t2.c1, t2.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({1, 1})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t2: ({t2: (t2.__pk_increment, t2.c1, t2.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({3, 3})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t2: ({t2: (t2.__pk_increment, t2.c1, t2.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({4, 4})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t3: ({t3: (t3.__pk_increment, t3.c1, t3.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({3, 3})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t3: ({t3: (t3.__pk_increment, t3.c1, t3.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({NULL, 3})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t3: ({t3: (t3.__pk_increment, t3.c1, t3.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({7, 7})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t3: ({t3: (t3.__pk_increment, t3.c1, t3.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({NULL, 7})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t3: ({t3: (t3.__pk_increment, t3.c1, t3.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({7, 7})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t3: ({t3: (t3.__pk_increment, t3.c1, t3.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({4, 4})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t3: ({t3: (t3.__pk_increment, t3.c1, t3.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({5, 5})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t4: ({t4: (t4.__pk_increment, t4.c1, t4.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({4, 4})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t4: ({t4: (t4.__pk_increment, t4.c1, t4.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({NULL, 4})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t4: ({t4: (t4.__pk_increment, t4.c1, t4.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({8, 8})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t4: ({t4: (t4.__pk_increment, t4.c1, t4.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({NULL, 8})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t4: ({t4: (t4.__pk_increment, t4.c1, t4.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({8, 8})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t4: ({t4: (t4.__pk_increment, t4.c1, t4.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({1, 1})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t4: ({t4: (t4.__pk_increment, t4.c1, t4.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({2, 2})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t4: ({t4: (t4.__pk_increment, t4.c1, t4.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({3, 3})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t5: ({t5: (t5.__pk_increment, t5.c1, t5.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({1, 1})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t5: ({t5: (t5.__pk_increment, t5.c1, t5.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({2, 2})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t5: ({t5: (t5.__pk_increment, t5.c1, t5.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({3, 3})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t5: ({t5: (t5.__pk_increment, t5.c1, t5.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({4, 4})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t5: ({t5: (t5.__pk_increment, t5.c1, t5.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({NULL, NULL})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t6: ({t6: (t6.__pk_increment, t6.c1, t6.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({1, NULL})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t6: ({t6: (t6.__pk_increment, t6.c1, t6.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({2, NULL})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t6: ({t6: (t6.__pk_increment, t6.c1, t6.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({3, NULL})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t6: ({t6: (t6.__pk_increment, t6.c1, t6.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({4, NULL})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)]), filter(nil), 
      columns([{t6: ({t6: (t6.__pk_increment, t6.c1, t6.c2)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2]), filter(nil)
      values({5, NULL})

set autocommit=0;

EXPLAIN select * from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1);
Query Plan
=========================================================
|ID|OPERATOR                       |NAME |EST. ROWS|COST|
---------------------------------------------------------
|0 |NESTED-LOOP SEMI JOIN CARTESIAN|     |1        |119 |
|1 | TABLE SCAN                    |t1   |1        |39  |
|2 | MATERIAL                      |     |1        |79  |
|3 |  SUBPLAN SCAN                 |VIEW1|1        |79  |
|4 |   NESTED-LOOP JOIN CARTESIAN  |     |1        |79  |
|5 |    TABLE SCAN                 |t2   |1        |39  |
|6 |    MATERIAL                   |     |1        |39  |
|7 |     TABLE SCAN                |t3   |1        |39  |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter([t1.c1 = 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil)
  3 - output([1]), filter(nil), 
      access(nil)
  4 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([t2.c1 = 11]), 
      access([t2.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter([t3.c1 = 11]), 
      access([t3.c1]), partitions(p0)

select * from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select /*+no_rewrite*/* from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1);
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |SUBPLAN FILTER        |    |4        |777 |
|1 | TABLE SCAN           |t1  |8        |38  |
|2 | HASH RIGHT OUTER JOIN|    |9        |92  |
|3 |  TABLE SCAN          |t3  |8        |38  |
|4 |  TABLE SCAN          |t2  |9        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([11 = ANY(subquery(1))]), 
      exec_params_([t1.c1 = 1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t3.c1]), filter(nil), startup_filter([?]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select /*+no_rewrite*/* from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN insert into t11_temp (select * from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1));
Query Plan
===========================================================
|ID|OPERATOR                         |NAME |EST. ROWS|COST|
-----------------------------------------------------------
|0 |INSERT                           |     |1        |119 |
|1 | SUBPLAN SCAN                    |VIEW1|1        |119 |
|2 |  NESTED-LOOP SEMI JOIN CARTESIAN|     |1        |119 |
|3 |   TABLE SCAN                    |t1   |1        |39  |
|4 |   MATERIAL                      |     |1        |79  |
|5 |    SUBPLAN SCAN                 |VIEW2|1        |79  |
|6 |     NESTED-LOOP JOIN CARTESIAN  |     |1        |79  |
|7 |      TABLE SCAN                 |t2   |1        |39  |
|8 |      MATERIAL                   |     |1        |39  |
|9 |       TABLE SCAN                |t3   |1        |39  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter([t1.c1 = 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([1]), filter(nil)
  5 - output([1]), filter(nil), 
      access(nil)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter([t2.c1 = 11]), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter([t3.c1 = 11]), 
      access([t3.c1]), partitions(p0)

insert into t11_temp (select * from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1));

rollback;
EXPLAIN insert into t11_temp (select /*+no_rewrite*/* from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |4        |778 |
|1 | SUBPLAN SCAN           |VIEW1|4        |778 |
|2 |  SUBPLAN FILTER        |     |4        |777 |
|3 |   TABLE SCAN           |t1   |8        |38  |
|4 |   HASH RIGHT OUTER JOIN|     |9        |92  |
|5 |    TABLE SCAN          |t3   |8        |38  |
|6 |    TABLE SCAN          |t2   |9        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2]), filter([11 = ANY(subquery(1))]), 
      exec_params_([t1.c1 = 1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1]), filter(nil), startup_filter([?]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

insert into t11_temp (select /*+no_rewrite*/* from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1) limit 1);
Query Plan
============================================================
|ID|OPERATOR                          |NAME |EST. ROWS|COST|
------------------------------------------------------------
|0 |UPDATE                            |     |8        |165 |
|1 | SUBPLAN FILTER                   |     |8        |157 |
|2 |  TABLE SCAN                      |t1   |8        |38  |
|3 |  LIMIT                           |     |1        |119 |
|4 |   NESTED-LOOP SEMI JOIN CARTESIAN|     |1        |118 |
|5 |    TABLE SCAN                    |t1   |1        |39  |
|6 |    MATERIAL                      |     |1        |79  |
|7 |     SUBPLAN SCAN                 |VIEW1|1        |79  |
|8 |      NESTED-LOOP JOIN CARTESIAN  |     |1        |79  |
|9 |       TABLE SCAN                 |t2   |1        |39  |
|10|       MATERIAL                   |     |1        |39  |
|11|        TABLE SCAN                |t3   |1        |39  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter([t1.c1 = 1]), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access(nil)
  8 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  9 - output([1]), filter([t2.c1 = 11]), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter([t3.c1 = 11]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+no_rewrite*/t1.c1 from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |8        |268 |
|1 | SUBPLAN FILTER          |    |8        |260 |
|2 |  TABLE SCAN             |t1  |8        |38  |
|3 |  LIMIT                  |    |1        |222 |
|4 |   SUBPLAN FILTER        |    |1        |221 |
|5 |    TABLE SCAN           |t1  |2        |37  |
|6 |    HASH RIGHT OUTER JOIN|    |9        |92  |
|7 |     TABLE SCAN          |t3  |8        |38  |
|8 |     TABLE SCAN          |t2  |9        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([11 = ANY(subquery(1))]), 
      exec_params_([t1.c1 = 1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t3.c1]), filter(nil), startup_filter([?]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+no_rewrite*/t1.c1 from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1) limit 1);
Query Plan
============================================================
|ID|OPERATOR                          |NAME |EST. ROWS|COST|
------------------------------------------------------------
|0 |DELETE                            |     |1        |158 |
|1 | SUBPLAN FILTER                   |     |1        |157 |
|2 |  TABLE SCAN                      |t1   |1        |39  |
|3 |  LIMIT                           |     |1        |119 |
|4 |   NESTED-LOOP SEMI JOIN CARTESIAN|     |1        |118 |
|5 |    TABLE SCAN                    |t1   |1        |39  |
|6 |    MATERIAL                      |     |1        |79  |
|7 |     SUBPLAN SCAN                 |VIEW1|1        |79  |
|8 |      NESTED-LOOP JOIN CARTESIAN  |     |1        |79  |
|9 |       TABLE SCAN                 |t2   |1        |39  |
|10|       MATERIAL                   |     |1        |39  |
|11|        TABLE SCAN                |t3   |1        |39  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter([t1.c1 = 1]), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access(nil)
  8 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  9 - output([1]), filter([t2.c1 = 11]), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter([t3.c1 = 11]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+no_rewrite*/t1.c1 from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |261 |
|1 | SUBPLAN FILTER          |    |1        |260 |
|2 |  TABLE SCAN             |t1  |1        |39  |
|3 |  LIMIT                  |    |1        |222 |
|4 |   SUBPLAN FILTER        |    |1        |221 |
|5 |    TABLE SCAN           |t1  |2        |37  |
|6 |    HASH RIGHT OUTER JOIN|    |9        |92  |
|7 |     TABLE SCAN          |t3  |8        |38  |
|8 |     TABLE SCAN          |t2  |9        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([11 = ANY(subquery(1))]), 
      exec_params_([t1.c1 = 1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t3.c1]), filter(nil), startup_filter([?]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+no_rewrite*/t1.c1 from t1 where (11) in (select t3.c1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1 = 1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |HASH RIGHT SEMI JOIN|    |8        |146 |
|1 | TABLE SCAN         |t3  |8        |38  |
|2 | HASH JOIN          |    |8        |93  |
|3 |  TABLE SCAN        |t1  |8        |38  |
|4 |  TABLE SCAN        |t2  |9        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  1 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |4        |399 |
|1 | HASH OUTER JOIN|    |8        |93  |
|2 |  TABLE SCAN    |t1  |8        |38  |
|3 |  TABLE SCAN    |t2  |9        |38  |
|4 | TABLE SCAN     |t3  |1        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1));
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |INSERT                |     |8        |148 |
|1 | SUBPLAN SCAN         |VIEW1|8        |147 |
|2 |  HASH RIGHT SEMI JOIN|     |8        |146 |
|3 |   TABLE SCAN         |t3   |8        |38  |
|4 |   HASH JOIN          |     |8        |93  |
|5 |    TABLE SCAN        |t1   |8        |38  |
|6 |    TABLE SCAN        |t2   |9        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |4        |400 |
|1 | SUBPLAN SCAN     |VIEW1|4        |399 |
|2 |  SUBPLAN FILTER  |     |4        |399 |
|3 |   HASH OUTER JOIN|     |8        |93  |
|4 |    TABLE SCAN    |t1   |8        |38  |
|5 |    TABLE SCAN    |t2   |9        |38  |
|6 |   TABLE SCAN     |t3   |1        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |UPDATE                 |    |8        |177 |
|1 | SUBPLAN FILTER        |    |8        |169 |
|2 |  TABLE SCAN           |t1  |8        |38  |
|3 |  LIMIT                |    |1        |131 |
|4 |   HASH RIGHT SEMI JOIN|    |1        |130 |
|5 |    TABLE SCAN         |t3  |8        |38  |
|6 |    HASH JOIN          |    |2        |84  |
|7 |     TABLE SCAN        |t1  |8        |38  |
|8 |     TABLE SCAN        |t2  |2        |36  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |8        |207 |
|1 | SUBPLAN FILTER    |    |8        |199 |
|2 |  TABLE SCAN       |t1  |8        |38  |
|3 |  LIMIT            |    |1        |161 |
|4 |   SUBPLAN FILTER  |    |1        |161 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |1        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |DELETE                 |    |1        |170 |
|1 | SUBPLAN FILTER        |    |1        |169 |
|2 |  TABLE SCAN           |t1  |1        |39  |
|3 |  LIMIT                |    |1        |131 |
|4 |   HASH RIGHT SEMI JOIN|    |1        |130 |
|5 |    TABLE SCAN         |t3  |8        |38  |
|6 |    HASH JOIN          |    |2        |84  |
|7 |     TABLE SCAN        |t1  |8        |38  |
|8 |     TABLE SCAN        |t2  |2        |36  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |200 |
|1 | SUBPLAN FILTER    |    |1        |199 |
|2 |  TABLE SCAN       |t1  |1        |39  |
|3 |  LIMIT            |    |1        |161 |
|4 |   SUBPLAN FILTER  |    |1        |161 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |1        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |HASH RIGHT SEMI JOIN|    |8        |147 |
|1 | TABLE SCAN         |t3  |8        |38  |
|2 | HASH OUTER JOIN    |    |8        |93  |
|3 |  TABLE SCAN        |t1  |8        |38  |
|4 |  TABLE SCAN        |t2  |9        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
|    5 |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |4        |399 |
|1 | HASH OUTER JOIN|    |8        |93  |
|2 |  TABLE SCAN    |t1  |8        |38  |
|3 |  TABLE SCAN    |t2  |9        |38  |
|4 | TABLE SCAN     |t3  |1        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
|    5 |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1));
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |INSERT                |     |8        |149 |
|1 | SUBPLAN SCAN         |VIEW1|8        |148 |
|2 |  HASH RIGHT SEMI JOIN|     |8        |147 |
|3 |   TABLE SCAN         |t3   |8        |38  |
|4 |   HASH OUTER JOIN    |     |8        |93  |
|5 |    TABLE SCAN        |t1   |8        |38  |
|6 |    TABLE SCAN        |t2   |9        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |4        |400 |
|1 | SUBPLAN SCAN     |VIEW1|4        |399 |
|2 |  SUBPLAN FILTER  |     |4        |399 |
|3 |   HASH OUTER JOIN|     |8        |93  |
|4 |    TABLE SCAN    |t1   |8        |38  |
|5 |    TABLE SCAN    |t2   |9        |38  |
|6 |   TABLE SCAN     |t3   |1        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1) limit 1);
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |UPDATE                 |    |8        |177 |
|1 | SUBPLAN FILTER        |    |8        |169 |
|2 |  TABLE SCAN           |t1  |8        |38  |
|3 |  LIMIT                |    |1        |130 |
|4 |   HASH RIGHT SEMI JOIN|    |1        |130 |
|5 |    TABLE SCAN         |t3  |8        |38  |
|6 |    HASH OUTER JOIN    |    |1        |83  |
|7 |     TABLE SCAN        |t1  |8        |38  |
|8 |     TABLE SCAN        |t2  |2        |36  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |8        |207 |
|1 | SUBPLAN FILTER    |    |8        |199 |
|2 |  TABLE SCAN       |t1  |8        |38  |
|3 |  LIMIT            |    |1        |161 |
|4 |   SUBPLAN FILTER  |    |1        |161 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |1        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1) limit 1);
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |DELETE                 |    |1        |170 |
|1 | SUBPLAN FILTER        |    |1        |169 |
|2 |  TABLE SCAN           |t1  |1        |39  |
|3 |  LIMIT                |    |1        |130 |
|4 |   HASH RIGHT SEMI JOIN|    |1        |130 |
|5 |    TABLE SCAN         |t3  |8        |38  |
|6 |    HASH OUTER JOIN    |    |1        |83  |
|7 |     TABLE SCAN        |t1  |8        |38  |
|8 |     TABLE SCAN        |t2  |2        |36  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |200 |
|1 | SUBPLAN FILTER    |    |1        |199 |
|2 |  TABLE SCAN       |t1  |1        |39  |
|3 |  LIMIT            |    |1        |161 |
|4 |   SUBPLAN FILTER  |    |1        |161 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |1        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t1.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1);
Query Plan
==============================================
|ID|OPERATOR            |NAME |EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT SEMI JOIN|     |8        |146 |
|1 | SUBPLAN SCAN       |VIEW1|8        |93  |
|2 |  HASH JOIN         |     |8        |92  |
|3 |   TABLE SCAN       |t3   |8        |38  |
|4 |   TABLE SCAN       |t2   |9        |38  |
|5 | TABLE SCAN         |t1   |8        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t3.c1]), other_conds(nil)
  1 - output([VIEW1.t3.c1]), filter(nil), 
      access([VIEW1.t3.c1])
  2 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1);
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    3 |    2 |
|    4 |    2 |
+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |4        |655 |
|1 | TABLE SCAN                |t1  |8        |38  |
|2 | NESTED-LOOP JOIN CARTESIAN|    |1        |77  |
|3 |  TABLE SCAN               |t2  |1        |39  |
|4 |  MATERIAL                 |    |1        |39  |
|5 |   TABLE SCAN              |t3  |1        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  4 - output([1]), filter(nil)
  5 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1);
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    3 |    2 |
|    4 |    2 |
+------+------+
EXPLAIN insert into t11_temp (select * from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1));
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |INSERT                |     |8        |148 |
|1 | SUBPLAN SCAN         |VIEW1|8        |147 |
|2 |  HASH RIGHT SEMI JOIN|     |8        |146 |
|3 |   SUBPLAN SCAN       |VIEW2|8        |93  |
|4 |    HASH JOIN         |     |8        |92  |
|5 |     TABLE SCAN       |t3   |8        |38  |
|6 |     TABLE SCAN       |t2   |9        |38  |
|7 |   TABLE SCAN         |t1   |8        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.t3.c1]), other_conds(nil)
  3 - output([VIEW2.t3.c1]), filter(nil), 
      access([VIEW2.t3.c1])
  4 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t11_temp (select * from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1));

rollback;
EXPLAIN insert into t11_temp (select /*+NO_REWRITE*/* from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1));
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |4        |656 |
|1 | SUBPLAN SCAN                |VIEW1|4        |656 |
|2 |  SUBPLAN FILTER             |     |4        |655 |
|3 |   TABLE SCAN                |t1   |8        |38  |
|4 |   NESTED-LOOP JOIN CARTESIAN|     |1        |77  |
|5 |    TABLE SCAN               |t2   |1        |39  |
|6 |    MATERIAL                 |     |1        |39  |
|7 |     TABLE SCAN              |t3   |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

insert into t11_temp (select /*+NO_REWRITE*/* from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE            |     |8        |184 |
|1 | SUBPLAN FILTER   |     |8        |176 |
|2 |  TABLE SCAN      |t1   |8        |38  |
|3 |  LIMIT           |     |1        |138 |
|4 |   MERGE SEMI JOIN|     |1        |138 |
|5 |    SORT          |     |3        |44  |
|6 |     TABLE SCAN   |t1   |8        |38  |
|7 |    SUBPLAN SCAN  |VIEW1|3        |92  |
|8 |     MERGE JOIN   |     |3        |92  |
|9 |      SORT        |     |6        |45  |
|10|       TABLE SCAN |t2   |9        |38  |
|11|      SORT        |     |5        |44  |
|12|       TABLE SCAN |t3   |8        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t3.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([VIEW1.t3.c1]), filter(nil), 
      access([VIEW1.t3.c1])
  8 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |8        |238 |
|1 | SUBPLAN FILTER               |    |8        |230 |
|2 |  TABLE SCAN                  |t1  |8        |38  |
|3 |  LIMIT                       |    |1        |191 |
|4 |   SUBPLAN FILTER             |    |1        |191 |
|5 |    TABLE SCAN                |t1  |2        |37  |
|6 |    NESTED-LOOP JOIN CARTESIAN|    |1        |77  |
|7 |     TABLE SCAN               |t2  |1        |39  |
|8 |     MATERIAL                 |    |1        |39  |
|9 |      TABLE SCAN              |t3  |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |DELETE            |     |1        |177 |
|1 | SUBPLAN FILTER   |     |1        |176 |
|2 |  TABLE SCAN      |t1   |1        |39  |
|3 |  LIMIT           |     |1        |138 |
|4 |   MERGE SEMI JOIN|     |1        |138 |
|5 |    SORT          |     |3        |44  |
|6 |     TABLE SCAN   |t1   |8        |38  |
|7 |    SUBPLAN SCAN  |VIEW1|3        |92  |
|8 |     MERGE JOIN   |     |3        |92  |
|9 |      SORT        |     |6        |45  |
|10|       TABLE SCAN |t2   |9        |38  |
|11|      SORT        |     |5        |44  |
|12|       TABLE SCAN |t3   |8        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t3.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([VIEW1.t3.c1]), filter(nil), 
      access([VIEW1.t3.c1])
  8 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |230 |
|1 | SUBPLAN FILTER               |    |1        |229 |
|2 |  TABLE SCAN                  |t1  |1        |39  |
|3 |  LIMIT                       |    |1        |191 |
|4 |   SUBPLAN FILTER             |    |1        |191 |
|5 |    TABLE SCAN                |t1  |2        |37  |
|6 |    NESTED-LOOP JOIN CARTESIAN|    |1        |77  |
|7 |     TABLE SCAN               |t2  |1        |39  |
|8 |     MATERIAL                 |    |1        |39  |
|9 |      TABLE SCAN              |t3  |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |HASH RIGHT SEMI JOIN   |     |8        |147 |
|1 | SUBPLAN SCAN          |VIEW1|9        |93  |
|2 |  HASH RIGHT OUTER JOIN|     |9        |92  |
|3 |   TABLE SCAN          |t3   |8        |38  |
|4 |   TABLE SCAN          |t2   |9        |38  |
|5 | TABLE SCAN            |t1   |8        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  1 - output([VIEW1.t2.c1]), filter(nil), 
      access([VIEW1.t2.c1])
  2 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1);
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    2 |
|    4 |    2 |
+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER   |    |4        |655 |
|1 | TABLE SCAN      |t1  |8        |38  |
|2 | MERGE OUTER JOIN|    |1        |77  |
|3 |  TABLE SCAN     |t2  |1        |39  |
|4 |  TABLE SCAN     |t3  |1        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t2.c1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  4 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1);
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    2 |
|    4 |    2 |
+------+------+
EXPLAIN insert into t11_temp (select * from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1));
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |8        |150 |
|1 | SUBPLAN SCAN            |VIEW1|8        |149 |
|2 |  HASH RIGHT SEMI JOIN   |     |8        |147 |
|3 |   SUBPLAN SCAN          |VIEW2|9        |93  |
|4 |    HASH RIGHT OUTER JOIN|     |9        |92  |
|5 |     TABLE SCAN          |t3   |8        |38  |
|6 |     TABLE SCAN          |t2   |9        |38  |
|7 |   TABLE SCAN            |t1   |8        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.t2.c1]), other_conds(nil)
  3 - output([VIEW2.t2.c1]), filter(nil), 
      access([VIEW2.t2.c1])
  4 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t11_temp (select * from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1));

rollback;
EXPLAIN insert into t11_temp (select /*+NO_REWRITE*/* from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1));
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |4        |656 |
|1 | SUBPLAN SCAN      |VIEW1|4        |656 |
|2 |  SUBPLAN FILTER   |     |4        |655 |
|3 |   TABLE SCAN      |t1   |8        |38  |
|4 |   MERGE OUTER JOIN|     |1        |77  |
|5 |    TABLE SCAN     |t2   |1        |39  |
|6 |    TABLE SCAN     |t3   |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t2.c1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  6 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

insert into t11_temp (select /*+NO_REWRITE*/* from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |UPDATE               |     |8        |184 |
|1 | SUBPLAN FILTER      |     |8        |176 |
|2 |  TABLE SCAN         |t1   |8        |38  |
|3 |  LIMIT              |     |1        |138 |
|4 |   MERGE SEMI JOIN   |     |1        |138 |
|5 |    SORT             |     |3        |44  |
|6 |     TABLE SCAN      |t1   |8        |38  |
|7 |    SUBPLAN SCAN     |VIEW1|4        |92  |
|8 |     MERGE OUTER JOIN|     |4        |91  |
|9 |      SORT           |     |6        |45  |
|10|       TABLE SCAN    |t2   |9        |38  |
|11|      SORT           |     |5        |44  |
|12|       TABLE SCAN    |t3   |8        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([VIEW1.t2.c1]), filter(nil), 
      access([VIEW1.t2.c1])
  8 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |8        |238 |
|1 | SUBPLAN FILTER     |    |8        |230 |
|2 |  TABLE SCAN        |t1  |8        |38  |
|3 |  LIMIT             |    |1        |191 |
|4 |   SUBPLAN FILTER   |    |1        |191 |
|5 |    TABLE SCAN      |t1  |2        |37  |
|6 |    MERGE OUTER JOIN|    |1        |77  |
|7 |     TABLE SCAN     |t2  |1        |39  |
|8 |     TABLE SCAN     |t3  |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t2.c1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |DELETE               |     |1        |177 |
|1 | SUBPLAN FILTER      |     |1        |176 |
|2 |  TABLE SCAN         |t1   |1        |39  |
|3 |  LIMIT              |     |1        |138 |
|4 |   MERGE SEMI JOIN   |     |1        |138 |
|5 |    SORT             |     |3        |44  |
|6 |     TABLE SCAN      |t1   |8        |38  |
|7 |    SUBPLAN SCAN     |VIEW1|4        |92  |
|8 |     MERGE OUTER JOIN|     |4        |91  |
|9 |      SORT           |     |6        |45  |
|10|       TABLE SCAN    |t2   |9        |38  |
|11|      SORT           |     |5        |44  |
|12|       TABLE SCAN    |t3   |8        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([VIEW1.t2.c1]), filter(nil), 
      access([VIEW1.t2.c1])
  8 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |230 |
|1 | SUBPLAN FILTER     |    |1        |229 |
|2 |  TABLE SCAN        |t1  |1        |39  |
|3 |  LIMIT             |    |1        |191 |
|4 |   SUBPLAN FILTER   |    |1        |191 |
|5 |    TABLE SCAN      |t1  |2        |37  |
|6 |    MERGE OUTER JOIN|    |1        |77  |
|7 |     TABLE SCAN     |t2  |1        |39  |
|8 |     TABLE SCAN     |t3  |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t2.c1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1);
Query Plan
==============================================
|ID|OPERATOR            |NAME |EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT ANTI JOIN|     |0        |146 |
|1 | SUBPLAN SCAN       |VIEW1|8        |93  |
|2 |  HASH JOIN         |     |8        |92  |
|3 |   TABLE SCAN       |t3   |8        |38  |
|4 |   TABLE SCAN       |t2   |9        |38  |
|5 | TABLE SCAN         |t1   |8        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t3.c1]), other_conds(nil)
  1 - output([VIEW1.t3.c1]), filter(nil), 
      access([VIEW1.t3.c1])
  2 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1);
+------+------+
| c1   | c2   |
+------+------+
|    2 |    2 |
|    5 |    5 |
|   10 |   10 |
| NULL |    1 |
| NULL |    5 |
+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |4        |655 |
|1 | TABLE SCAN                |t1  |8        |38  |
|2 | NESTED-LOOP JOIN CARTESIAN|    |1        |77  |
|3 |  TABLE SCAN               |t2  |1        |39  |
|4 |  MATERIAL                 |    |1        |39  |
|5 |   TABLE SCAN              |t3  |1        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  4 - output([1]), filter(nil)
  5 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1);
+------+------+
| c1   | c2   |
+------+------+
|    2 |    2 |
|    5 |    5 |
|   10 |   10 |
| NULL |    1 |
| NULL |    5 |
+------+------+
EXPLAIN insert into t11_temp (select * from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1));
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |INSERT                |     |0        |146 |
|1 | SUBPLAN SCAN         |VIEW1|0        |146 |
|2 |  HASH RIGHT ANTI JOIN|     |0        |146 |
|3 |   SUBPLAN SCAN       |VIEW2|8        |93  |
|4 |    HASH JOIN         |     |8        |92  |
|5 |     TABLE SCAN       |t3   |8        |38  |
|6 |     TABLE SCAN       |t2   |9        |38  |
|7 |   TABLE SCAN         |t1   |8        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.t3.c1]), other_conds(nil)
  3 - output([VIEW2.t3.c1]), filter(nil), 
      access([VIEW2.t3.c1])
  4 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t11_temp (select * from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1));

rollback;
EXPLAIN insert into t11_temp (select /*+NO_REWRITE*/* from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1));
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |4        |656 |
|1 | SUBPLAN SCAN                |VIEW1|4        |656 |
|2 |  SUBPLAN FILTER             |     |4        |655 |
|3 |   TABLE SCAN                |t1   |8        |38  |
|4 |   NESTED-LOOP JOIN CARTESIAN|     |1        |77  |
|5 |    TABLE SCAN               |t2   |1        |39  |
|6 |    MATERIAL                 |     |1        |39  |
|7 |     TABLE SCAN              |t3   |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

insert into t11_temp (select /*+NO_REWRITE*/* from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
Query Plan
===========================================
|ID|OPERATOR         |NAME |EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE           |     |8        |192 |
|1 | SUBPLAN FILTER  |     |8        |184 |
|2 |  TABLE SCAN     |t1   |8        |38  |
|3 |  LIMIT          |     |0        |146 |
|4 |   HASH ANTI JOIN|     |0        |146 |
|5 |    TABLE SCAN   |t1   |8        |38  |
|6 |    SUBPLAN SCAN |VIEW1|8        |93  |
|7 |     HASH JOIN   |     |8        |92  |
|8 |      TABLE SCAN |t3   |8        |38  |
|9 |      TABLE SCAN |t2   |9        |38  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t3.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([VIEW1.t3.c1]), filter(nil), 
      access([VIEW1.t3.c1])
  7 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |8        |238 |
|1 | SUBPLAN FILTER               |    |8        |230 |
|2 |  TABLE SCAN                  |t1  |8        |38  |
|3 |  LIMIT                       |    |1        |191 |
|4 |   SUBPLAN FILTER             |    |1        |191 |
|5 |    TABLE SCAN                |t1  |2        |37  |
|6 |    NESTED-LOOP JOIN CARTESIAN|    |1        |77  |
|7 |     TABLE SCAN               |t2  |1        |39  |
|8 |     MATERIAL                 |    |1        |39  |
|9 |      TABLE SCAN              |t3  |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
Query Plan
===========================================
|ID|OPERATOR         |NAME |EST. ROWS|COST|
-------------------------------------------
|0 |DELETE           |     |1        |185 |
|1 | SUBPLAN FILTER  |     |1        |184 |
|2 |  TABLE SCAN     |t1   |1        |39  |
|3 |  LIMIT          |     |0        |146 |
|4 |   HASH ANTI JOIN|     |0        |146 |
|5 |    TABLE SCAN   |t1   |8        |38  |
|6 |    SUBPLAN SCAN |VIEW1|8        |93  |
|7 |     HASH JOIN   |     |8        |92  |
|8 |      TABLE SCAN |t3   |8        |38  |
|9 |      TABLE SCAN |t2   |9        |38  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t3.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([VIEW1.t3.c1]), filter(nil), 
      access([VIEW1.t3.c1])
  7 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |230 |
|1 | SUBPLAN FILTER               |    |1        |229 |
|2 |  TABLE SCAN                  |t1  |1        |39  |
|3 |  LIMIT                       |    |1        |191 |
|4 |   SUBPLAN FILTER             |    |1        |191 |
|5 |    TABLE SCAN                |t1  |2        |37  |
|6 |    NESTED-LOOP JOIN CARTESIAN|    |1        |77  |
|7 |     TABLE SCAN               |t2  |1        |39  |
|8 |     MATERIAL                 |    |1        |39  |
|9 |      TABLE SCAN              |t3  |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;

EXPLAIN select * from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |HASH RIGHT ANTI JOIN   |     |0        |147 |
|1 | SUBPLAN SCAN          |VIEW1|9        |93  |
|2 |  HASH RIGHT OUTER JOIN|     |9        |92  |
|3 |   TABLE SCAN          |t3   |8        |38  |
|4 |   TABLE SCAN          |t2   |9        |38  |
|5 | TABLE SCAN            |t1   |8        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  1 - output([VIEW1.t2.c1]), filter(nil), 
      access([VIEW1.t2.c1])
  2 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1);
+------+------+
| c1   | c2   |
+------+------+
|    5 |    5 |
|   10 |   10 |
| NULL |    1 |
| NULL |    5 |
+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER   |    |4        |655 |
|1 | TABLE SCAN      |t1  |8        |38  |
|2 | MERGE OUTER JOIN|    |1        |77  |
|3 |  TABLE SCAN     |t2  |1        |39  |
|4 |  TABLE SCAN     |t3  |1        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t2.c1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  4 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1);
+------+------+
| c1   | c2   |
+------+------+
|    5 |    5 |
|   10 |   10 |
| NULL |    1 |
| NULL |    5 |
+------+------+
EXPLAIN insert into t11_temp (select * from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1));
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |0        |147 |
|1 | SUBPLAN SCAN            |VIEW1|0        |147 |
|2 |  HASH RIGHT ANTI JOIN   |     |0        |147 |
|3 |   SUBPLAN SCAN          |VIEW2|9        |93  |
|4 |    HASH RIGHT OUTER JOIN|     |9        |92  |
|5 |     TABLE SCAN          |t3   |8        |38  |
|6 |     TABLE SCAN          |t2   |9        |38  |
|7 |   TABLE SCAN            |t1   |8        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.t2.c1]), other_conds(nil)
  3 - output([VIEW2.t2.c1]), filter(nil), 
      access([VIEW2.t2.c1])
  4 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t11_temp (select * from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1));

rollback;
EXPLAIN insert into t11_temp (select /*+NO_REWRITE*/* from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1));
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |4        |656 |
|1 | SUBPLAN SCAN      |VIEW1|4        |656 |
|2 |  SUBPLAN FILTER   |     |4        |655 |
|3 |   TABLE SCAN      |t1   |8        |38  |
|4 |   MERGE OUTER JOIN|     |1        |77  |
|5 |    TABLE SCAN     |t2   |1        |39  |
|6 |    TABLE SCAN     |t3   |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t2.c1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  6 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

insert into t11_temp (select /*+NO_REWRITE*/* from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                    |     |8        |193 |
|1 | SUBPLAN FILTER           |     |8        |185 |
|2 |  TABLE SCAN              |t1   |8        |38  |
|3 |  LIMIT                   |     |0        |146 |
|4 |   HASH ANTI JOIN         |     |0        |146 |
|5 |    TABLE SCAN            |t1   |8        |38  |
|6 |    SUBPLAN SCAN          |VIEW1|9        |93  |
|7 |     HASH RIGHT OUTER JOIN|     |9        |92  |
|8 |      TABLE SCAN          |t3   |8        |38  |
|9 |      TABLE SCAN          |t2   |9        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([VIEW1.t2.c1]), filter(nil), 
      access([VIEW1.t2.c1])
  7 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |8        |238 |
|1 | SUBPLAN FILTER     |    |8        |230 |
|2 |  TABLE SCAN        |t1  |8        |38  |
|3 |  LIMIT             |    |1        |191 |
|4 |   SUBPLAN FILTER   |    |1        |191 |
|5 |    TABLE SCAN      |t1  |2        |37  |
|6 |    MERGE OUTER JOIN|    |1        |77  |
|7 |     TABLE SCAN     |t2  |1        |39  |
|8 |     TABLE SCAN     |t3  |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t2.c1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                    |     |1        |186 |
|1 | SUBPLAN FILTER           |     |1        |185 |
|2 |  TABLE SCAN              |t1   |1        |39  |
|3 |  LIMIT                   |     |0        |146 |
|4 |   HASH ANTI JOIN         |     |0        |146 |
|5 |    TABLE SCAN            |t1   |8        |38  |
|6 |    SUBPLAN SCAN          |VIEW1|9        |93  |
|7 |     HASH RIGHT OUTER JOIN|     |9        |92  |
|8 |      TABLE SCAN          |t3   |8        |38  |
|9 |      TABLE SCAN          |t2   |9        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([VIEW1.t2.c1]), filter(nil), 
      access([VIEW1.t2.c1])
  7 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |230 |
|1 | SUBPLAN FILTER     |    |1        |229 |
|2 |  TABLE SCAN        |t1  |1        |39  |
|3 |  LIMIT             |    |1        |191 |
|4 |   SUBPLAN FILTER   |    |1        |191 |
|5 |    TABLE SCAN      |t1  |2        |37  |
|6 |    MERGE OUTER JOIN|    |1        |77  |
|7 |     TABLE SCAN     |t2  |1        |39  |
|8 |     TABLE SCAN     |t3  |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t2.c1]), filter([? = t2.c1]), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where not exists (select 1 from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t2.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |HASH RIGHT ANTI JOIN|    |1        |146 |
|1 | TABLE SCAN         |t3  |8        |38  |
|2 | HASH OUTER JOIN    |    |8        |93  |
|3 |  TABLE SCAN        |t1  |8        |38  |
|4 |  TABLE SCAN        |t2  |9        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  1 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
|    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL |
| NULL |    1 | NULL | NULL |
| NULL |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |4        |399 |
|1 | HASH OUTER JOIN|    |8        |93  |
|2 |  TABLE SCAN    |t1  |8        |38  |
|3 |  TABLE SCAN    |t2  |9        |38  |
|4 | TABLE SCAN     |t3  |1        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
|    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL |
| NULL |    1 | NULL | NULL |
| NULL |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1));
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |INSERT                |     |1        |146 |
|1 | SUBPLAN SCAN         |VIEW1|1        |146 |
|2 |  HASH RIGHT ANTI JOIN|     |1        |146 |
|3 |   TABLE SCAN         |t3   |8        |38  |
|4 |   HASH OUTER JOIN    |     |8        |93  |
|5 |    TABLE SCAN        |t1   |8        |38  |
|6 |    TABLE SCAN        |t2   |9        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |4        |400 |
|1 | SUBPLAN SCAN     |VIEW1|4        |399 |
|2 |  SUBPLAN FILTER  |     |4        |399 |
|3 |   HASH OUTER JOIN|     |8        |93  |
|4 |    TABLE SCAN    |t1   |8        |38  |
|5 |    TABLE SCAN    |t2   |9        |38  |
|6 |   TABLE SCAN     |t3   |1        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |UPDATE                 |    |8        |191 |
|1 | SUBPLAN FILTER        |    |8        |183 |
|2 |  TABLE SCAN           |t1  |8        |38  |
|3 |  LIMIT                |    |1        |144 |
|4 |   HASH RIGHT ANTI JOIN|    |1        |144 |
|5 |    TABLE SCAN         |t3  |8        |38  |
|6 |    HASH OUTER JOIN    |    |8        |92  |
|7 |     TABLE SCAN        |t1  |8        |38  |
|8 |     TABLE SCAN        |t2  |9        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |8        |207 |
|1 | SUBPLAN FILTER    |    |8        |199 |
|2 |  TABLE SCAN       |t1  |8        |38  |
|3 |  LIMIT            |    |1        |161 |
|4 |   SUBPLAN FILTER  |    |1        |161 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |1        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |DELETE                 |    |1        |184 |
|1 | SUBPLAN FILTER        |    |1        |183 |
|2 |  TABLE SCAN           |t1  |1        |39  |
|3 |  LIMIT                |    |1        |144 |
|4 |   HASH RIGHT ANTI JOIN|    |1        |144 |
|5 |    TABLE SCAN         |t3  |8        |38  |
|6 |    HASH OUTER JOIN    |    |8        |92  |
|7 |     TABLE SCAN        |t1  |8        |38  |
|8 |     TABLE SCAN        |t2  |9        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.3226495451672298 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |200 |
|1 | SUBPLAN FILTER    |    |1        |199 |
|2 |  TABLE SCAN       |t1  |1        |39  |
|3 |  LIMIT            |    |1        |161 |
|4 |   SUBPLAN FILTER  |    |1        |161 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |1        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.3226495451672298 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |HASH OUTER JOIN      |     |2        |125 |
|1 | HASH RIGHT SEMI JOIN|     |2        |80  |
|2 |  SUBPLAN SCAN       |VIEW1|2        |37  |
|3 |   TABLE SCAN        |t3   |2        |37  |
|4 |  TABLE SCAN         |t1   |8        |38  |
|5 | TABLE SCAN          |t2   |9        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.c1]), other_conds(nil)
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |4        |134 |
|1 | HASH OUTER JOIN|    |8        |93  |
|2 |  TABLE SCAN    |t1  |8        |38  |
|3 |  TABLE SCAN    |t2  |9        |38  |
|4 | TABLE SCAN     |t3  |2        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([t1.c1 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2));
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |2        |125 |
|1 | SUBPLAN SCAN          |VIEW1|2        |125 |
|2 |  HASH OUTER JOIN      |     |2        |125 |
|3 |   HASH RIGHT SEMI JOIN|     |2        |80  |
|4 |    SUBPLAN SCAN       |VIEW2|2        |37  |
|5 |     TABLE SCAN        |t3   |2        |37  |
|6 |    TABLE SCAN         |t1   |8        |38  |
|7 |   TABLE SCAN          |t2   |9        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.c1]), other_conds(nil)
  4 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |4        |136 |
|1 | SUBPLAN SCAN     |VIEW1|4        |135 |
|2 |  SUBPLAN FILTER  |     |4        |134 |
|3 |   HASH OUTER JOIN|     |8        |93  |
|4 |    TABLE SCAN    |t1   |8        |38  |
|5 |    TABLE SCAN    |t2   |9        |38  |
|6 |   TABLE SCAN     |t3   |2        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([t1.c1 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                  |     |8        |168 |
|1 | SUBPLAN FILTER         |     |8        |160 |
|2 |  TABLE SCAN            |t1   |8        |38  |
|3 |  LIMIT                 |     |1        |121 |
|4 |   HASH OUTER JOIN      |     |1        |121 |
|5 |    HASH RIGHT SEMI JOIN|     |2        |80  |
|6 |     SUBPLAN SCAN       |VIEW1|2        |37  |
|7 |      TABLE SCAN        |t3   |2        |37  |
|8 |     TABLE SCAN         |t1   |8        |38  |
|9 |    TABLE SCAN          |t2   |5        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.c1]), other_conds(nil)
  6 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |8        |169 |
|1 | SUBPLAN FILTER    |    |8        |161 |
|2 |  TABLE SCAN       |t1  |8        |38  |
|3 |  LIMIT            |    |1        |123 |
|4 |   SUBPLAN FILTER  |    |1        |122 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |2        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t1.c1 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                  |     |1        |160 |
|1 | SUBPLAN FILTER         |     |1        |159 |
|2 |  TABLE SCAN            |t1   |1        |39  |
|3 |  LIMIT                 |     |1        |121 |
|4 |   HASH OUTER JOIN      |     |1        |121 |
|5 |    HASH RIGHT SEMI JOIN|     |2        |80  |
|6 |     SUBPLAN SCAN       |VIEW1|2        |37  |
|7 |      TABLE SCAN        |t3   |2        |37  |
|8 |     TABLE SCAN         |t1   |8        |38  |
|9 |    TABLE SCAN          |t2   |5        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.c1]), other_conds(nil)
  6 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |162 |
|1 | SUBPLAN FILTER    |    |1        |161 |
|2 |  TABLE SCAN       |t1  |1        |39  |
|3 |  LIMIT            |    |1        |123 |
|4 |   SUBPLAN FILTER  |    |1        |122 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |2        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t1.c1 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2);
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |HASH OUTER JOIN       |     |6        |132 |
|1 | NESTED-LOOP ANTI JOIN|     |6        |80  |
|2 |  TABLE SCAN          |t1   |8        |38  |
|3 |  MATERIAL            |     |2        |37  |
|4 |   SUBPLAN SCAN       |VIEW1|2        |37  |
|5 |    TABLE SCAN        |t3   |2        |37  |
|6 | TABLE SCAN           |t2   |9        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([(T_OP_OR, t1.c1 = VIEW1.c1, (T_OP_IS, t1.c1, NULL, 0), (T_OP_IS, VIEW1.c1, NULL, 0))]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW1.c1]), filter(nil)
  4 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
|    4 |    2 |    4 |    4 |
|    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |4        |134 |
|1 | HASH OUTER JOIN|    |8        |93  |
|2 |  TABLE SCAN    |t1  |8        |38  |
|3 |  TABLE SCAN    |t2  |9        |38  |
|4 | TABLE SCAN     |t3  |2        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([t1.c1 != ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
|    4 |    2 |    4 |    4 |
|    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |6        |134 |
|1 | SUBPLAN SCAN           |VIEW1|6        |133 |
|2 |  HASH OUTER JOIN       |     |6        |132 |
|3 |   NESTED-LOOP ANTI JOIN|     |6        |80  |
|4 |    TABLE SCAN          |t1   |8        |38  |
|5 |    MATERIAL            |     |2        |37  |
|6 |     SUBPLAN SCAN       |VIEW2|2        |37  |
|7 |      TABLE SCAN        |t3   |2        |37  |
|8 |   TABLE SCAN           |t2   |9        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([(T_OP_OR, t1.c1 = VIEW2.c1, (T_OP_IS, t1.c1, NULL, 0), (T_OP_IS, VIEW2.c1, NULL, 0))]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([VIEW2.c1]), filter(nil)
  6 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |4        |136 |
|1 | SUBPLAN SCAN     |VIEW1|4        |135 |
|2 |  SUBPLAN FILTER  |     |4        |134 |
|3 |   HASH OUTER JOIN|     |8        |93  |
|4 |    TABLE SCAN    |t1   |8        |38  |
|5 |    TABLE SCAN    |t2   |9        |38  |
|6 |   TABLE SCAN     |t3   |2        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([t1.c1 != ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                  |     |8        |168 |
|1 | SUBPLAN FILTER         |     |8        |160 |
|2 |  TABLE SCAN            |t1   |8        |38  |
|3 |  LIMIT                 |     |1        |122 |
|4 |   NESTED-LOOP ANTI JOIN|     |1        |121 |
|5 |    HASH OUTER JOIN     |     |2        |84  |
|6 |     TABLE SCAN         |t1   |8        |38  |
|7 |     TABLE SCAN         |t2   |2        |37  |
|8 |    MATERIAL            |     |2        |37  |
|9 |     SUBPLAN SCAN       |VIEW1|2        |37  |
|10|      TABLE SCAN        |t3   |2        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([(T_OP_OR, t1.c1 = VIEW1.c1, (T_OP_IS, t1.c1, NULL, 0), (T_OP_IS, VIEW1.c1, NULL, 0))]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([VIEW1.c1]), filter(nil)
  9 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |8        |169 |
|1 | SUBPLAN FILTER    |    |8        |161 |
|2 |  TABLE SCAN       |t1  |8        |38  |
|3 |  LIMIT            |    |1        |123 |
|4 |   SUBPLAN FILTER  |    |1        |122 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |2        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t1.c1 != ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                  |     |1        |161 |
|1 | SUBPLAN FILTER         |     |1        |160 |
|2 |  TABLE SCAN            |t1   |1        |39  |
|3 |  LIMIT                 |     |1        |122 |
|4 |   NESTED-LOOP ANTI JOIN|     |1        |121 |
|5 |    HASH OUTER JOIN     |     |2        |84  |
|6 |     TABLE SCAN         |t1   |8        |38  |
|7 |     TABLE SCAN         |t2   |2        |37  |
|8 |    MATERIAL            |     |2        |37  |
|9 |     SUBPLAN SCAN       |VIEW1|2        |37  |
|10|      TABLE SCAN        |t3   |2        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([(T_OP_OR, t1.c1 = VIEW1.c1, (T_OP_IS, t1.c1, NULL, 0), (T_OP_IS, VIEW1.c1, NULL, 0))]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([VIEW1.c1]), filter(nil)
  9 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.3226495451672298 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |162 |
|1 | SUBPLAN FILTER    |    |1        |161 |
|2 |  TABLE SCAN       |t1  |1        |39  |
|3 |  LIMIT            |    |1        |123 |
|4 |   SUBPLAN FILTER  |    |1        |122 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |2        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t1.c1 != ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t1.c1 not in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.3226495451672298 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |HASH JOIN            |     |2        |124 |
|1 | HASH RIGHT SEMI JOIN|     |2        |81  |
|2 |  SUBPLAN SCAN       |VIEW1|2        |37  |
|3 |   TABLE SCAN        |t3   |2        |37  |
|4 |  TABLE SCAN         |t2   |9        |38  |
|5 | TABLE SCAN          |t1   |8        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = VIEW1.c1]), other_conds(nil)
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |4        |134 |
|1 | HASH OUTER JOIN|    |8        |93  |
|2 |  TABLE SCAN    |t1  |8        |38  |
|3 |  TABLE SCAN    |t2  |9        |38  |
|4 | TABLE SCAN     |t3  |2        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([t2.c1 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2));
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |2        |125 |
|1 | SUBPLAN SCAN          |VIEW1|2        |125 |
|2 |  HASH JOIN            |     |2        |124 |
|3 |   HASH RIGHT SEMI JOIN|     |2        |81  |
|4 |    SUBPLAN SCAN       |VIEW2|2        |37  |
|5 |     TABLE SCAN        |t3   |2        |37  |
|6 |    TABLE SCAN         |t2   |9        |38  |
|7 |   TABLE SCAN          |t1   |8        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = VIEW2.c1]), other_conds(nil)
  4 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |4        |136 |
|1 | SUBPLAN SCAN     |VIEW1|4        |135 |
|2 |  SUBPLAN FILTER  |     |4        |134 |
|3 |   HASH OUTER JOIN|     |8        |93  |
|4 |    TABLE SCAN    |t1   |8        |38  |
|5 |    TABLE SCAN    |t2   |9        |38  |
|6 |   TABLE SCAN     |t3   |2        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([t2.c1 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                  |     |8        |168 |
|1 | SUBPLAN FILTER         |     |8        |160 |
|2 |  TABLE SCAN            |t1   |8        |38  |
|3 |  LIMIT                 |     |1        |122 |
|4 |   HASH JOIN            |     |1        |121 |
|5 |    HASH RIGHT SEMI JOIN|     |2        |81  |
|6 |     SUBPLAN SCAN       |VIEW1|2        |37  |
|7 |      TABLE SCAN        |t3   |2        |37  |
|8 |     TABLE SCAN         |t2   |9        |38  |
|9 |    TABLE SCAN          |t1   |5        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = VIEW1.c1]), other_conds(nil)
  6 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |8        |169 |
|1 | SUBPLAN FILTER    |    |8        |161 |
|2 |  TABLE SCAN       |t1  |8        |38  |
|3 |  LIMIT            |    |1        |123 |
|4 |   SUBPLAN FILTER  |    |1        |122 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |2        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                  |     |1        |161 |
|1 | SUBPLAN FILTER         |     |1        |160 |
|2 |  TABLE SCAN            |t1   |1        |39  |
|3 |  LIMIT                 |     |1        |122 |
|4 |   HASH JOIN            |     |1        |121 |
|5 |    HASH RIGHT SEMI JOIN|     |2        |81  |
|6 |     SUBPLAN SCAN       |VIEW1|2        |37  |
|7 |      TABLE SCAN        |t3   |2        |37  |
|8 |     TABLE SCAN         |t2   |9        |38  |
|9 |    TABLE SCAN          |t1   |5        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = VIEW1.c1]), other_conds(nil)
  6 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |162 |
|1 | SUBPLAN FILTER    |    |1        |161 |
|2 |  TABLE SCAN       |t1  |1        |39  |
|3 |  LIMIT            |    |1        |123 |
|4 |   SUBPLAN FILTER  |    |1        |122 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |2        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |7        |136 |
|1 | HASH OUTER JOIN     |     |8        |93  |
|2 |  TABLE SCAN         |t1   |8        |38  |
|3 |  TABLE SCAN         |t2   |9        |38  |
|4 | MATERIAL            |     |2        |37  |
|5 |  SUBPLAN SCAN       |VIEW1|2        |37  |
|6 |   TABLE SCAN        |t3   |2        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      conds([(T_OP_OR, t2.c1 = VIEW1.c1, (T_OP_IS, t2.c1, NULL, 0), (T_OP_IS, VIEW1.c1, NULL, 0))]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([VIEW1.c1]), filter(nil)
  5 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

select * from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |4        |134 |
|1 | HASH OUTER JOIN|    |8        |93  |
|2 |  TABLE SCAN    |t1  |8        |38  |
|3 |  TABLE SCAN    |t2  |9        |38  |
|4 | TABLE SCAN     |t3  |2        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([t2.c1 != ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2));
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |7        |137 |
|1 | SUBPLAN SCAN          |VIEW1|7        |136 |
|2 |  NESTED-LOOP ANTI JOIN|     |7        |136 |
|3 |   HASH OUTER JOIN     |     |8        |93  |
|4 |    TABLE SCAN         |t1   |8        |38  |
|5 |    TABLE SCAN         |t2   |9        |38  |
|6 |   MATERIAL            |     |2        |37  |
|7 |    SUBPLAN SCAN       |VIEW2|2        |37  |
|8 |     TABLE SCAN        |t3   |2        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      conds([(T_OP_OR, t2.c1 = VIEW2.c1, (T_OP_IS, t2.c1, NULL, 0), (T_OP_IS, VIEW2.c1, NULL, 0))]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([VIEW2.c1]), filter(nil)
  7 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |4        |136 |
|1 | SUBPLAN SCAN     |VIEW1|4        |135 |
|2 |  SUBPLAN FILTER  |     |4        |134 |
|3 |   HASH OUTER JOIN|     |8        |93  |
|4 |    TABLE SCAN    |t1   |8        |38  |
|5 |    TABLE SCAN    |t2   |9        |38  |
|6 |   TABLE SCAN     |t3   |2        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([t2.c1 != ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                  |     |8        |168 |
|1 | SUBPLAN FILTER         |     |8        |160 |
|2 |  TABLE SCAN            |t1   |8        |38  |
|3 |  LIMIT                 |     |1        |121 |
|4 |   NESTED-LOOP ANTI JOIN|     |1        |121 |
|5 |    HASH OUTER JOIN     |     |2        |84  |
|6 |     TABLE SCAN         |t1   |8        |38  |
|7 |     TABLE SCAN         |t2   |2        |37  |
|8 |    MATERIAL            |     |2        |37  |
|9 |     SUBPLAN SCAN       |VIEW1|2        |37  |
|10|      TABLE SCAN        |t3   |2        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([(T_OP_OR, t2.c1 = VIEW1.c1, (T_OP_IS, t2.c1, NULL, 0), (T_OP_IS, VIEW1.c1, NULL, 0))]), nl_params_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([VIEW1.c1]), filter(nil)
  9 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |8        |169 |
|1 | SUBPLAN FILTER    |    |8        |161 |
|2 |  TABLE SCAN       |t1  |8        |38  |
|3 |  LIMIT            |    |1        |123 |
|4 |   SUBPLAN FILTER  |    |1        |122 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |2        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 != ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                  |     |1        |161 |
|1 | SUBPLAN FILTER         |     |1        |160 |
|2 |  TABLE SCAN            |t1   |1        |39  |
|3 |  LIMIT                 |     |1        |121 |
|4 |   NESTED-LOOP ANTI JOIN|     |1        |121 |
|5 |    HASH OUTER JOIN     |     |2        |84  |
|6 |     TABLE SCAN         |t1   |8        |38  |
|7 |     TABLE SCAN         |t2   |2        |37  |
|8 |    MATERIAL            |     |2        |37  |
|9 |     SUBPLAN SCAN       |VIEW1|2        |37  |
|10|      TABLE SCAN        |t3   |2        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([(T_OP_OR, t2.c1 = VIEW1.c1, (T_OP_IS, t2.c1, NULL, 0), (T_OP_IS, VIEW1.c1, NULL, 0))]), nl_params_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([VIEW1.c1]), filter(nil)
  9 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.3226495451672298 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |162 |
|1 | SUBPLAN FILTER    |    |1        |161 |
|2 |  TABLE SCAN       |t1  |1        |39  |
|3 |  LIMIT            |    |1        |123 |
|4 |   SUBPLAN FILTER  |    |1        |122 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |2        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t2.c1 != ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(2), offset(nil)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 not in (select t3.c1 from t3 limit 2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.3226495451672298 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1);
Query Plan
==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |MERGE JOIN      |     |8        |200 |
|1 | MERGE SEMI JOIN|     |8        |149 |
|2 |  SORT          |     |9        |47  |
|3 |   TABLE SCAN   |t2   |9        |38  |
|4 |  SUBPLAN SCAN  |VIEW1|8        |95  |
|5 |   MERGE JOIN   |     |8        |94  |
|6 |    SORT        |     |8        |44  |
|7 |     TABLE SCAN |t3   |8        |38  |
|8 |    SORT        |     |8        |44  |
|9 |     TABLE SCAN |t4   |8        |38  |
|10| SORT           |     |8        |46  |
|11|  TABLE SCAN    |t1   |8        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = VIEW1.t4.c1]), other_conds(nil)
  2 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([VIEW1.t4.c1]), filter(nil), 
      access([VIEW1.t4.c1])
  5 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  6 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  9 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |4        |709 |
|1 | HASH OUTER JOIN           |    |8        |93  |
|2 |  TABLE SCAN               |t1  |8        |38  |
|3 |  TABLE SCAN               |t2  |9        |38  |
|4 | NESTED-LOOP JOIN CARTESIAN|    |1        |77  |
|5 |  TABLE SCAN               |t3  |1        |38  |
|6 |  MATERIAL                 |    |1        |39  |
|7 |   TABLE SCAN              |t4  |1        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |8        |202 |
|1 | SUBPLAN SCAN     |VIEW1|8        |201 |
|2 |  MERGE JOIN      |     |8        |200 |
|3 |   MERGE SEMI JOIN|     |8        |149 |
|4 |    SORT          |     |9        |47  |
|5 |     TABLE SCAN   |t2   |9        |38  |
|6 |    SUBPLAN SCAN  |VIEW2|8        |95  |
|7 |     MERGE JOIN   |     |8        |94  |
|8 |      SORT        |     |8        |44  |
|9 |       TABLE SCAN |t3   |8        |38  |
|10|      SORT        |     |8        |44  |
|11|       TABLE SCAN |t4   |8        |38  |
|12|   SORT           |     |8        |46  |
|13|    TABLE SCAN    |t1   |8        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = VIEW2.t4.c1]), other_conds(nil)
  4 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([VIEW2.t4.c1]), filter(nil), 
      access([VIEW2.t4.c1])
  7 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1));
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |4        |710 |
|1 | SUBPLAN SCAN                |VIEW1|4        |709 |
|2 |  SUBPLAN FILTER             |     |4        |709 |
|3 |   HASH OUTER JOIN           |     |8        |93  |
|4 |    TABLE SCAN               |t1   |8        |38  |
|5 |    TABLE SCAN               |t2   |9        |38  |
|6 |   NESTED-LOOP JOIN CARTESIAN|     |1        |77  |
|7 |    TABLE SCAN               |t3   |1        |38  |
|8 |    MATERIAL                 |     |1        |39  |
|9 |     TABLE SCAN              |t4   |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1) limit 1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                 |     |8        |232 |
|1 | SUBPLAN FILTER        |     |8        |224 |
|2 |  TABLE SCAN           |t1   |8        |38  |
|3 |  LIMIT                |     |1        |185 |
|4 |   HASH RIGHT SEMI JOIN|     |1        |185 |
|5 |    SUBPLAN SCAN       |VIEW1|8        |92  |
|6 |     HASH JOIN         |     |8        |91  |
|7 |      TABLE SCAN       |t3   |8        |38  |
|8 |      TABLE SCAN       |t4   |8        |38  |
|9 |    HASH JOIN          |     |2        |84  |
|10|     TABLE SCAN        |t1   |8        |38  |
|11|     TABLE SCAN        |t2   |2        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = VIEW1.t4.c1]), other_conds(nil)
  5 - output([VIEW1.t4.c1]), filter(nil), 
      access([VIEW1.t4.c1])
  6 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1) limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |8        |285 |
|1 | SUBPLAN FILTER               |    |8        |277 |
|2 |  TABLE SCAN                  |t1  |8        |38  |
|3 |  LIMIT                       |    |1        |239 |
|4 |   SUBPLAN FILTER             |    |1        |238 |
|5 |    HASH OUTER JOIN           |    |2        |85  |
|6 |     TABLE SCAN               |t1  |8        |38  |
|7 |     TABLE SCAN               |t2  |3        |37  |
|8 |    NESTED-LOOP JOIN CARTESIAN|    |1        |77  |
|9 |     TABLE SCAN               |t3  |1        |38  |
|10|     MATERIAL                 |    |1        |39  |
|11|      TABLE SCAN              |t4  |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  9 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1) limit 1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                 |     |1        |224 |
|1 | SUBPLAN FILTER        |     |1        |223 |
|2 |  TABLE SCAN           |t1   |1        |39  |
|3 |  LIMIT                |     |1        |185 |
|4 |   HASH RIGHT SEMI JOIN|     |1        |185 |
|5 |    SUBPLAN SCAN       |VIEW1|8        |92  |
|6 |     HASH JOIN         |     |8        |91  |
|7 |      TABLE SCAN       |t3   |8        |38  |
|8 |      TABLE SCAN       |t4   |8        |38  |
|9 |    HASH JOIN          |     |2        |84  |
|10|     TABLE SCAN        |t1   |8        |38  |
|11|     TABLE SCAN        |t2   |2        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = VIEW1.t4.c1]), other_conds(nil)
  5 - output([VIEW1.t4.c1]), filter(nil), 
      access([VIEW1.t4.c1])
  6 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1) limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |278 |
|1 | SUBPLAN FILTER               |    |1        |277 |
|2 |  TABLE SCAN                  |t1  |1        |39  |
|3 |  LIMIT                       |    |1        |239 |
|4 |   SUBPLAN FILTER             |    |1        |238 |
|5 |    HASH OUTER JOIN           |    |2        |85  |
|6 |     TABLE SCAN               |t1  |8        |38  |
|7 |     TABLE SCAN               |t2  |3        |37  |
|8 |    NESTED-LOOP JOIN CARTESIAN|    |1        |77  |
|9 |     TABLE SCAN               |t3  |1        |38  |
|10|     MATERIAL                 |    |1        |39  |
|11|      TABLE SCAN              |t4  |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  9 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t4.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |MERGE JOIN         |     |8        |200 |
|1 | MERGE SEMI JOIN   |     |8        |149 |
|2 |  SORT             |     |9        |47  |
|3 |   TABLE SCAN      |t2   |9        |38  |
|4 |  SUBPLAN SCAN     |VIEW1|8        |95  |
|5 |   MERGE OUTER JOIN|     |8        |94  |
|6 |    SORT           |     |8        |44  |
|7 |     TABLE SCAN    |t3   |8        |38  |
|8 |    SORT           |     |8        |44  |
|9 |     TABLE SCAN    |t4   |8        |38  |
|10| SORT              |     |8        |46  |
|11|  TABLE SCAN       |t1   |8        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = VIEW1.t3.c1]), other_conds(nil)
  2 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([VIEW1.t3.c1]), filter(nil), 
      access([VIEW1.t3.c1])
  5 - output([t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  6 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  9 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER   |    |4        |709 |
|1 | HASH OUTER JOIN |    |8        |93  |
|2 |  TABLE SCAN     |t1  |8        |38  |
|3 |  TABLE SCAN     |t2  |9        |38  |
|4 | MERGE OUTER JOIN|    |1        |77  |
|5 |  TABLE SCAN     |t3  |1        |38  |
|6 |  TABLE SCAN     |t4  |1        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  5 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  6 - output([t4.c1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1));
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |INSERT               |     |8        |202 |
|1 | SUBPLAN SCAN        |VIEW1|8        |201 |
|2 |  MERGE JOIN         |     |8        |200 |
|3 |   MERGE SEMI JOIN   |     |8        |149 |
|4 |    SORT             |     |9        |47  |
|5 |     TABLE SCAN      |t2   |9        |38  |
|6 |    SUBPLAN SCAN     |VIEW2|8        |95  |
|7 |     MERGE OUTER JOIN|     |8        |94  |
|8 |      SORT           |     |8        |44  |
|9 |       TABLE SCAN    |t3   |8        |38  |
|10|      SORT           |     |8        |44  |
|11|       TABLE SCAN    |t4   |8        |38  |
|12|   SORT              |     |8        |46  |
|13|    TABLE SCAN       |t1   |8        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = VIEW2.t3.c1]), other_conds(nil)
  4 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([VIEW2.t3.c1]), filter(nil), 
      access([VIEW2.t3.c1])
  7 - output([t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1));
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |4        |710 |
|1 | SUBPLAN SCAN      |VIEW1|4        |709 |
|2 |  SUBPLAN FILTER   |     |4        |709 |
|3 |   HASH OUTER JOIN |     |8        |93  |
|4 |    TABLE SCAN     |t1   |8        |38  |
|5 |    TABLE SCAN     |t2   |9        |38  |
|6 |   MERGE OUTER JOIN|     |1        |77  |
|7 |    TABLE SCAN     |t3   |1        |38  |
|8 |    TABLE SCAN     |t4   |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1) limit 1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                 |     |8        |232 |
|1 | SUBPLAN FILTER        |     |8        |224 |
|2 |  TABLE SCAN           |t1   |8        |38  |
|3 |  LIMIT                |     |1        |185 |
|4 |   HASH RIGHT SEMI JOIN|     |1        |185 |
|5 |    SUBPLAN SCAN       |VIEW1|8        |92  |
|6 |     HASH OUTER JOIN   |     |8        |91  |
|7 |      TABLE SCAN       |t3   |8        |38  |
|8 |      TABLE SCAN       |t4   |8        |38  |
|9 |    HASH JOIN          |     |2        |84  |
|10|     TABLE SCAN        |t1   |8        |38  |
|11|     TABLE SCAN        |t2   |2        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = VIEW1.t3.c1]), other_conds(nil)
  5 - output([VIEW1.t3.c1]), filter(nil), 
      access([VIEW1.t3.c1])
  6 - output([t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |8        |285 |
|1 | SUBPLAN FILTER     |    |8        |277 |
|2 |  TABLE SCAN        |t1  |8        |38  |
|3 |  LIMIT             |    |1        |238 |
|4 |   SUBPLAN FILTER   |    |1        |238 |
|5 |    HASH OUTER JOIN |    |2        |85  |
|6 |     TABLE SCAN     |t1  |8        |38  |
|7 |     TABLE SCAN     |t2  |3        |37  |
|8 |    MERGE OUTER JOIN|    |1        |77  |
|9 |     TABLE SCAN     |t3  |1        |38  |
|10|     TABLE SCAN     |t4  |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1) limit 1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                 |     |1        |224 |
|1 | SUBPLAN FILTER        |     |1        |223 |
|2 |  TABLE SCAN           |t1   |1        |39  |
|3 |  LIMIT                |     |1        |185 |
|4 |   HASH RIGHT SEMI JOIN|     |1        |185 |
|5 |    SUBPLAN SCAN       |VIEW1|8        |92  |
|6 |     HASH OUTER JOIN   |     |8        |91  |
|7 |      TABLE SCAN       |t3   |8        |38  |
|8 |      TABLE SCAN       |t4   |8        |38  |
|9 |    HASH JOIN          |     |2        |84  |
|10|     TABLE SCAN        |t1   |8        |38  |
|11|     TABLE SCAN        |t2   |2        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = VIEW1.t3.c1]), other_conds(nil)
  5 - output([VIEW1.t3.c1]), filter(nil), 
      access([VIEW1.t3.c1])
  6 - output([t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |278 |
|1 | SUBPLAN FILTER     |    |1        |277 |
|2 |  TABLE SCAN        |t1  |1        |39  |
|3 |  LIMIT             |    |1        |238 |
|4 |   SUBPLAN FILTER   |    |1        |238 |
|5 |    HASH OUTER JOIN |    |2        |85  |
|6 |     TABLE SCAN     |t1  |8        |38  |
|7 |     TABLE SCAN     |t2  |3        |37  |
|8 |    MERGE OUTER JOIN|    |1        |77  |
|9 |     TABLE SCAN     |t3  |1        |38  |
|10|     TABLE SCAN     |t4  |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c1=t3.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1);
Query Plan
==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |MERGE OUTER JOIN|     |8        |201 |
|1 | MERGE SEMI JOIN|     |8        |147 |
|2 |  SORT          |     |8        |46  |
|3 |   TABLE SCAN   |t1   |8        |38  |
|4 |  SUBPLAN SCAN  |VIEW1|8        |95  |
|5 |   MERGE JOIN   |     |8        |94  |
|6 |    SORT        |     |8        |44  |
|7 |     TABLE SCAN |t3   |8        |38  |
|8 |    SORT        |     |8        |44  |
|9 |     TABLE SCAN |t4   |8        |38  |
|10| SORT           |     |9        |47  |
|11|  TABLE SCAN    |t2   |9        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t4.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([VIEW1.t4.c1]), filter(nil), 
      access([VIEW1.t4.c1])
  5 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  6 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  9 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |4        |709 |
|1 | HASH OUTER JOIN           |    |8        |93  |
|2 |  TABLE SCAN               |t1  |8        |38  |
|3 |  TABLE SCAN               |t2  |9        |38  |
|4 | NESTED-LOOP JOIN CARTESIAN|    |1        |77  |
|5 |  TABLE SCAN               |t3  |1        |38  |
|6 |  MATERIAL                 |    |1        |39  |
|7 |   TABLE SCAN              |t4  |1        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |8        |203 |
|1 | SUBPLAN SCAN     |VIEW1|8        |202 |
|2 |  MERGE OUTER JOIN|     |8        |201 |
|3 |   MERGE SEMI JOIN|     |8        |147 |
|4 |    SORT          |     |8        |46  |
|5 |     TABLE SCAN   |t1   |8        |38  |
|6 |    SUBPLAN SCAN  |VIEW2|8        |95  |
|7 |     MERGE JOIN   |     |8        |94  |
|8 |      SORT        |     |8        |44  |
|9 |       TABLE SCAN |t3   |8        |38  |
|10|      SORT        |     |8        |44  |
|11|       TABLE SCAN |t4   |8        |38  |
|12|   SORT           |     |9        |47  |
|13|    TABLE SCAN    |t2   |9        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.t4.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([VIEW2.t4.c1]), filter(nil), 
      access([VIEW2.t4.c1])
  7 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  13 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1));
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |4        |710 |
|1 | SUBPLAN SCAN                |VIEW1|4        |709 |
|2 |  SUBPLAN FILTER             |     |4        |709 |
|3 |   HASH OUTER JOIN           |     |8        |93  |
|4 |    TABLE SCAN               |t1   |8        |38  |
|5 |    TABLE SCAN               |t2   |9        |38  |
|6 |   NESTED-LOOP JOIN CARTESIAN|     |1        |77  |
|7 |    TABLE SCAN               |t3   |1        |38  |
|8 |    MATERIAL                 |     |1        |39  |
|9 |     TABLE SCAN              |t4   |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1) limit 1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                 |     |8        |231 |
|1 | SUBPLAN FILTER        |     |8        |223 |
|2 |  TABLE SCAN           |t1   |8        |38  |
|3 |  LIMIT                |     |1        |185 |
|4 |   HASH RIGHT SEMI JOIN|     |1        |185 |
|5 |    SUBPLAN SCAN       |VIEW1|8        |92  |
|6 |     HASH JOIN         |     |8        |91  |
|7 |      TABLE SCAN       |t3   |8        |38  |
|8 |      TABLE SCAN       |t4   |8        |38  |
|9 |    HASH OUTER JOIN    |     |1        |83  |
|10|     TABLE SCAN        |t1   |8        |38  |
|11|     TABLE SCAN        |t2   |2        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t4.c1]), other_conds(nil)
  5 - output([VIEW1.t4.c1]), filter(nil), 
      access([VIEW1.t4.c1])
  6 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1) limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |8        |285 |
|1 | SUBPLAN FILTER               |    |8        |277 |
|2 |  TABLE SCAN                  |t1  |8        |38  |
|3 |  LIMIT                       |    |1        |239 |
|4 |   SUBPLAN FILTER             |    |1        |238 |
|5 |    HASH OUTER JOIN           |    |2        |85  |
|6 |     TABLE SCAN               |t1  |8        |38  |
|7 |     TABLE SCAN               |t2  |3        |37  |
|8 |    NESTED-LOOP JOIN CARTESIAN|    |1        |77  |
|9 |     TABLE SCAN               |t3  |1        |38  |
|10|     MATERIAL                 |    |1        |39  |
|11|      TABLE SCAN              |t4  |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  9 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1) limit 1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                 |     |1        |224 |
|1 | SUBPLAN FILTER        |     |1        |223 |
|2 |  TABLE SCAN           |t1   |1        |39  |
|3 |  LIMIT                |     |1        |185 |
|4 |   HASH RIGHT SEMI JOIN|     |1        |185 |
|5 |    SUBPLAN SCAN       |VIEW1|8        |92  |
|6 |     HASH JOIN         |     |8        |91  |
|7 |      TABLE SCAN       |t3   |8        |38  |
|8 |      TABLE SCAN       |t4   |8        |38  |
|9 |    HASH OUTER JOIN    |     |1        |83  |
|10|     TABLE SCAN        |t1   |8        |38  |
|11|     TABLE SCAN        |t2   |2        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t4.c1]), other_conds(nil)
  5 - output([VIEW1.t4.c1]), filter(nil), 
      access([VIEW1.t4.c1])
  6 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1) limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |278 |
|1 | SUBPLAN FILTER               |    |1        |277 |
|2 |  TABLE SCAN                  |t1  |1        |39  |
|3 |  LIMIT                       |    |1        |239 |
|4 |   SUBPLAN FILTER             |    |1        |238 |
|5 |    HASH OUTER JOIN           |    |2        |85  |
|6 |     TABLE SCAN               |t1  |8        |38  |
|7 |     TABLE SCAN               |t2  |3        |37  |
|8 |    NESTED-LOOP JOIN CARTESIAN|    |1        |77  |
|9 |     TABLE SCAN               |t3  |1        |38  |
|10|     MATERIAL                 |    |1        |39  |
|11|      TABLE SCAN              |t4  |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  9 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2);
Query Plan
==============================================
|ID|OPERATOR            |NAME |EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT ANTI JOIN|     |1        |201 |
|1 | SUBPLAN SCAN       |VIEW1|8        |92  |
|2 |  HASH JOIN         |     |8        |91  |
|3 |   TABLE SCAN       |t3   |8        |38  |
|4 |   TABLE SCAN       |t4   |8        |38  |
|5 | HASH OUTER JOIN    |     |8        |93  |
|6 |  TABLE SCAN        |t1   |8        |38  |
|7 |  TABLE SCAN        |t2   |9        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c2 = VIEW1.t4.c2]), other_conds(nil)
  1 - output([VIEW1.t4.c2]), filter(nil), 
      access([VIEW1.t4.c2])
  2 - output([t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c2]), other_conds(nil)
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
|    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL |
| NULL |    1 | NULL | NULL |
| NULL |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |4        |709 |
|1 | HASH OUTER JOIN           |    |8        |93  |
|2 |  TABLE SCAN               |t1  |8        |38  |
|3 |  TABLE SCAN               |t2  |9        |38  |
|4 | NESTED-LOOP JOIN CARTESIAN|    |1        |77  |
|5 |  TABLE SCAN               |t3  |1        |38  |
|6 |  MATERIAL                 |    |1        |39  |
|7 |   TABLE SCAN              |t4  |1        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter([? = t4.c2]), 
      access([t4.c2]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
|    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL |
| NULL |    1 | NULL | NULL |
| NULL |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2));
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |INSERT                |     |1        |201 |
|1 | SUBPLAN SCAN         |VIEW1|1        |201 |
|2 |  HASH RIGHT ANTI JOIN|     |1        |201 |
|3 |   SUBPLAN SCAN       |VIEW2|8        |92  |
|4 |    HASH JOIN         |     |8        |91  |
|5 |     TABLE SCAN       |t3   |8        |38  |
|6 |     TABLE SCAN       |t4   |8        |38  |
|7 |   HASH OUTER JOIN    |     |8        |93  |
|8 |    TABLE SCAN        |t1   |8        |38  |
|9 |    TABLE SCAN        |t2   |9        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c2 = VIEW2.t4.c2]), other_conds(nil)
  3 - output([VIEW2.t4.c2]), filter(nil), 
      access([VIEW2.t4.c2])
  4 - output([t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c2]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  7 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2));
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |4        |710 |
|1 | SUBPLAN SCAN                |VIEW1|4        |709 |
|2 |  SUBPLAN FILTER             |     |4        |709 |
|3 |   HASH OUTER JOIN           |     |8        |93  |
|4 |    TABLE SCAN               |t1   |8        |38  |
|5 |    TABLE SCAN               |t2   |9        |38  |
|6 |   NESTED-LOOP JOIN CARTESIAN|     |1        |77  |
|7 |    TABLE SCAN               |t3   |1        |38  |
|8 |    MATERIAL                 |     |1        |39  |
|9 |     TABLE SCAN              |t4   |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter([? = t4.c2]), 
      access([t4.c2]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2) limit 1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                 |     |8        |246 |
|1 | SUBPLAN FILTER        |     |8        |238 |
|2 |  TABLE SCAN           |t1   |8        |38  |
|3 |  LIMIT                |     |1        |199 |
|4 |   HASH RIGHT ANTI JOIN|     |1        |199 |
|5 |    SUBPLAN SCAN       |VIEW1|8        |92  |
|6 |     HASH JOIN         |     |8        |91  |
|7 |      TABLE SCAN       |t3   |8        |38  |
|8 |      TABLE SCAN       |t4   |8        |38  |
|9 |    HASH OUTER JOIN    |     |8        |92  |
|10|     TABLE SCAN        |t1   |8        |38  |
|11|     TABLE SCAN        |t2   |9        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c2 = VIEW1.t4.c2]), other_conds(nil)
  5 - output([VIEW1.t4.c2]), filter(nil), 
      access([VIEW1.t4.c2])
  6 - output([t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c2]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  9 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2) limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |8        |285 |
|1 | SUBPLAN FILTER               |    |8        |277 |
|2 |  TABLE SCAN                  |t1  |8        |38  |
|3 |  LIMIT                       |    |1        |239 |
|4 |   SUBPLAN FILTER             |    |1        |238 |
|5 |    HASH OUTER JOIN           |    |2        |85  |
|6 |     TABLE SCAN               |t1  |8        |38  |
|7 |     TABLE SCAN               |t2  |3        |37  |
|8 |    NESTED-LOOP JOIN CARTESIAN|    |1        |77  |
|9 |     TABLE SCAN               |t3  |1        |38  |
|10|     MATERIAL                 |    |1        |39  |
|11|      TABLE SCAN              |t4  |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  9 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter([? = t4.c2]), 
      access([t4.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2) limit 1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                 |     |1        |238 |
|1 | SUBPLAN FILTER        |     |1        |237 |
|2 |  TABLE SCAN           |t1   |1        |39  |
|3 |  LIMIT                |     |1        |199 |
|4 |   HASH RIGHT ANTI JOIN|     |1        |199 |
|5 |    SUBPLAN SCAN       |VIEW1|8        |92  |
|6 |     HASH JOIN         |     |8        |91  |
|7 |      TABLE SCAN       |t3   |8        |38  |
|8 |      TABLE SCAN       |t4   |8        |38  |
|9 |    HASH OUTER JOIN    |     |8        |92  |
|10|     TABLE SCAN        |t1   |8        |38  |
|11|     TABLE SCAN        |t2   |9        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c2 = VIEW1.t4.c2]), other_conds(nil)
  5 - output([VIEW1.t4.c2]), filter(nil), 
      access([VIEW1.t4.c2])
  6 - output([t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c2]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  9 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.3226495451672298 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2) limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |278 |
|1 | SUBPLAN FILTER               |    |1        |277 |
|2 |  TABLE SCAN                  |t1  |1        |39  |
|3 |  LIMIT                       |    |1        |239 |
|4 |   SUBPLAN FILTER             |    |1        |238 |
|5 |    HASH OUTER JOIN           |    |2        |85  |
|6 |     TABLE SCAN               |t1  |8        |38  |
|7 |     TABLE SCAN               |t2  |3        |37  |
|8 |    NESTED-LOOP JOIN CARTESIAN|    |1        |77  |
|9 |     TABLE SCAN               |t3  |1        |38  |
|10|     MATERIAL                 |    |1        |39  |
|11|      TABLE SCAN              |t4  |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  9 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter([? = t4.c2]), 
      access([t4.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t4.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.3226495451672298 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |HASH RIGHT ANTI JOIN   |     |1        |201 |
|1 | SUBPLAN SCAN          |VIEW1|8        |92  |
|2 |  HASH RIGHT OUTER JOIN|     |8        |91  |
|3 |   TABLE SCAN          |t4   |8        |38  |
|4 |   TABLE SCAN          |t3   |8        |38  |
|5 | HASH OUTER JOIN       |     |8        |93  |
|6 |  TABLE SCAN           |t1   |8        |38  |
|7 |  TABLE SCAN           |t2   |9        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c2 = VIEW1.t3.c2]), other_conds(nil)
  1 - output([VIEW1.t3.c2]), filter(nil), 
      access([VIEW1.t3.c2])
  2 - output([t3.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c2]), other_conds(nil)
  3 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
|    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL |
| NULL |    1 | NULL | NULL |
| NULL |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |4        |734 |
|1 | HASH OUTER JOIN|    |8        |93  |
|2 |  TABLE SCAN    |t1  |8        |38  |
|3 |  TABLE SCAN    |t2  |9        |38  |
|4 | HASH OUTER JOIN|    |1        |80  |
|5 |  TABLE SCAN    |t3  |1        |39  |
|6 |  TABLE SCAN    |t4  |8        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c2]), other_conds(nil)
  5 - output([t3.c1]), filter([? = t3.c2]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  6 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
|    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL |
| NULL |    1 | NULL | NULL |
| NULL |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2));
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |1        |201 |
|1 | SUBPLAN SCAN            |VIEW1|1        |201 |
|2 |  HASH RIGHT ANTI JOIN   |     |1        |201 |
|3 |   SUBPLAN SCAN          |VIEW2|8        |92  |
|4 |    HASH RIGHT OUTER JOIN|     |8        |91  |
|5 |     TABLE SCAN          |t4   |8        |38  |
|6 |     TABLE SCAN          |t3   |8        |38  |
|7 |   HASH OUTER JOIN       |     |8        |93  |
|8 |    TABLE SCAN           |t1   |8        |38  |
|9 |    TABLE SCAN           |t2   |9        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c2 = VIEW2.t3.c2]), other_conds(nil)
  3 - output([VIEW2.t3.c2]), filter(nil), 
      access([VIEW2.t3.c2])
  4 - output([t3.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c2]), other_conds(nil)
  5 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  7 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |4        |735 |
|1 | SUBPLAN SCAN     |VIEW1|4        |734 |
|2 |  SUBPLAN FILTER  |     |4        |734 |
|3 |   HASH OUTER JOIN|     |8        |93  |
|4 |    TABLE SCAN    |t1   |8        |38  |
|5 |    TABLE SCAN    |t2   |9        |38  |
|6 |   HASH OUTER JOIN|     |1        |80  |
|7 |    TABLE SCAN    |t3   |1        |39  |
|8 |    TABLE SCAN    |t4   |8        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c2]), other_conds(nil)
  7 - output([t3.c1]), filter([? = t3.c2]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  8 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2) limit 1);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                    |     |8        |246 |
|1 | SUBPLAN FILTER           |     |8        |238 |
|2 |  TABLE SCAN              |t1   |8        |38  |
|3 |  LIMIT                   |     |1        |199 |
|4 |   HASH RIGHT ANTI JOIN   |     |1        |199 |
|5 |    SUBPLAN SCAN          |VIEW1|8        |92  |
|6 |     HASH RIGHT OUTER JOIN|     |8        |91  |
|7 |      TABLE SCAN          |t4   |8        |38  |
|8 |      TABLE SCAN          |t3   |8        |38  |
|9 |    HASH OUTER JOIN       |     |8        |92  |
|10|     TABLE SCAN           |t1   |8        |38  |
|11|     TABLE SCAN           |t2   |9        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c2 = VIEW1.t3.c2]), other_conds(nil)
  5 - output([VIEW1.t3.c2]), filter(nil), 
      access([VIEW1.t3.c2])
  6 - output([t3.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c2]), other_conds(nil)
  7 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  8 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  9 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |8        |291 |
|1 | SUBPLAN FILTER    |    |8        |283 |
|2 |  TABLE SCAN       |t1  |8        |38  |
|3 |  LIMIT            |    |1        |245 |
|4 |   SUBPLAN FILTER  |    |1        |245 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    HASH OUTER JOIN|    |1        |80  |
|9 |     TABLE SCAN    |t3  |1        |39  |
|10|     TABLE SCAN    |t4  |8        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c2]), other_conds(nil)
  9 - output([t3.c1]), filter([? = t3.c2]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  10 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2) limit 1);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                    |     |1        |238 |
|1 | SUBPLAN FILTER           |     |1        |237 |
|2 |  TABLE SCAN              |t1   |1        |39  |
|3 |  LIMIT                   |     |1        |199 |
|4 |   HASH RIGHT ANTI JOIN   |     |1        |199 |
|5 |    SUBPLAN SCAN          |VIEW1|8        |92  |
|6 |     HASH RIGHT OUTER JOIN|     |8        |91  |
|7 |      TABLE SCAN          |t4   |8        |38  |
|8 |      TABLE SCAN          |t3   |8        |38  |
|9 |    HASH OUTER JOIN       |     |8        |92  |
|10|     TABLE SCAN           |t1   |8        |38  |
|11|     TABLE SCAN           |t2   |9        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c2 = VIEW1.t3.c2]), other_conds(nil)
  5 - output([VIEW1.t3.c2]), filter(nil), 
      access([VIEW1.t3.c2])
  6 - output([t3.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c2]), other_conds(nil)
  7 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  8 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  9 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.3226495451672298 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |284 |
|1 | SUBPLAN FILTER    |    |1        |283 |
|2 |  TABLE SCAN       |t1  |1        |39  |
|3 |  LIMIT            |    |1        |245 |
|4 |   SUBPLAN FILTER  |    |1        |245 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    HASH OUTER JOIN|    |1        |80  |
|9 |     TABLE SCAN    |t3  |1        |39  |
|10|     TABLE SCAN    |t4  |8        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c2]), other_conds(nil)
  9 - output([t3.c1]), filter([? = t3.c2]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  10 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c2 where t2.c2=t3.c2) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.3226495451672298 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1);
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |HASH SEMI JOIN        |     |3        |280 |
|1 | HASH JOIN            |     |3        |179 |
|2 |  HASH RIGHT ANTI JOIN|     |3        |133 |
|3 |   SUBPLAN SCAN       |VIEW2|5        |85  |
|4 |    HASH OUTER JOIN   |     |5        |84  |
|5 |     TABLE SCAN       |t5   |5        |37  |
|6 |     TABLE SCAN       |t6   |5        |37  |
|7 |   TABLE SCAN         |t1   |8        |38  |
|8 |  TABLE SCAN          |t2   |9        |38  |
|9 | SUBPLAN SCAN         |VIEW1|8        |92  |
|10|  HASH JOIN           |     |8        |91  |
|11|   TABLE SCAN         |t3   |8        |38  |
|12|   TABLE SCAN         |t4   |8        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c2 = VIEW1.t4.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.t5.c1]), other_conds(nil)
  3 - output([VIEW2.t5.c1]), filter(nil), 
      access([VIEW2.t5.c1])
  4 - output([t5.c1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  5 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  6 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  9 - output([VIEW1.t4.c2]), filter(nil), 
      access([VIEW1.t4.c2])
  10 - output([t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER   |    |2        |1335|
|1 | HASH OUTER JOIN |    |8        |93  |
|2 |  TABLE SCAN     |t1  |8        |38  |
|3 |  TABLE SCAN     |t2  |9        |38  |
|4 | HASH JOIN       |    |1        |80  |
|5 |  TABLE SCAN     |t4  |1        |39  |
|6 |  TABLE SCAN     |t3  |8        |38  |
|7 | MERGE OUTER JOIN|    |1        |76  |
|8 |  TABLE SCAN     |t5  |1        |38  |
|9 |  TABLE SCAN     |t6  |1        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))], [(T_OP_NOT_EXISTS, subquery(2))]), 
      exec_params_([t2.c2], [t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  5 - output([t4.c1]), filter([? = t4.c2]), 
      access([t4.c1], [t4.c2]), partitions(p0)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  7 - output([1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  8 - output([t5.c1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  9 - output([t6.c1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |3        |281 |
|1 | SUBPLAN SCAN           |VIEW1|3        |281 |
|2 |  HASH SEMI JOIN        |     |3        |280 |
|3 |   HASH JOIN            |     |3        |179 |
|4 |    HASH RIGHT ANTI JOIN|     |3        |133 |
|5 |     SUBPLAN SCAN       |VIEW3|5        |85  |
|6 |      HASH OUTER JOIN   |     |5        |84  |
|7 |       TABLE SCAN       |t5   |5        |37  |
|8 |       TABLE SCAN       |t6   |5        |37  |
|9 |     TABLE SCAN         |t1   |8        |38  |
|10|    TABLE SCAN          |t2   |9        |38  |
|11|   SUBPLAN SCAN         |VIEW2|8        |92  |
|12|    HASH JOIN           |     |8        |91  |
|13|     TABLE SCAN         |t3   |8        |38  |
|14|     TABLE SCAN         |t4   |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c2 = VIEW2.t4.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW3.t5.c1]), other_conds(nil)
  5 - output([VIEW3.t5.c1]), filter(nil), 
      access([VIEW3.t5.c1])
  6 - output([t5.c1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  7 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  8 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p0)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  11 - output([VIEW2.t4.c2]), filter(nil), 
      access([VIEW2.t4.c2])
  12 - output([t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  13 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  14 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1));
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |2        |1335|
|1 | SUBPLAN SCAN      |VIEW1|2        |1335|
|2 |  SUBPLAN FILTER   |     |2        |1335|
|3 |   HASH OUTER JOIN |     |8        |93  |
|4 |    TABLE SCAN     |t1   |8        |38  |
|5 |    TABLE SCAN     |t2   |9        |38  |
|6 |   HASH JOIN       |     |1        |80  |
|7 |    TABLE SCAN     |t4   |1        |39  |
|8 |    TABLE SCAN     |t3   |8        |38  |
|9 |   MERGE OUTER JOIN|     |1        |76  |
|10|    TABLE SCAN     |t5   |1        |38  |
|11|    TABLE SCAN     |t6   |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))], [(T_OP_NOT_EXISTS, subquery(2))]), 
      exec_params_([t2.c2], [t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t4.c1]), filter([? = t4.c2]), 
      access([t4.c1], [t4.c2]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  10 - output([t5.c1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  11 - output([t6.c1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                   |     |8        |326 |
|1 | SUBPLAN FILTER          |     |8        |318 |
|2 |  TABLE SCAN             |t1   |8        |38  |
|3 |  LIMIT                  |     |1        |279 |
|4 |   HASH SEMI JOIN        |     |3        |279 |
|5 |    HASH JOIN            |     |3        |178 |
|6 |     HASH RIGHT ANTI JOIN|     |3        |133 |
|7 |      SUBPLAN SCAN       |VIEW2|5        |85  |
|8 |       HASH OUTER JOIN   |     |5        |84  |
|9 |        TABLE SCAN       |t5   |5        |37  |
|10|        TABLE SCAN       |t6   |5        |37  |
|11|      TABLE SCAN         |t1   |8        |38  |
|12|     TABLE SCAN          |t2   |9        |38  |
|13|    SUBPLAN SCAN         |VIEW1|8        |92  |
|14|     HASH JOIN           |     |8        |91  |
|15|      TABLE SCAN         |t3   |8        |38  |
|16|      TABLE SCAN         |t4   |8        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c2 = VIEW1.t4.c2]), other_conds(nil)
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.t5.c1]), other_conds(nil)
  7 - output([VIEW2.t5.c1]), filter(nil), 
      access([VIEW2.t5.c1])
  8 - output([t5.c1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  9 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  10 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  13 - output([VIEW1.t4.c2]), filter(nil), 
      access([VIEW1.t4.c2])
  14 - output([t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  15 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  16 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |8        |754 |
|1 | SUBPLAN FILTER     |    |8        |746 |
|2 |  TABLE SCAN        |t1  |8        |38  |
|3 |  LIMIT             |    |1        |708 |
|4 |   SUBPLAN FILTER   |    |1        |708 |
|5 |    HASH OUTER JOIN |    |4        |87  |
|6 |     TABLE SCAN     |t1  |8        |38  |
|7 |     TABLE SCAN     |t2  |5        |37  |
|8 |    HASH JOIN       |    |1        |80  |
|9 |     TABLE SCAN     |t4  |1        |39  |
|10|     TABLE SCAN     |t3  |8        |38  |
|11|    MERGE OUTER JOIN|    |1        |76  |
|12|     TABLE SCAN     |t5  |1        |38  |
|13|     TABLE SCAN     |t6  |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))], [(T_OP_NOT_EXISTS, subquery(2))]), 
      exec_params_([t2.c2], [t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t4.c1]), filter([? = t4.c2]), 
      access([t4.c1], [t4.c2]), partitions(p0)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  12 - output([t5.c1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  13 - output([t6.c1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                   |     |1        |318 |
|1 | SUBPLAN FILTER          |     |1        |317 |
|2 |  TABLE SCAN             |t1   |1        |39  |
|3 |  LIMIT                  |     |1        |279 |
|4 |   HASH SEMI JOIN        |     |3        |279 |
|5 |    HASH JOIN            |     |3        |178 |
|6 |     HASH RIGHT ANTI JOIN|     |3        |133 |
|7 |      SUBPLAN SCAN       |VIEW2|5        |85  |
|8 |       HASH OUTER JOIN   |     |5        |84  |
|9 |        TABLE SCAN       |t5   |5        |37  |
|10|        TABLE SCAN       |t6   |5        |37  |
|11|      TABLE SCAN         |t1   |8        |38  |
|12|     TABLE SCAN          |t2   |9        |38  |
|13|    SUBPLAN SCAN         |VIEW1|8        |92  |
|14|     HASH JOIN           |     |8        |91  |
|15|      TABLE SCAN         |t3   |8        |38  |
|16|      TABLE SCAN         |t4   |8        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c2 = VIEW1.t4.c2]), other_conds(nil)
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.t5.c1]), other_conds(nil)
  7 - output([VIEW2.t5.c1]), filter(nil), 
      access([VIEW2.t5.c1])
  8 - output([t5.c1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  9 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  10 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p0)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  13 - output([VIEW1.t4.c2]), filter(nil), 
      access([VIEW1.t4.c2])
  14 - output([t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  15 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  16 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |747 |
|1 | SUBPLAN FILTER     |    |1        |746 |
|2 |  TABLE SCAN        |t1  |1        |39  |
|3 |  LIMIT             |    |1        |708 |
|4 |   SUBPLAN FILTER   |    |1        |708 |
|5 |    HASH OUTER JOIN |    |4        |87  |
|6 |     TABLE SCAN     |t1  |8        |38  |
|7 |     TABLE SCAN     |t2  |5        |37  |
|8 |    HASH JOIN       |    |1        |80  |
|9 |     TABLE SCAN     |t4  |1        |39  |
|10|     TABLE SCAN     |t3  |8        |38  |
|11|    MERGE OUTER JOIN|    |1        |76  |
|12|     TABLE SCAN     |t5  |1        |38  |
|13|     TABLE SCAN     |t6  |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))], [(T_OP_NOT_EXISTS, subquery(2))]), 
      exec_params_([t2.c2], [t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t4.c1]), filter([? = t4.c2]), 
      access([t4.c1], [t4.c2]), partitions(p0)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  12 - output([t5.c1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  13 - output([t6.c1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |HASH OUTER JOIN         |     |3        |279 |
|1 | HASH SEMI JOIN         |     |3        |233 |
|2 |  HASH RIGHT ANTI JOIN  |     |3        |133 |
|3 |   SUBPLAN SCAN         |VIEW2|5        |85  |
|4 |    HASH OUTER JOIN     |     |5        |84  |
|5 |     TABLE SCAN         |t5   |5        |37  |
|6 |     TABLE SCAN         |t6   |5        |37  |
|7 |   TABLE SCAN           |t1   |8        |38  |
|8 |  SUBPLAN SCAN          |VIEW1|8        |92  |
|9 |   HASH RIGHT OUTER JOIN|     |8        |91  |
|10|    TABLE SCAN          |t4   |8        |38  |
|11|    TABLE SCAN          |t3   |8        |38  |
|12| TABLE SCAN             |t2   |9        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = VIEW1.t3.c2]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.t5.c1]), other_conds(nil)
  3 - output([VIEW2.t5.c1]), filter(nil), 
      access([VIEW2.t5.c1])
  4 - output([t5.c1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  5 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  6 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([VIEW1.t3.c2]), filter(nil), 
      access([VIEW1.t3.c2])
  9 - output([t3.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  12 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    5 |    5 | NULL | NULL |
| NULL |    1 | NULL | NULL |
| NULL |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER   |    |2        |1335|
|1 | HASH OUTER JOIN |    |8        |93  |
|2 |  TABLE SCAN     |t1  |8        |38  |
|3 |  TABLE SCAN     |t2  |9        |38  |
|4 | HASH OUTER JOIN |    |1        |80  |
|5 |  TABLE SCAN     |t3  |1        |39  |
|6 |  TABLE SCAN     |t4  |8        |38  |
|7 | MERGE OUTER JOIN|    |1        |76  |
|8 |  TABLE SCAN     |t5  |1        |38  |
|9 |  TABLE SCAN     |t6  |1        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))], [(T_OP_NOT_EXISTS, subquery(2))]), 
      exec_params_([t1.c2], [t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  5 - output([t3.c1]), filter([? = t3.c2]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  7 - output([1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  8 - output([t5.c1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  9 - output([t6.c1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    5 |    5 | NULL | NULL |
| NULL |    1 | NULL | NULL |
| NULL |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1));
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT                    |     |3        |280 |
|1 | SUBPLAN SCAN             |VIEW1|3        |280 |
|2 |  HASH OUTER JOIN         |     |3        |279 |
|3 |   HASH SEMI JOIN         |     |3        |233 |
|4 |    HASH RIGHT ANTI JOIN  |     |3        |133 |
|5 |     SUBPLAN SCAN         |VIEW3|5        |85  |
|6 |      HASH OUTER JOIN     |     |5        |84  |
|7 |       TABLE SCAN         |t5   |5        |37  |
|8 |       TABLE SCAN         |t6   |5        |37  |
|9 |     TABLE SCAN           |t1   |8        |38  |
|10|    SUBPLAN SCAN          |VIEW2|8        |92  |
|11|     HASH RIGHT OUTER JOIN|     |8        |91  |
|12|      TABLE SCAN          |t4   |8        |38  |
|13|      TABLE SCAN          |t3   |8        |38  |
|14|   TABLE SCAN             |t2   |9        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = VIEW2.t3.c2]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW3.t5.c1]), other_conds(nil)
  5 - output([VIEW3.t5.c1]), filter(nil), 
      access([VIEW3.t5.c1])
  6 - output([t5.c1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  7 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  8 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p0)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  10 - output([VIEW2.t3.c2]), filter(nil), 
      access([VIEW2.t3.c2])
  11 - output([t3.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  12 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  13 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  14 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1));
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |2        |1335|
|1 | SUBPLAN SCAN      |VIEW1|2        |1335|
|2 |  SUBPLAN FILTER   |     |2        |1335|
|3 |   HASH OUTER JOIN |     |8        |93  |
|4 |    TABLE SCAN     |t1   |8        |38  |
|5 |    TABLE SCAN     |t2   |9        |38  |
|6 |   HASH OUTER JOIN |     |1        |80  |
|7 |    TABLE SCAN     |t3   |1        |39  |
|8 |    TABLE SCAN     |t4   |8        |38  |
|9 |   MERGE OUTER JOIN|     |1        |76  |
|10|    TABLE SCAN     |t5   |1        |38  |
|11|    TABLE SCAN     |t6   |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))], [(T_OP_NOT_EXISTS, subquery(2))]), 
      exec_params_([t1.c2], [t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1]), filter([? = t3.c2]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  10 - output([t5.c1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  11 - output([t6.c1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
Query Plan
=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |UPDATE                     |     |8        |321 |
|1 | SUBPLAN FILTER            |     |8        |313 |
|2 |  TABLE SCAN               |t1   |8        |38  |
|3 |  LIMIT                    |     |1        |275 |
|4 |   HASH OUTER JOIN         |     |1        |275 |
|5 |    HASH SEMI JOIN         |     |3        |233 |
|6 |     HASH RIGHT ANTI JOIN  |     |3        |133 |
|7 |      SUBPLAN SCAN         |VIEW2|5        |85  |
|8 |       HASH OUTER JOIN     |     |5        |84  |
|9 |        TABLE SCAN         |t5   |5        |37  |
|10|        TABLE SCAN         |t6   |5        |37  |
|11|      TABLE SCAN           |t1   |8        |38  |
|12|     SUBPLAN SCAN          |VIEW1|8        |92  |
|13|      HASH RIGHT OUTER JOIN|     |8        |91  |
|14|       TABLE SCAN          |t4   |8        |38  |
|15|       TABLE SCAN          |t3   |8        |38  |
|16|    TABLE SCAN             |t2   |3        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = VIEW1.t3.c2]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.t5.c1]), other_conds(nil)
  7 - output([VIEW2.t5.c1]), filter(nil), 
      access([VIEW2.t5.c1])
  8 - output([t5.c1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  9 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  10 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p0)
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  12 - output([VIEW1.t3.c2]), filter(nil), 
      access([VIEW1.t3.c2])
  13 - output([t3.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  14 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  15 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  16 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |8        |755 |
|1 | SUBPLAN FILTER          |    |8        |747 |
|2 |  TABLE SCAN             |t1  |8        |38  |
|3 |  LIMIT                  |    |1        |709 |
|4 |   SUBPLAN FILTER        |    |1        |709 |
|5 |    HASH RIGHT OUTER JOIN|    |4        |88  |
|6 |     TABLE SCAN          |t2  |9        |38  |
|7 |     TABLE SCAN          |t1  |4        |37  |
|8 |    HASH OUTER JOIN      |    |1        |80  |
|9 |     TABLE SCAN          |t3  |1        |39  |
|10|     TABLE SCAN          |t4  |8        |38  |
|11|    MERGE OUTER JOIN     |    |1        |76  |
|12|     TABLE SCAN          |t5  |1        |38  |
|13|     TABLE SCAN          |t6  |1        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))], [(T_OP_NOT_EXISTS, subquery(2))]), 
      exec_params_([t1.c2], [t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter([? = t3.c2]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  12 - output([t5.c1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  13 - output([t6.c1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|       NULL |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
Query Plan
=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |DELETE                     |     |1        |314 |
|1 | SUBPLAN FILTER            |     |1        |313 |
|2 |  TABLE SCAN               |t1   |1        |39  |
|3 |  LIMIT                    |     |1        |275 |
|4 |   HASH OUTER JOIN         |     |1        |275 |
|5 |    HASH SEMI JOIN         |     |3        |233 |
|6 |     HASH RIGHT ANTI JOIN  |     |3        |133 |
|7 |      SUBPLAN SCAN         |VIEW2|5        |85  |
|8 |       HASH OUTER JOIN     |     |5        |84  |
|9 |        TABLE SCAN         |t5   |5        |37  |
|10|        TABLE SCAN         |t6   |5        |37  |
|11|      TABLE SCAN           |t1   |8        |38  |
|12|     SUBPLAN SCAN          |VIEW1|8        |92  |
|13|      HASH RIGHT OUTER JOIN|     |8        |91  |
|14|       TABLE SCAN          |t4   |8        |38  |
|15|       TABLE SCAN          |t3   |8        |38  |
|16|    TABLE SCAN             |t2   |3        |37  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = VIEW1.t3.c2]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.t5.c1]), other_conds(nil)
  7 - output([VIEW2.t5.c1]), filter(nil), 
      access([VIEW2.t5.c1])
  8 - output([t5.c1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  9 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  10 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p0)
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  12 - output([VIEW1.t3.c2]), filter(nil), 
      access([VIEW1.t3.c2])
  13 - output([t3.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  14 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  15 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  16 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |748 |
|1 | SUBPLAN FILTER          |    |1        |747 |
|2 |  TABLE SCAN             |t1  |1        |39  |
|3 |  LIMIT                  |    |1        |709 |
|4 |   SUBPLAN FILTER        |    |1        |709 |
|5 |    HASH RIGHT OUTER JOIN|    |4        |88  |
|6 |     TABLE SCAN          |t2  |9        |38  |
|7 |     TABLE SCAN          |t1  |4        |37  |
|8 |    HASH OUTER JOIN      |    |1        |80  |
|9 |     TABLE SCAN          |t3  |1        |39  |
|10|     TABLE SCAN          |t4  |8        |38  |
|11|    MERGE OUTER JOIN     |    |1        |76  |
|12|     TABLE SCAN          |t5  |1        |38  |
|13|     TABLE SCAN          |t6  |1        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))], [(T_OP_NOT_EXISTS, subquery(2))]), 
      exec_params_([t1.c2], [t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter([? = t3.c2]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  12 - output([t5.c1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  13 - output([t6.c1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t1.c2=t3.c2) and not exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1);
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |HASH JOIN             |     |1        |275 |
|1 | HASH SEMI JOIN       |     |1        |234 |
|2 |  HASH RIGHT ANTI JOIN|     |1        |146 |
|3 |   SUBPLAN SCAN       |VIEW1|8        |92  |
|4 |    HASH JOIN         |     |8        |91  |
|5 |     TABLE SCAN       |t3   |8        |38  |
|6 |     TABLE SCAN       |t4   |8        |38  |
|7 |   TABLE SCAN         |t2   |9        |38  |
|8 |  SUBPLAN SCAN        |VIEW2|5        |85  |
|9 |   HASH OUTER JOIN    |     |5        |84  |
|10|    TABLE SCAN        |t5   |5        |37  |
|11|    TABLE SCAN        |t6   |5        |37  |
|12| TABLE SCAN           |t1   |8        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = VIEW2.t5.c1]), other_conds(nil)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c2 = VIEW1.t4.c2]), other_conds(nil)
  3 - output([VIEW1.t4.c2]), filter(nil), 
      access([VIEW1.t4.c2])
  4 - output([t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([VIEW2.t5.c1]), filter(nil), 
      access([VIEW2.t5.c1])
  9 - output([t5.c1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  10 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  11 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p0)
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER   |    |2        |1335|
|1 | HASH OUTER JOIN |    |8        |93  |
|2 |  TABLE SCAN     |t1  |8        |38  |
|3 |  TABLE SCAN     |t2  |9        |38  |
|4 | HASH JOIN       |    |1        |80  |
|5 |  TABLE SCAN     |t4  |1        |39  |
|6 |  TABLE SCAN     |t3  |8        |38  |
|7 | MERGE OUTER JOIN|    |1        |76  |
|8 |  TABLE SCAN     |t5  |1        |38  |
|9 |  TABLE SCAN     |t6  |1        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))]), 
      exec_params_([t2.c2], [t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  5 - output([t4.c1]), filter([? = t4.c2]), 
      access([t4.c1], [t4.c2]), partitions(p0)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  7 - output([1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  8 - output([t5.c1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  9 - output([t6.c1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |1        |275 |
|1 | SUBPLAN SCAN           |VIEW1|1        |275 |
|2 |  HASH JOIN             |     |1        |275 |
|3 |   HASH SEMI JOIN       |     |1        |234 |
|4 |    HASH RIGHT ANTI JOIN|     |1        |146 |
|5 |     SUBPLAN SCAN       |VIEW2|8        |92  |
|6 |      HASH JOIN         |     |8        |91  |
|7 |       TABLE SCAN       |t3   |8        |38  |
|8 |       TABLE SCAN       |t4   |8        |38  |
|9 |     TABLE SCAN         |t2   |9        |38  |
|10|    SUBPLAN SCAN        |VIEW3|5        |85  |
|11|     HASH OUTER JOIN    |     |5        |84  |
|12|      TABLE SCAN        |t5   |5        |37  |
|13|      TABLE SCAN        |t6   |5        |37  |
|14|   TABLE SCAN           |t1   |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = VIEW3.t5.c1]), other_conds(nil)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c2 = VIEW2.t4.c2]), other_conds(nil)
  5 - output([VIEW2.t4.c2]), filter(nil), 
      access([VIEW2.t4.c2])
  6 - output([t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  10 - output([VIEW3.t5.c1]), filter(nil), 
      access([VIEW3.t5.c1])
  11 - output([t5.c1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  12 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  13 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p0)
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1));
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |2        |1335|
|1 | SUBPLAN SCAN      |VIEW1|2        |1335|
|2 |  SUBPLAN FILTER   |     |2        |1335|
|3 |   HASH OUTER JOIN |     |8        |93  |
|4 |    TABLE SCAN     |t1   |8        |38  |
|5 |    TABLE SCAN     |t2   |9        |38  |
|6 |   HASH JOIN       |     |1        |80  |
|7 |    TABLE SCAN     |t4   |1        |39  |
|8 |    TABLE SCAN     |t3   |8        |38  |
|9 |   MERGE OUTER JOIN|     |1        |76  |
|10|    TABLE SCAN     |t5   |1        |38  |
|11|    TABLE SCAN     |t6   |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))]), 
      exec_params_([t2.c2], [t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t4.c1]), filter([? = t4.c2]), 
      access([t4.c1], [t4.c2]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  10 - output([t5.c1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  11 - output([t6.c1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1) limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                   |     |8        |321 |
|1 | SUBPLAN FILTER          |     |8        |313 |
|2 |  TABLE SCAN             |t1   |8        |38  |
|3 |  LIMIT                  |     |1        |275 |
|4 |   HASH JOIN             |     |1        |275 |
|5 |    HASH SEMI JOIN       |     |1        |234 |
|6 |     HASH RIGHT ANTI JOIN|     |1        |146 |
|7 |      SUBPLAN SCAN       |VIEW1|8        |92  |
|8 |       HASH JOIN         |     |8        |91  |
|9 |        TABLE SCAN       |t3   |8        |38  |
|10|        TABLE SCAN       |t4   |8        |38  |
|11|      TABLE SCAN         |t2   |9        |38  |
|12|     SUBPLAN SCAN        |VIEW2|5        |85  |
|13|      HASH OUTER JOIN    |     |5        |84  |
|14|       TABLE SCAN        |t5   |5        |37  |
|15|       TABLE SCAN        |t6   |5        |37  |
|16|    TABLE SCAN           |t1   |8        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = VIEW2.t5.c1]), other_conds(nil)
  6 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = VIEW1.t4.c2]), other_conds(nil)
  7 - output([VIEW1.t4.c2]), filter(nil), 
      access([VIEW1.t4.c2])
  8 - output([t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  12 - output([VIEW2.t5.c1]), filter(nil), 
      access([VIEW2.t5.c1])
  13 - output([t5.c1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  14 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  15 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p0)
  16 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |8        |754 |
|1 | SUBPLAN FILTER     |    |8        |746 |
|2 |  TABLE SCAN        |t1  |8        |38  |
|3 |  LIMIT             |    |1        |708 |
|4 |   SUBPLAN FILTER   |    |1        |708 |
|5 |    HASH OUTER JOIN |    |4        |87  |
|6 |     TABLE SCAN     |t1  |8        |38  |
|7 |     TABLE SCAN     |t2  |5        |37  |
|8 |    HASH JOIN       |    |1        |80  |
|9 |     TABLE SCAN     |t4  |1        |39  |
|10|     TABLE SCAN     |t3  |8        |38  |
|11|    MERGE OUTER JOIN|    |1        |76  |
|12|     TABLE SCAN     |t5  |1        |38  |
|13|     TABLE SCAN     |t6  |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))]), 
      exec_params_([t2.c2], [t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c2], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t4.c1]), filter([? = t4.c2]), 
      access([t4.c1], [t4.c2]), partitions(p0)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  12 - output([t5.c1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  13 - output([t6.c1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1) limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                   |     |1        |314 |
|1 | SUBPLAN FILTER          |     |1        |313 |
|2 |  TABLE SCAN             |t1   |1        |39  |
|3 |  LIMIT                  |     |1        |275 |
|4 |   HASH JOIN             |     |1        |275 |
|5 |    HASH SEMI JOIN       |     |1        |234 |
|6 |     HASH RIGHT ANTI JOIN|     |1        |146 |
|7 |      SUBPLAN SCAN       |VIEW1|8        |92  |
|8 |       HASH JOIN         |     |8        |91  |
|9 |        TABLE SCAN       |t3   |8        |38  |
|10|        TABLE SCAN       |t4   |8        |38  |
|11|      TABLE SCAN         |t2   |9        |38  |
|12|     SUBPLAN SCAN        |VIEW2|5        |85  |
|13|      HASH OUTER JOIN    |     |5        |84  |
|14|       TABLE SCAN        |t5   |5        |37  |
|15|       TABLE SCAN        |t6   |5        |37  |
|16|    TABLE SCAN           |t1   |8        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = VIEW2.t5.c1]), other_conds(nil)
  6 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = VIEW1.t4.c2]), other_conds(nil)
  7 - output([VIEW1.t4.c2]), filter(nil), 
      access([VIEW1.t4.c2])
  8 - output([t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  12 - output([VIEW2.t5.c1]), filter(nil), 
      access([VIEW2.t5.c1])
  13 - output([t5.c1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  14 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  15 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p0)
  16 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.3226495451672298 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |747 |
|1 | SUBPLAN FILTER     |    |1        |746 |
|2 |  TABLE SCAN        |t1  |1        |39  |
|3 |  LIMIT             |    |1        |708 |
|4 |   SUBPLAN FILTER   |    |1        |708 |
|5 |    HASH OUTER JOIN |    |4        |87  |
|6 |     TABLE SCAN     |t1  |8        |38  |
|7 |     TABLE SCAN     |t2  |5        |37  |
|8 |    HASH JOIN       |    |1        |80  |
|9 |     TABLE SCAN     |t4  |1        |39  |
|10|     TABLE SCAN     |t3  |8        |38  |
|11|    MERGE OUTER JOIN|    |1        |76  |
|12|     TABLE SCAN     |t5  |1        |38  |
|13|     TABLE SCAN     |t6  |1        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))]), 
      exec_params_([t2.c2], [t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c2], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t4.c1]), filter([? = t4.c2]), 
      access([t4.c1], [t4.c2]), partitions(p0)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([1]), filter(nil), 
      equal_conds([t5.c1 = t6.c1]), other_conds(nil)
  12 - output([t5.c1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  13 - output([t6.c1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 left join t4 on t3.c1=t4.c1 where t2.c2=t4.c2) and exists (select 1 from t5 left join t6 on t5.c1=t6.c1 where t2.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.3226495451672298 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1));
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |SUBPLAN FILTER                |    |4        |1372|
|1 | HASH OUTER JOIN              |    |8        |93  |
|2 |  TABLE SCAN                  |t1  |8        |38  |
|3 |  TABLE SCAN                  |t2  |9        |38  |
|4 | LIMIT                        |    |1        |160 |
|5 |  SUBPLAN FILTER              |    |1        |160 |
|6 |   HASH OUTER JOIN            |    |2        |84  |
|7 |    TABLE SCAN                |t3  |8        |38  |
|8 |    TABLE SCAN                |t4  |2        |37  |
|9 |   LIMIT                      |    |1        |76  |
|10|    NESTED-LOOP JOIN CARTESIAN|    |1        |76  |
|11|     TABLE SCAN               |t5  |1        |38  |
|12|     MATERIAL                 |    |1        |38  |
|13|      TABLE SCAN              |t6  |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([NULL]), filter(nil), limit(1), offset(nil)
  5 - output([1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  6 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([NULL]), filter(nil), limit(1), offset(nil)
  10 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  11 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1));
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1));
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |SUBPLAN FILTER               |    |4        |1434|
|1 | HASH OUTER JOIN             |    |8        |93  |
|2 |  TABLE SCAN                 |t1  |8        |38  |
|3 |  TABLE SCAN                 |t2  |9        |38  |
|4 | SUBPLAN FILTER              |    |4        |167 |
|5 |  HASH OUTER JOIN            |    |8        |91  |
|6 |   TABLE SCAN                |t3  |8        |38  |
|7 |   TABLE SCAN                |t4  |8        |38  |
|8 |  LIMIT                      |    |1        |76  |
|9 |   NESTED-LOOP JOIN CARTESIAN|    |1        |76  |
|10|    TABLE SCAN               |t5  |1        |38  |
|11|    MATERIAL                 |    |1        |38  |
|12|     TABLE SCAN              |t6  |1        |38  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([NULL]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  5 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([NULL]), filter(nil), limit(1), offset(nil)
  9 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  10 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  11 - output([1]), filter(nil)
  12 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1));
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)));
Query Plan
==========================================================
|ID|OPERATOR                        |NAME |EST. ROWS|COST|
----------------------------------------------------------
|0 |INSERT                          |     |4        |1373|
|1 | SUBPLAN SCAN                   |VIEW1|4        |1372|
|2 |  SUBPLAN FILTER                |     |4        |1372|
|3 |   HASH OUTER JOIN              |     |8        |93  |
|4 |    TABLE SCAN                  |t1   |8        |38  |
|5 |    TABLE SCAN                  |t2   |9        |38  |
|6 |   LIMIT                        |     |1        |160 |
|7 |    SUBPLAN FILTER              |     |1        |160 |
|8 |     HASH OUTER JOIN            |     |2        |84  |
|9 |      TABLE SCAN                |t3   |8        |38  |
|10|      TABLE SCAN                |t4   |2        |37  |
|11|     LIMIT                      |     |1        |76  |
|12|      NESTED-LOOP JOIN CARTESIAN|     |1        |76  |
|13|       TABLE SCAN               |t5   |1        |38  |
|14|       MATERIAL                 |     |1        |38  |
|15|        TABLE SCAN              |t6   |1        |38  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([NULL]), filter(nil), limit(1), offset(nil)
  7 - output([1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  8 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([NULL]), filter(nil), limit(1), offset(nil)
  12 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  13 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  14 - output([1]), filter(nil)
  15 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)));
Query Plan
=========================================================
|ID|OPERATOR                       |NAME |EST. ROWS|COST|
---------------------------------------------------------
|0 |INSERT                         |     |4        |1435|
|1 | SUBPLAN SCAN                  |VIEW1|4        |1434|
|2 |  SUBPLAN FILTER               |     |4        |1434|
|3 |   HASH OUTER JOIN             |     |8        |93  |
|4 |    TABLE SCAN                 |t1   |8        |38  |
|5 |    TABLE SCAN                 |t2   |9        |38  |
|6 |   SUBPLAN FILTER              |     |4        |167 |
|7 |    HASH OUTER JOIN            |     |8        |91  |
|8 |     TABLE SCAN                |t3   |8        |38  |
|9 |     TABLE SCAN                |t4   |8        |38  |
|10|    LIMIT                      |     |1        |76  |
|11|     NESTED-LOOP JOIN CARTESIAN|     |1        |76  |
|12|      TABLE SCAN               |t5   |1        |38  |
|13|      MATERIAL                 |     |1        |38  |
|14|       TABLE SCAN              |t6   |1        |38  |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([NULL]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  7 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([NULL]), filter(nil), limit(1), offset(nil)
  11 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  12 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  13 - output([1]), filter(nil)
  14 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
Query Plan
==========================================================
|ID|OPERATOR                         |NAME|EST. ROWS|COST|
----------------------------------------------------------
|0 |UPDATE                           |    |8        |451 |
|1 | SUBPLAN FILTER                  |    |8        |443 |
|2 |  TABLE SCAN                     |t1  |8        |38  |
|3 |  LIMIT                          |    |1        |404 |
|4 |   SUBPLAN FILTER                |    |1        |404 |
|5 |    HASH OUTER JOIN              |    |2        |85  |
|6 |     TABLE SCAN                  |t1  |8        |38  |
|7 |     TABLE SCAN                  |t2  |3        |37  |
|8 |    LIMIT                        |    |1        |160 |
|9 |     SUBPLAN FILTER              |    |1        |160 |
|10|      HASH OUTER JOIN            |    |2        |84  |
|11|       TABLE SCAN                |t3  |8        |38  |
|12|       TABLE SCAN                |t4  |2        |37  |
|13|      LIMIT                      |    |1        |76  |
|14|       NESTED-LOOP JOIN CARTESIAN|    |1        |76  |
|15|        TABLE SCAN               |t5  |1        |38  |
|16|        MATERIAL                 |    |1        |38  |
|17|         TABLE SCAN              |t6  |1        |38  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([NULL]), filter(nil), limit(1), offset(nil)
  9 - output([1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  10 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  13 - output([NULL]), filter(nil), limit(1), offset(nil)
  14 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  15 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  16 - output([1]), filter(nil)
  17 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
Query Plan
=========================================================
|ID|OPERATOR                        |NAME|EST. ROWS|COST|
---------------------------------------------------------
|0 |UPDATE                          |    |8        |466 |
|1 | SUBPLAN FILTER                 |    |8        |458 |
|2 |  TABLE SCAN                    |t1  |8        |38  |
|3 |  LIMIT                         |    |1        |420 |
|4 |   SUBPLAN FILTER               |    |1        |420 |
|5 |    HASH OUTER JOIN             |    |2        |85  |
|6 |     TABLE SCAN                 |t1  |8        |38  |
|7 |     TABLE SCAN                 |t2  |3        |37  |
|8 |    SUBPLAN FILTER              |    |4        |167 |
|9 |     HASH OUTER JOIN            |    |8        |91  |
|10|      TABLE SCAN                |t3  |8        |38  |
|11|      TABLE SCAN                |t4  |8        |38  |
|12|     LIMIT                      |    |1        |76  |
|13|      NESTED-LOOP JOIN CARTESIAN|    |1        |76  |
|14|       TABLE SCAN               |t5  |1        |38  |
|15|       MATERIAL                 |    |1        |38  |
|16|        TABLE SCAN              |t6  |1        |38  |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([NULL]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  9 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([NULL]), filter(nil), limit(1), offset(nil)
  13 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  14 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  15 - output([1]), filter(nil)
  16 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
Query Plan
==========================================================
|ID|OPERATOR                         |NAME|EST. ROWS|COST|
----------------------------------------------------------
|0 |DELETE                           |    |1        |443 |
|1 | SUBPLAN FILTER                  |    |1        |442 |
|2 |  TABLE SCAN                     |t1  |1        |39  |
|3 |  LIMIT                          |    |1        |404 |
|4 |   SUBPLAN FILTER                |    |1        |404 |
|5 |    HASH OUTER JOIN              |    |2        |85  |
|6 |     TABLE SCAN                  |t1  |8        |38  |
|7 |     TABLE SCAN                  |t2  |3        |37  |
|8 |    LIMIT                        |    |1        |160 |
|9 |     SUBPLAN FILTER              |    |1        |160 |
|10|      HASH OUTER JOIN            |    |2        |84  |
|11|       TABLE SCAN                |t3  |8        |38  |
|12|       TABLE SCAN                |t4  |2        |37  |
|13|      LIMIT                      |    |1        |76  |
|14|       NESTED-LOOP JOIN CARTESIAN|    |1        |76  |
|15|        TABLE SCAN               |t5  |1        |38  |
|16|        MATERIAL                 |    |1        |38  |
|17|         TABLE SCAN              |t6  |1        |38  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([NULL]), filter(nil), limit(1), offset(nil)
  9 - output([1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  10 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  13 - output([NULL]), filter(nil), limit(1), offset(nil)
  14 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  15 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  16 - output([1]), filter(nil)
  17 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
Query Plan
=========================================================
|ID|OPERATOR                        |NAME|EST. ROWS|COST|
---------------------------------------------------------
|0 |DELETE                          |    |1        |459 |
|1 | SUBPLAN FILTER                 |    |1        |458 |
|2 |  TABLE SCAN                    |t1  |1        |39  |
|3 |  LIMIT                         |    |1        |420 |
|4 |   SUBPLAN FILTER               |    |1        |420 |
|5 |    HASH OUTER JOIN             |    |2        |85  |
|6 |     TABLE SCAN                 |t1  |8        |38  |
|7 |     TABLE SCAN                 |t2  |3        |37  |
|8 |    SUBPLAN FILTER              |    |4        |167 |
|9 |     HASH OUTER JOIN            |    |8        |91  |
|10|      TABLE SCAN                |t3  |8        |38  |
|11|      TABLE SCAN                |t4  |8        |38  |
|12|     LIMIT                      |    |1        |76  |
|13|      NESTED-LOOP JOIN CARTESIAN|    |1        |76  |
|14|       TABLE SCAN               |t5  |1        |38  |
|15|       MATERIAL                 |    |1        |38  |
|16|        TABLE SCAN              |t6  |1        |38  |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([NULL]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  9 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([NULL]), filter(nil), limit(1), offset(nil)
  13 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  14 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  15 - output([1]), filter(nil)
  16 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1));
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |SUBPLAN FILTER                |    |4        |1311|
|1 | HASH OUTER JOIN              |    |8        |93  |
|2 |  TABLE SCAN                  |t1  |8        |38  |
|3 |  TABLE SCAN                  |t2  |9        |38  |
|4 | LIMIT                        |    |1        |153 |
|5 |  SUBPLAN FILTER              |    |1        |152 |
|6 |   NESTED-LOOP JOIN CARTESIAN |    |1        |77  |
|7 |    TABLE SCAN                |t3  |1        |38  |
|8 |    MATERIAL                  |    |1        |39  |
|9 |     TABLE SCAN               |t4  |1        |38  |
|10|   LIMIT                      |    |1        |76  |
|11|    NESTED-LOOP JOIN CARTESIAN|    |1        |76  |
|12|     TABLE SCAN               |t5  |1        |38  |
|13|     MATERIAL                 |    |1        |38  |
|14|      TABLE SCAN              |t6  |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([NULL]), filter(nil), limit(1), offset(nil)
  5 - output([1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)
  10 - output([NULL]), filter(nil), limit(1), offset(nil)
  11 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  12 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  13 - output([1]), filter(nil)
  14 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1));
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1));
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |SUBPLAN FILTER               |    |4        |1311|
|1 | HASH OUTER JOIN             |    |8        |93  |
|2 |  TABLE SCAN                 |t1  |8        |38  |
|3 |  TABLE SCAN                 |t2  |9        |38  |
|4 | SUBPLAN FILTER              |    |1        |152 |
|5 |  NESTED-LOOP JOIN CARTESIAN |    |1        |77  |
|6 |   TABLE SCAN                |t3  |1        |38  |
|7 |   MATERIAL                  |    |1        |39  |
|8 |    TABLE SCAN               |t4  |1        |38  |
|9 |  LIMIT                      |    |1        |76  |
|10|   NESTED-LOOP JOIN CARTESIAN|    |1        |76  |
|11|    TABLE SCAN               |t5  |1        |38  |
|12|    MATERIAL                 |    |1        |38  |
|13|     TABLE SCAN              |t6  |1        |38  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([NULL]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  5 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  7 - output([1]), filter(nil)
  8 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)
  9 - output([NULL]), filter(nil), limit(1), offset(nil)
  10 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  11 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1));
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)));
Query Plan
==========================================================
|ID|OPERATOR                        |NAME |EST. ROWS|COST|
----------------------------------------------------------
|0 |INSERT                          |     |4        |1312|
|1 | SUBPLAN SCAN                   |VIEW1|4        |1312|
|2 |  SUBPLAN FILTER                |     |4        |1311|
|3 |   HASH OUTER JOIN              |     |8        |93  |
|4 |    TABLE SCAN                  |t1   |8        |38  |
|5 |    TABLE SCAN                  |t2   |9        |38  |
|6 |   LIMIT                        |     |1        |153 |
|7 |    SUBPLAN FILTER              |     |1        |152 |
|8 |     NESTED-LOOP JOIN CARTESIAN |     |1        |77  |
|9 |      TABLE SCAN                |t3   |1        |38  |
|10|      MATERIAL                  |     |1        |39  |
|11|       TABLE SCAN               |t4   |1        |38  |
|12|     LIMIT                      |     |1        |76  |
|13|      NESTED-LOOP JOIN CARTESIAN|     |1        |76  |
|14|       TABLE SCAN               |t5   |1        |38  |
|15|       MATERIAL                 |     |1        |38  |
|16|        TABLE SCAN              |t6   |1        |38  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([NULL]), filter(nil), limit(1), offset(nil)
  7 - output([1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  8 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  9 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)
  12 - output([NULL]), filter(nil), limit(1), offset(nil)
  13 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  14 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  15 - output([1]), filter(nil)
  16 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)));
Query Plan
=========================================================
|ID|OPERATOR                       |NAME |EST. ROWS|COST|
---------------------------------------------------------
|0 |INSERT                         |     |4        |1312|
|1 | SUBPLAN SCAN                  |VIEW1|4        |1311|
|2 |  SUBPLAN FILTER               |     |4        |1311|
|3 |   HASH OUTER JOIN             |     |8        |93  |
|4 |    TABLE SCAN                 |t1   |8        |38  |
|5 |    TABLE SCAN                 |t2   |9        |38  |
|6 |   SUBPLAN FILTER              |     |1        |152 |
|7 |    NESTED-LOOP JOIN CARTESIAN |     |1        |77  |
|8 |     TABLE SCAN                |t3   |1        |38  |
|9 |     MATERIAL                  |     |1        |39  |
|10|      TABLE SCAN               |t4   |1        |38  |
|11|    LIMIT                      |     |1        |76  |
|12|     NESTED-LOOP JOIN CARTESIAN|     |1        |76  |
|13|      TABLE SCAN               |t5   |1        |38  |
|14|      MATERIAL                 |     |1        |38  |
|15|       TABLE SCAN              |t6   |1        |38  |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([NULL]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  7 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  8 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)
  11 - output([NULL]), filter(nil), limit(1), offset(nil)
  12 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  13 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  14 - output([1]), filter(nil)
  15 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
Query Plan
==========================================================
|ID|OPERATOR                         |NAME|EST. ROWS|COST|
----------------------------------------------------------
|0 |UPDATE                           |    |8        |436 |
|1 | SUBPLAN FILTER                  |    |8        |428 |
|2 |  TABLE SCAN                     |t1  |8        |38  |
|3 |  LIMIT                          |    |1        |389 |
|4 |   SUBPLAN FILTER                |    |1        |389 |
|5 |    HASH OUTER JOIN              |    |2        |85  |
|6 |     TABLE SCAN                  |t1  |8        |38  |
|7 |     TABLE SCAN                  |t2  |3        |37  |
|8 |    LIMIT                        |    |1        |153 |
|9 |     SUBPLAN FILTER              |    |1        |152 |
|10|      NESTED-LOOP JOIN CARTESIAN |    |1        |77  |
|11|       TABLE SCAN                |t3  |1        |38  |
|12|       MATERIAL                  |    |1        |39  |
|13|        TABLE SCAN               |t4  |1        |38  |
|14|      LIMIT                      |    |1        |76  |
|15|       NESTED-LOOP JOIN CARTESIAN|    |1        |76  |
|16|        TABLE SCAN               |t5  |1        |38  |
|17|        MATERIAL                 |    |1        |38  |
|18|         TABLE SCAN              |t6  |1        |38  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([NULL]), filter(nil), limit(1), offset(nil)
  9 - output([1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  10 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  11 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)
  14 - output([NULL]), filter(nil), limit(1), offset(nil)
  15 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  16 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  17 - output([1]), filter(nil)
  18 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
Query Plan
=========================================================
|ID|OPERATOR                        |NAME|EST. ROWS|COST|
---------------------------------------------------------
|0 |UPDATE                          |    |8        |435 |
|1 | SUBPLAN FILTER                 |    |8        |427 |
|2 |  TABLE SCAN                    |t1  |8        |38  |
|3 |  LIMIT                         |    |1        |389 |
|4 |   SUBPLAN FILTER               |    |1        |389 |
|5 |    HASH OUTER JOIN             |    |2        |85  |
|6 |     TABLE SCAN                 |t1  |8        |38  |
|7 |     TABLE SCAN                 |t2  |3        |37  |
|8 |    SUBPLAN FILTER              |    |1        |152 |
|9 |     NESTED-LOOP JOIN CARTESIAN |    |1        |77  |
|10|      TABLE SCAN                |t3  |1        |38  |
|11|      MATERIAL                  |    |1        |39  |
|12|       TABLE SCAN               |t4  |1        |38  |
|13|     LIMIT                      |    |1        |76  |
|14|      NESTED-LOOP JOIN CARTESIAN|    |1        |76  |
|15|       TABLE SCAN               |t5  |1        |38  |
|16|       MATERIAL                 |    |1        |38  |
|17|        TABLE SCAN              |t6  |1        |38  |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([NULL]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  9 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  10 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  11 - output([1]), filter(nil)
  12 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)
  13 - output([NULL]), filter(nil), limit(1), offset(nil)
  14 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  15 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  16 - output([1]), filter(nil)
  17 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
Query Plan
==========================================================
|ID|OPERATOR                         |NAME|EST. ROWS|COST|
----------------------------------------------------------
|0 |DELETE                           |    |1        |428 |
|1 | SUBPLAN FILTER                  |    |1        |427 |
|2 |  TABLE SCAN                     |t1  |1        |39  |
|3 |  LIMIT                          |    |1        |389 |
|4 |   SUBPLAN FILTER                |    |1        |389 |
|5 |    HASH OUTER JOIN              |    |2        |85  |
|6 |     TABLE SCAN                  |t1  |8        |38  |
|7 |     TABLE SCAN                  |t2  |3        |37  |
|8 |    LIMIT                        |    |1        |153 |
|9 |     SUBPLAN FILTER              |    |1        |152 |
|10|      NESTED-LOOP JOIN CARTESIAN |    |1        |77  |
|11|       TABLE SCAN                |t3  |1        |38  |
|12|       MATERIAL                  |    |1        |39  |
|13|        TABLE SCAN               |t4  |1        |38  |
|14|      LIMIT                      |    |1        |76  |
|15|       NESTED-LOOP JOIN CARTESIAN|    |1        |76  |
|16|        TABLE SCAN               |t5  |1        |38  |
|17|        MATERIAL                 |    |1        |38  |
|18|         TABLE SCAN              |t6  |1        |38  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([NULL]), filter(nil), limit(1), offset(nil)
  9 - output([1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  10 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  11 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)
  14 - output([NULL]), filter(nil), limit(1), offset(nil)
  15 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  16 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  17 - output([1]), filter(nil)
  18 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
Query Plan
=========================================================
|ID|OPERATOR                        |NAME|EST. ROWS|COST|
---------------------------------------------------------
|0 |DELETE                          |    |1        |428 |
|1 | SUBPLAN FILTER                 |    |1        |427 |
|2 |  TABLE SCAN                    |t1  |1        |39  |
|3 |  LIMIT                         |    |1        |389 |
|4 |   SUBPLAN FILTER               |    |1        |389 |
|5 |    HASH OUTER JOIN             |    |2        |85  |
|6 |     TABLE SCAN                 |t1  |8        |38  |
|7 |     TABLE SCAN                 |t2  |3        |37  |
|8 |    SUBPLAN FILTER              |    |1        |152 |
|9 |     NESTED-LOOP JOIN CARTESIAN |    |1        |77  |
|10|      TABLE SCAN                |t3  |1        |38  |
|11|      MATERIAL                  |    |1        |39  |
|12|       TABLE SCAN               |t4  |1        |38  |
|13|     LIMIT                      |    |1        |76  |
|14|      NESTED-LOOP JOIN CARTESIAN|    |1        |76  |
|15|       TABLE SCAN               |t5  |1        |38  |
|16|       MATERIAL                 |    |1        |38  |
|17|        TABLE SCAN              |t6  |1        |38  |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([NULL]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  9 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  10 - output([1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  11 - output([1]), filter(nil)
  12 - output([1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)
  13 - output([NULL]), filter(nil), limit(1), offset(nil)
  14 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  15 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)
  16 - output([1]), filter(nil)
  17 - output([1]), filter([? = t6.c1]), 
      access([t6.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists( select null from t3 left join t4 on t3.c1=t4.c1 where t1.c1=t4.c1 and exists(select null from t5 left join t6 on t5.c1=t6.c1 where t1.c1=t6.c1)) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5);
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |HASH JOIN             |    |3        |144 |
|1 | NESTED-LOOP SEMI JOIN|    |3        |99  |
|2 |  TABLE SCAN          |t2  |9        |38  |
|3 |  MATERIAL            |    |8        |39  |
|4 |   TABLE SCAN         |t3  |8        |38  |
|5 | TABLE SCAN           |t1  |8        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      conds([t2.c1 + t3.c1 < 5]), nl_params_(nil)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  3 - output([t3.c1]), filter(nil)
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    3 |    2 |    3 |    3 |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |4        |400 |
|1 | HASH OUTER JOIN|    |8        |93  |
|2 |  TABLE SCAN    |t1  |8        |38  |
|3 |  TABLE SCAN    |t2  |9        |38  |
|4 | TABLE SCAN     |t3  |3        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter([? + t3.c1 < 5]), 
      access([t3.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    3 |    2 |    3 |    3 |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |3        |145 |
|1 | SUBPLAN SCAN           |VIEW1|3        |144 |
|2 |  HASH JOIN             |     |3        |144 |
|3 |   NESTED-LOOP SEMI JOIN|     |3        |99  |
|4 |    TABLE SCAN          |t2   |9        |38  |
|5 |    MATERIAL            |     |8        |39  |
|6 |     TABLE SCAN         |t3   |8        |38  |
|7 |   TABLE SCAN           |t1   |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      conds([t2.c1 + t3.c1 < 5]), nl_params_(nil)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  5 - output([t3.c1]), filter(nil)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |4        |402 |
|1 | SUBPLAN SCAN     |VIEW1|4        |401 |
|2 |  SUBPLAN FILTER  |     |4        |400 |
|3 |   HASH OUTER JOIN|     |8        |93  |
|4 |    TABLE SCAN    |t1   |8        |38  |
|5 |    TABLE SCAN    |t2   |9        |38  |
|6 |   TABLE SCAN     |t3   |3        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter([? + t3.c1 < 5]), 
      access([t3.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |8        |178 |
|1 | SUBPLAN FILTER         |    |8        |170 |
|2 |  TABLE SCAN            |t1  |8        |38  |
|3 |  LIMIT                 |    |1        |132 |
|4 |   NESTED-LOOP SEMI JOIN|    |1        |132 |
|5 |    HASH JOIN           |    |3        |86  |
|6 |     TABLE SCAN         |t1  |8        |38  |
|7 |     TABLE SCAN         |t2  |4        |37  |
|8 |    MATERIAL            |    |8        |39  |
|9 |     TABLE SCAN         |t3  |8        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t2.c1 + t3.c1 < 5]), nl_params_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |8        |208 |
|1 | SUBPLAN FILTER    |    |8        |200 |
|2 |  TABLE SCAN       |t1  |8        |38  |
|3 |  LIMIT            |    |1        |161 |
|4 |   SUBPLAN FILTER  |    |1        |161 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |3        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([? + t3.c1 < 5]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |171 |
|1 | SUBPLAN FILTER         |    |1        |170 |
|2 |  TABLE SCAN            |t1  |1        |39  |
|3 |  LIMIT                 |    |1        |132 |
|4 |   NESTED-LOOP SEMI JOIN|    |1        |132 |
|5 |    HASH JOIN           |    |3        |86  |
|6 |     TABLE SCAN         |t1  |8        |38  |
|7 |     TABLE SCAN         |t2  |4        |37  |
|8 |    MATERIAL            |    |8        |39  |
|9 |     TABLE SCAN         |t3  |8        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t2.c1 + t3.c1 < 5]), nl_params_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |201 |
|1 | SUBPLAN FILTER    |    |1        |200 |
|2 |  TABLE SCAN       |t1  |1        |39  |
|3 |  LIMIT            |    |1        |161 |
|4 |   SUBPLAN FILTER  |    |1        |161 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |3        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([? + t3.c1 < 5]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5);
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|    |6        |151 |
|1 | HASH OUTER JOIN     |    |8        |93  |
|2 |  TABLE SCAN         |t1  |8        |38  |
|3 |  TABLE SCAN         |t2  |9        |38  |
|4 | MATERIAL            |    |8        |39  |
|5 |  TABLE SCAN         |t3  |8        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      conds([t2.c1 + t3.c1 < 5]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t3.c1]), filter(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    4 |    2 |    4 |    4 |
|    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL |
| NULL |    1 | NULL | NULL |
| NULL |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |4        |400 |
|1 | HASH OUTER JOIN|    |8        |93  |
|2 |  TABLE SCAN    |t1  |8        |38  |
|3 |  TABLE SCAN    |t2  |9        |38  |
|4 | TABLE SCAN     |t3  |3        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter([? + t3.c1 < 5]), 
      access([t3.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    4 |    2 |    4 |    4 |
|    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL |
| NULL |    1 | NULL | NULL |
| NULL |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5));
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |6        |153 |
|1 | SUBPLAN SCAN          |VIEW1|6        |152 |
|2 |  NESTED-LOOP ANTI JOIN|     |6        |151 |
|3 |   HASH OUTER JOIN     |     |8        |93  |
|4 |    TABLE SCAN         |t1   |8        |38  |
|5 |    TABLE SCAN         |t2   |9        |38  |
|6 |   MATERIAL            |     |8        |39  |
|7 |    TABLE SCAN         |t3   |8        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      conds([t2.c1 + t3.c1 < 5]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t3.c1]), filter(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |4        |402 |
|1 | SUBPLAN SCAN     |VIEW1|4        |401 |
|2 |  SUBPLAN FILTER  |     |4        |400 |
|3 |   HASH OUTER JOIN|     |8        |93  |
|4 |    TABLE SCAN    |t1   |8        |38  |
|5 |    TABLE SCAN    |t2   |9        |38  |
|6 |   TABLE SCAN     |t3   |3        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter([? + t3.c1 < 5]), 
      access([t3.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |8        |173 |
|1 | SUBPLAN FILTER         |    |8        |165 |
|2 |  TABLE SCAN            |t1  |8        |38  |
|3 |  LIMIT                 |    |1        |126 |
|4 |   NESTED-LOOP ANTI JOIN|    |1        |126 |
|5 |    HASH OUTER JOIN     |    |2        |84  |
|6 |     TABLE SCAN         |t1  |8        |38  |
|7 |     TABLE SCAN         |t2  |2        |37  |
|8 |    MATERIAL            |    |8        |39  |
|9 |     TABLE SCAN         |t3  |8        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t2.c1 + t3.c1 < 5]), nl_params_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |8        |208 |
|1 | SUBPLAN FILTER    |    |8        |200 |
|2 |  TABLE SCAN       |t1  |8        |38  |
|3 |  LIMIT            |    |1        |161 |
|4 |   SUBPLAN FILTER  |    |1        |161 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |3        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([? + t3.c1 < 5]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |166 |
|1 | SUBPLAN FILTER         |    |1        |165 |
|2 |  TABLE SCAN            |t1  |1        |39  |
|3 |  LIMIT                 |    |1        |126 |
|4 |   NESTED-LOOP ANTI JOIN|    |1        |126 |
|5 |    HASH OUTER JOIN     |    |2        |84  |
|6 |     TABLE SCAN         |t1  |8        |38  |
|7 |     TABLE SCAN         |t2  |2        |37  |
|8 |    MATERIAL            |    |8        |39  |
|9 |     TABLE SCAN         |t3  |8        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t2.c1 + t3.c1 < 5]), nl_params_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |201 |
|1 | SUBPLAN FILTER    |    |1        |200 |
|2 |  TABLE SCAN       |t1  |1        |39  |
|3 |  LIMIT            |    |1        |161 |
|4 |   SUBPLAN FILTER  |    |1        |161 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |3        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([? + t3.c1 < 5]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1<5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5);
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |HASH JOIN             |    |1        |137 |
|1 | NESTED-LOOP SEMI JOIN|    |1        |97  |
|2 |  TABLE SCAN          |t2  |9        |38  |
|3 |  MATERIAL            |    |8        |39  |
|4 |   TABLE SCAN         |t3  |8        |38  |
|5 | TABLE SCAN           |t1  |8        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      conds([t2.c1 + t3.c1 = 5]), nl_params_(nil)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  3 - output([t3.c1]), filter(nil)
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |4        |399 |
|1 | HASH OUTER JOIN|    |8        |93  |
|2 |  TABLE SCAN    |t1  |8        |38  |
|3 |  TABLE SCAN    |t2  |9        |38  |
|4 | TABLE SCAN     |t3  |1        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter([? + t3.c1 = 5]), 
      access([t3.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |1        |137 |
|1 | SUBPLAN SCAN           |VIEW1|1        |137 |
|2 |  HASH JOIN             |     |1        |137 |
|3 |   NESTED-LOOP SEMI JOIN|     |1        |97  |
|4 |    TABLE SCAN          |t2   |9        |38  |
|5 |    MATERIAL            |     |8        |39  |
|6 |     TABLE SCAN         |t3   |8        |38  |
|7 |   TABLE SCAN           |t1   |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      conds([t2.c1 + t3.c1 = 5]), nl_params_(nil)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  5 - output([t3.c1]), filter(nil)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |4        |400 |
|1 | SUBPLAN SCAN     |VIEW1|4        |399 |
|2 |  SUBPLAN FILTER  |     |4        |399 |
|3 |   HASH OUTER JOIN|     |8        |93  |
|4 |    TABLE SCAN    |t1   |8        |38  |
|5 |    TABLE SCAN    |t2   |9        |38  |
|6 |   TABLE SCAN     |t3   |1        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter([? + t3.c1 = 5]), 
      access([t3.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |8        |183 |
|1 | SUBPLAN FILTER          |    |8        |175 |
|2 |  TABLE SCAN             |t1  |8        |38  |
|3 |  LIMIT                  |    |1        |137 |
|4 |   HASH JOIN             |    |1        |137 |
|5 |    NESTED-LOOP SEMI JOIN|    |1        |97  |
|6 |     TABLE SCAN          |t2  |9        |38  |
|7 |     MATERIAL            |    |8        |39  |
|8 |      TABLE SCAN         |t3  |8        |38  |
|9 |    TABLE SCAN           |t1  |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      conds([t2.c1 + t3.c1 = 5]), nl_params_(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t3.c1]), filter(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |8        |207 |
|1 | SUBPLAN FILTER    |    |8        |199 |
|2 |  TABLE SCAN       |t1  |8        |38  |
|3 |  LIMIT            |    |1        |161 |
|4 |   SUBPLAN FILTER  |    |1        |161 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |1        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([? + t3.c1 = 5]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |176 |
|1 | SUBPLAN FILTER          |    |1        |175 |
|2 |  TABLE SCAN             |t1  |1        |39  |
|3 |  LIMIT                  |    |1        |137 |
|4 |   HASH JOIN             |    |1        |137 |
|5 |    NESTED-LOOP SEMI JOIN|    |1        |97  |
|6 |     TABLE SCAN          |t2  |9        |38  |
|7 |     MATERIAL            |    |8        |39  |
|8 |      TABLE SCAN         |t3  |8        |38  |
|9 |    TABLE SCAN           |t1  |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      conds([t2.c1 + t3.c1 = 5]), nl_params_(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t3.c1]), filter(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |200 |
|1 | SUBPLAN FILTER    |    |1        |199 |
|2 |  TABLE SCAN       |t1  |1        |39  |
|3 |  LIMIT            |    |1        |161 |
|4 |   SUBPLAN FILTER  |    |1        |161 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |1        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([? + t3.c1 = 5]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5);
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|    |8        |150 |
|1 | HASH OUTER JOIN     |    |8        |93  |
|2 |  TABLE SCAN         |t1  |8        |38  |
|3 |  TABLE SCAN         |t2  |9        |38  |
|4 | MATERIAL            |    |8        |39  |
|5 |  TABLE SCAN         |t3  |8        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      conds([t2.c1 + t3.c1 = 5]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t3.c1]), filter(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    3 |    2 |    3 |    3 |
|    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL |
| NULL |    1 | NULL | NULL |
| NULL |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |4        |399 |
|1 | HASH OUTER JOIN|    |8        |93  |
|2 |  TABLE SCAN    |t1  |8        |38  |
|3 |  TABLE SCAN    |t2  |9        |38  |
|4 | TABLE SCAN     |t3  |1        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter([? + t3.c1 = 5]), 
      access([t3.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    3 |    2 |    3 |    3 |
|    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL |
| NULL |    1 | NULL | NULL |
| NULL |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5));
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |8        |152 |
|1 | SUBPLAN SCAN          |VIEW1|8        |151 |
|2 |  NESTED-LOOP ANTI JOIN|     |8        |150 |
|3 |   HASH OUTER JOIN     |     |8        |93  |
|4 |    TABLE SCAN         |t1   |8        |38  |
|5 |    TABLE SCAN         |t2   |9        |38  |
|6 |   MATERIAL            |     |8        |39  |
|7 |    TABLE SCAN         |t3   |8        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      conds([t2.c1 + t3.c1 = 5]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t3.c1]), filter(nil)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |4        |400 |
|1 | SUBPLAN SCAN     |VIEW1|4        |399 |
|2 |  SUBPLAN FILTER  |     |4        |399 |
|3 |   HASH OUTER JOIN|     |8        |93  |
|4 |    TABLE SCAN    |t1   |8        |38  |
|5 |    TABLE SCAN    |t2   |9        |38  |
|6 |   TABLE SCAN     |t3   |1        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter([? + t3.c1 = 5]), 
      access([t3.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |8        |171 |
|1 | SUBPLAN FILTER         |    |8        |163 |
|2 |  TABLE SCAN            |t1  |8        |38  |
|3 |  LIMIT                 |    |1        |124 |
|4 |   NESTED-LOOP ANTI JOIN|    |1        |124 |
|5 |    HASH OUTER JOIN     |    |2        |83  |
|6 |     TABLE SCAN         |t1  |8        |38  |
|7 |     TABLE SCAN         |t2  |2        |36  |
|8 |    MATERIAL            |    |8        |39  |
|9 |     TABLE SCAN         |t3  |8        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t2.c1 + t3.c1 = 5]), nl_params_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |8        |207 |
|1 | SUBPLAN FILTER    |    |8        |199 |
|2 |  TABLE SCAN       |t1  |8        |38  |
|3 |  LIMIT            |    |1        |161 |
|4 |   SUBPLAN FILTER  |    |1        |161 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |1        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([? + t3.c1 = 5]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |164 |
|1 | SUBPLAN FILTER         |    |1        |163 |
|2 |  TABLE SCAN            |t1  |1        |39  |
|3 |  LIMIT                 |    |1        |124 |
|4 |   NESTED-LOOP ANTI JOIN|    |1        |124 |
|5 |    HASH OUTER JOIN     |    |2        |83  |
|6 |     TABLE SCAN         |t1  |8        |38  |
|7 |     TABLE SCAN         |t2  |2        |36  |
|8 |    MATERIAL            |    |8        |39  |
|9 |     TABLE SCAN         |t3  |8        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t2.c1 + t3.c1 = 5]), nl_params_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |200 |
|1 | SUBPLAN FILTER    |    |1        |199 |
|2 |  TABLE SCAN       |t1  |1        |39  |
|3 |  LIMIT            |    |1        |161 |
|4 |   SUBPLAN FILTER  |    |1        |161 |
|5 |    HASH OUTER JOIN|    |2        |85  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |3        |37  |
|8 |    TABLE SCAN     |t3  |1        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter([? + t3.c1 = 5]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select 1 from t3 where t2.c1+t3.c1 = 5) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;

EXPLAIN select * from t1 where not exists (select null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100);
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP ANTI JOIN        |     |7        |120 |
|1 | TABLE SCAN                  |t1   |8        |38  |
|2 | MATERIAL                    |     |1        |79  |
|3 |  SUBPLAN SCAN               |VIEW1|1        |79  |
|4 |   NESTED-LOOP JOIN CARTESIAN|     |1        |79  |
|5 |    TABLE SCAN               |t2   |1        |39  |
|6 |    MATERIAL                 |     |1        |39  |
|7 |     TABLE SCAN              |t3   |1        |39  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 = 100]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil)
  3 - output([1]), filter(nil), 
      access(nil)
  4 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter([t2.c1 = 100]), 
      access([t2.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter([t3.c1 = 100]), 
      access([t3.c1]), partitions(p0)

select * from t1 where not exists (select null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100);
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    2 |
|    4 |    2 |
|    5 |    5 |
|   10 |   10 |
| NULL |    1 |
| NULL |    5 |
+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 where not exists (select /*+NO_REWRITE*/null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |4        |682 |
|1 | TABLE SCAN     |t1  |8        |38  |
|2 | HASH OUTER JOIN|    |1        |81  |
|3 |  TABLE SCAN    |t2  |1        |39  |
|4 |  TABLE SCAN    |t3  |8        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([NULL]), filter([? = t3.c1]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t2.c1]), filter([t2.c1 = 100]), 
      access([t2.c1]), partitions(p0)
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 where not exists (select /*+NO_REWRITE*/null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100);
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    2 |
|    4 |    2 |
|    5 |    5 |
|   10 |   10 |
| NULL |    1 |
| NULL |    5 |
+------+------+
EXPLAIN insert into t11_temp (select * from t1 where not exists (select null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100));
Query Plan
=========================================================
|ID|OPERATOR                       |NAME |EST. ROWS|COST|
---------------------------------------------------------
|0 |INSERT                         |     |7        |122 |
|1 | SUBPLAN SCAN                  |VIEW1|7        |121 |
|2 |  NESTED-LOOP ANTI JOIN        |     |7        |120 |
|3 |   TABLE SCAN                  |t1   |8        |38  |
|4 |   MATERIAL                    |     |1        |79  |
|5 |    SUBPLAN SCAN               |VIEW2|1        |79  |
|6 |     NESTED-LOOP JOIN CARTESIAN|     |1        |79  |
|7 |      TABLE SCAN               |t2   |1        |39  |
|8 |      MATERIAL                 |     |1        |39  |
|9 |       TABLE SCAN              |t3   |1        |39  |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 = 100]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([1]), filter(nil)
  5 - output([1]), filter(nil), 
      access(nil)
  6 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter([t2.c1 = 100]), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter([t3.c1 = 100]), 
      access([t3.c1]), partitions(p0)

insert into t11_temp (select * from t1 where not exists (select null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100));

rollback;
EXPLAIN insert into t11_temp (select /*+NO_REWRITE*/* from t1 where not exists (select /*+NO_REWRITE*/null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100));
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |4        |684 |
|1 | SUBPLAN SCAN     |VIEW1|4        |683 |
|2 |  SUBPLAN FILTER  |     |4        |682 |
|3 |   TABLE SCAN     |t1   |8        |38  |
|4 |   HASH OUTER JOIN|     |1        |81  |
|5 |    TABLE SCAN    |t2   |1        |39  |
|6 |    TABLE SCAN    |t3   |8        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([NULL]), filter([? = t3.c1]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t2.c1]), filter([t2.c1 = 100]), 
      access([t2.c1]), partitions(p0)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

insert into t11_temp (select /*+NO_REWRITE*/* from t1 where not exists (select /*+NO_REWRITE*/null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 where not exists (select null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100) limit 1);
Query Plan
==========================================================
|ID|OPERATOR                        |NAME |EST. ROWS|COST|
----------------------------------------------------------
|0 |UPDATE                          |     |8        |162 |
|1 | SUBPLAN FILTER                 |     |8        |154 |
|2 |  TABLE SCAN                    |t1   |8        |38  |
|3 |  LIMIT                         |     |1        |116 |
|4 |   NESTED-LOOP ANTI JOIN        |     |1        |116 |
|5 |    TABLE SCAN                  |t1   |2        |36  |
|6 |    MATERIAL                    |     |1        |79  |
|7 |     SUBPLAN SCAN               |VIEW1|1        |79  |
|8 |      NESTED-LOOP JOIN CARTESIAN|     |1        |79  |
|9 |       TABLE SCAN               |t2   |1        |39  |
|10|       MATERIAL                 |     |1        |39  |
|11|        TABLE SCAN              |t3   |1        |39  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 = 100]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access(nil)
  8 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  9 - output([1]), filter([t2.c1 = 100]), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter([t3.c1 = 100]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 where not exists (select null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where not exists (select /*+NO_REWRITE*/null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |8        |244 |
|1 | SUBPLAN FILTER    |    |8        |236 |
|2 |  TABLE SCAN       |t1  |8        |38  |
|3 |  LIMIT            |    |1        |198 |
|4 |   SUBPLAN FILTER  |    |1        |198 |
|5 |    TABLE SCAN     |t1  |2        |37  |
|6 |    HASH OUTER JOIN|    |1        |81  |
|7 |     TABLE SCAN    |t2  |1        |39  |
|8 |     TABLE SCAN    |t3  |8        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([NULL]), filter([? = t3.c1]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t2.c1]), filter([t2.c1 = 100]), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where not exists (select /*+NO_REWRITE*/null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 where not exists (select null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100) limit 1);
Query Plan
==========================================================
|ID|OPERATOR                        |NAME |EST. ROWS|COST|
----------------------------------------------------------
|0 |DELETE                          |     |1        |155 |
|1 | SUBPLAN FILTER                 |     |1        |154 |
|2 |  TABLE SCAN                    |t1   |1        |39  |
|3 |  LIMIT                         |     |1        |116 |
|4 |   NESTED-LOOP ANTI JOIN        |     |1        |116 |
|5 |    TABLE SCAN                  |t1   |2        |36  |
|6 |    MATERIAL                    |     |1        |79  |
|7 |     SUBPLAN SCAN               |VIEW1|1        |79  |
|8 |      NESTED-LOOP JOIN CARTESIAN|     |1        |79  |
|9 |       TABLE SCAN               |t2   |1        |39  |
|10|       MATERIAL                 |     |1        |39  |
|11|        TABLE SCAN              |t3   |1        |39  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 = 100]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access(nil)
  8 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  9 - output([1]), filter([t2.c1 = 100]), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter([t3.c1 = 100]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 where not exists (select null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where not exists (select /*+NO_REWRITE*/null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100) limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |237 |
|1 | SUBPLAN FILTER    |    |1        |236 |
|2 |  TABLE SCAN       |t1  |1        |39  |
|3 |  LIMIT            |    |1        |198 |
|4 |   SUBPLAN FILTER  |    |1        |198 |
|5 |    TABLE SCAN     |t1  |2        |37  |
|6 |    HASH OUTER JOIN|    |1        |81  |
|7 |     TABLE SCAN    |t2  |1        |39  |
|8 |     TABLE SCAN    |t3  |8        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([NULL]), filter([? = t3.c1]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t2.c1]), filter([t2.c1 = 100]), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 where not exists (select /*+NO_REWRITE*/null from t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1 and t2.c1=100) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select t1.c2, t2.c2, t3.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1;
Query Plan
=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN      |    |8        |121 |
|1 | TABLE SCAN                 |t1  |8        |38  |
|2 | MATERIAL                   |    |1        |80  |
|3 |  NESTED-LOOP JOIN CARTESIAN|    |1        |79  |
|4 |   TABLE SCAN               |t3  |1        |39  |
|5 |   MATERIAL                 |    |1        |40  |
|6 |    TABLE SCAN              |t2  |1        |40  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [t2.c2], [t3.c2]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c2], [t3.c2]), filter(nil)
  3 - output([t2.c2], [t3.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t3.c2]), filter([t3.c1 = 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  5 - output([t2.c2]), filter(nil)
  6 - output([t2.c2]), filter([t2.c1 = 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select t1.c2, t2.c2, t3.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1;
+------+------+------+
| c2   | c2   | c2   |
+------+------+------+
|    1 |    1 |    1 |
|    1 |    1 |    1 |
|    1 | NULL | NULL |
|    2 | NULL | NULL |
|    2 | NULL | NULL |
|    2 | NULL | NULL |
|    5 | NULL | NULL |
|    5 | NULL | NULL |
|   10 | NULL | NULL |
+------+------+------+
EXPLAIN select /*+NO_REWRITE*/t1.c2, t2.c2, t3.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |8        |119 |
|1 | TABLE SCAN           |t1  |8        |38  |
|2 | MATERIAL             |    |1        |82  |
|3 |  HASH OUTER JOIN     |    |1        |81  |
|4 |   TABLE SCAN         |t2  |1        |40  |
|5 |   TABLE SCAN         |t3  |8        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [t2.c2], [t3.c2]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c2], [t3.c2]), filter(nil)
  3 - output([t2.c2], [t3.c2]), filter([t3.c1 = 1]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  4 - output([t2.c1], [t2.c2]), filter([t2.c1 = 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)

select /*+NO_REWRITE*/t1.c2, t2.c2, t3.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1;
+------+------+------+
| c2   | c2   | c2   |
+------+------+------+
|    1 |    1 |    1 |
|    1 |    1 |    1 |
|    1 | NULL | NULL |
|    2 | NULL | NULL |
|    2 | NULL | NULL |
|    2 | NULL | NULL |
|    5 | NULL | NULL |
|    5 | NULL | NULL |
|   10 | NULL | NULL |
+------+------+------+
EXPLAIN insert into t14_temp (select t1.c2, t2.c2, t3.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1);
Query Plan
========================================================
|ID|OPERATOR                      |NAME |EST. ROWS|COST|
--------------------------------------------------------
|0 |INSERT                        |     |8        |123 |
|1 | SUBPLAN SCAN                 |VIEW1|8        |122 |
|2 |  NESTED-LOOP OUTER JOIN      |     |8        |121 |
|3 |   TABLE SCAN                 |t1   |8        |38  |
|4 |   MATERIAL                   |     |1        |80  |
|5 |    NESTED-LOOP JOIN CARTESIAN|     |1        |79  |
|6 |     TABLE SCAN               |t3   |1        |39  |
|7 |     MATERIAL                 |     |1        |40  |
|8 |      TABLE SCAN              |t2   |1        |40  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t14_temp: ({t14_temp: (t14_temp.__pk_increment, t14_temp.a, t14_temp.b, t14_temp.c)})}]), partitions(p0)
  1 - output([VIEW1.c2], [VIEW1.c2], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c2], [VIEW1.c2], [VIEW1.c2])
  2 - output([t1.c2], [t2.c2], [t3.c2]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c2], [t3.c2]), filter(nil)
  5 - output([t2.c2], [t3.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([t3.c2]), filter([t3.c1 = 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  7 - output([t2.c2]), filter(nil)
  8 - output([t2.c2]), filter([t2.c1 = 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t14_temp (select t1.c2, t2.c2, t3.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1);

rollback;
EXPLAIN insert into t14_temp (select /*+NO_REWRITE*/t1.c2, t2.c2, t3.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |8        |122 |
|1 | SUBPLAN SCAN           |VIEW1|8        |121 |
|2 |  NESTED-LOOP OUTER JOIN|     |8        |119 |
|3 |   TABLE SCAN           |t1   |8        |38  |
|4 |   MATERIAL             |     |1        |82  |
|5 |    HASH OUTER JOIN     |     |1        |81  |
|6 |     TABLE SCAN         |t2   |1        |40  |
|7 |     TABLE SCAN         |t3   |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t14_temp: ({t14_temp: (t14_temp.__pk_increment, t14_temp.a, t14_temp.b, t14_temp.c)})}]), partitions(p0)
  1 - output([VIEW1.c2], [VIEW1.c2], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c2], [VIEW1.c2], [VIEW1.c2])
  2 - output([t1.c2], [t2.c2], [t3.c2]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c2], [t3.c2]), filter(nil)
  5 - output([t2.c2], [t3.c2]), filter([t3.c1 = 1]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2]), filter([t2.c1 = 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)

insert into t14_temp (select /*+NO_REWRITE*/t1.c2, t2.c2, t3.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1 limit 1);
Query Plan
=========================================================
|ID|OPERATOR                       |NAME |EST. ROWS|COST|
---------------------------------------------------------
|0 |UPDATE                         |     |8        |163 |
|1 | SUBPLAN FILTER                |     |8        |155 |
|2 |  TABLE SCAN                   |t1   |8        |38  |
|3 |  LIMIT                        |     |1        |116 |
|4 |   NESTED-LOOP OUTER JOIN      |     |1        |116 |
|5 |    SUBPLAN SCAN               |VIEW1|1        |37  |
|6 |     TABLE SCAN                |t1   |1        |36  |
|7 |    MATERIAL                   |     |1        |79  |
|8 |     NESTED-LOOP JOIN CARTESIAN|     |1        |79  |
|9 |      TABLE SCAN               |t2   |1        |39  |
|10|      MATERIAL                 |     |1        |39  |
|11|       TABLE SCAN              |t3   |1        |39  |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([VIEW1.t1.c2]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c2]), filter(nil), 
      conds([VIEW1.t1.c1 = 1]), nl_params_(nil)
  5 - output([VIEW1.t1.c1], [VIEW1.t1.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t1.c2])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      limit(1), offset(nil)
  7 - output([1]), filter(nil)
  8 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  9 - output([1]), filter([t2.c1 = 1]), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter([t3.c1 = 1]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+NO_REWRITE*/t1.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |8        |164 |
|1 | SUBPLAN FILTER          |    |8        |156 |
|2 |  TABLE SCAN             |t1  |8        |38  |
|3 |  LIMIT                  |    |1        |117 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |117 |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    MATERIAL             |    |1        |81  |
|7 |     HASH OUTER JOIN     |    |1        |81  |
|8 |      TABLE SCAN         |t2  |1        |39  |
|9 |      TABLE SCAN         |t3  |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c2]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c2]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter([t3.c1 = 1]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  8 - output([t2.c1]), filter([t2.c1 = 1]), 
      access([t2.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+NO_REWRITE*/t1.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1 limit 1);
Query Plan
=========================================================
|ID|OPERATOR                       |NAME |EST. ROWS|COST|
---------------------------------------------------------
|0 |DELETE                         |     |1        |155 |
|1 | SUBPLAN FILTER                |     |1        |154 |
|2 |  TABLE SCAN                   |t1   |1        |39  |
|3 |  LIMIT                        |     |1        |116 |
|4 |   NESTED-LOOP OUTER JOIN      |     |1        |116 |
|5 |    SUBPLAN SCAN               |VIEW1|1        |37  |
|6 |     TABLE SCAN                |t1   |1        |36  |
|7 |    MATERIAL                   |     |1        |79  |
|8 |     NESTED-LOOP JOIN CARTESIAN|     |1        |79  |
|9 |      TABLE SCAN               |t2   |1        |39  |
|10|      MATERIAL                 |     |1        |39  |
|11|       TABLE SCAN              |t3   |1        |39  |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW1.t1.c2]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c2]), filter(nil), 
      conds([VIEW1.t1.c1 = 1]), nl_params_(nil)
  5 - output([VIEW1.t1.c1], [VIEW1.t1.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t1.c2])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      limit(1), offset(nil)
  7 - output([1]), filter(nil)
  8 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  9 - output([1]), filter([t2.c1 = 1]), 
      access([t2.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter([t3.c1 = 1]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+NO_REWRITE*/t1.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |156 |
|1 | SUBPLAN FILTER          |    |1        |155 |
|2 |  TABLE SCAN             |t1  |1        |39  |
|3 |  LIMIT                  |    |1        |117 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |117 |
|5 |    TABLE SCAN           |t1  |1        |36  |
|6 |    MATERIAL             |    |1        |81  |
|7 |     HASH OUTER JOIN     |    |1        |81  |
|8 |      TABLE SCAN         |t2  |1        |39  |
|9 |      TABLE SCAN         |t3  |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c2]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c2]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter([t3.c1 = 1]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  8 - output([t2.c1]), filter([t2.c1 = 1]), 
      access([t2.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+NO_REWRITE*/t1.c2 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t1.c1 = 1 and t2.c1 = 1 and t3.c1 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |8        |146 |
|1 | TABLE SCAN          |t3  |8        |38  |
|2 | HASH OUTER JOIN     |    |8        |93  |
|3 |  TABLE SCAN         |t1  |8        |38  |
|4 |  TABLE SCAN         |t2  |9        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds([t2.c2 = 1])
  1 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 | NULL | NULL |
|    3 |    2 |    3 |    3 | NULL | NULL |
|    4 |    2 |    4 |    4 | NULL | NULL |
|    5 |    5 | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |8        |146 |
|1 | TABLE SCAN          |t3  |8        |38  |
|2 | HASH OUTER JOIN     |    |8        |93  |
|3 |  TABLE SCAN         |t1  |8        |38  |
|4 |  TABLE SCAN         |t2  |9        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds([t2.c2 = 1])
  1 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 | NULL | NULL |
|    3 |    2 |    3 |    3 | NULL | NULL |
|    4 |    2 |    4 |    4 | NULL | NULL |
|    5 |    5 | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+
EXPLAIN insert into t5_temp (select * from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |8        |148 |
|1 | SUBPLAN SCAN          |VIEW1|8        |147 |
|2 |  HASH RIGHT OUTER JOIN|     |8        |146 |
|3 |   TABLE SCAN          |t3   |8        |38  |
|4 |   HASH OUTER JOIN     |     |8        |93  |
|5 |    TABLE SCAN         |t1   |8        |38  |
|6 |    TABLE SCAN         |t2   |9        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.f, t5_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds([t2.c2 = 1])
  3 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t5_temp (select * from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1);

rollback;
EXPLAIN insert into t5_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |8        |148 |
|1 | SUBPLAN SCAN          |VIEW1|8        |147 |
|2 |  HASH RIGHT OUTER JOIN|     |8        |146 |
|3 |   TABLE SCAN          |t3   |8        |38  |
|4 |   HASH OUTER JOIN     |     |8        |93  |
|5 |    TABLE SCAN         |t1   |8        |38  |
|6 |    TABLE SCAN         |t2   |9        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.f, t5_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds([t2.c2 = 1])
  3 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t5_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1 limit 1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE             |     |8        |167 |
|1 | SUBPLAN FILTER    |     |8        |159 |
|2 |  TABLE SCAN       |t1   |8        |38  |
|3 |  LIMIT            |     |1        |121 |
|4 |   HASH OUTER JOIN |     |1        |120 |
|5 |    HASH OUTER JOIN|     |1        |79  |
|6 |     SUBPLAN SCAN  |VIEW1|1        |37  |
|7 |      TABLE SCAN   |t1   |1        |36  |
|8 |     TABLE SCAN    |t2   |9        |38  |
|9 |    TABLE SCAN     |t3   |8        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds([t2.c2 = 1])
  5 - output([VIEW1.t1.c1], [t2.c2]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t2.c1]), other_conds(nil)
  6 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |8        |177 |
|1 | SUBPLAN FILTER         |    |8        |169 |
|2 |  TABLE SCAN            |t1  |8        |38  |
|3 |  LIMIT                 |    |1        |130 |
|4 |   HASH RIGHT OUTER JOIN|    |1        |130 |
|5 |    TABLE SCAN          |t3  |8        |38  |
|6 |    HASH OUTER JOIN     |    |1        |83  |
|7 |     TABLE SCAN         |t1  |8        |38  |
|8 |     TABLE SCAN         |t2  |2        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds([t2.c2 = 1])
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1 limit 1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |DELETE             |     |1        |160 |
|1 | SUBPLAN FILTER    |     |1        |159 |
|2 |  TABLE SCAN       |t1   |1        |39  |
|3 |  LIMIT            |     |1        |121 |
|4 |   HASH OUTER JOIN |     |1        |120 |
|5 |    HASH OUTER JOIN|     |1        |79  |
|6 |     SUBPLAN SCAN  |VIEW1|1        |37  |
|7 |      TABLE SCAN   |t1   |1        |36  |
|8 |     TABLE SCAN    |t2   |9        |38  |
|9 |    TABLE SCAN     |t3   |8        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds([t2.c2 = 1])
  5 - output([VIEW1.t1.c1], [t2.c2]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t2.c1]), other_conds(nil)
  6 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |169 |
|1 | SUBPLAN FILTER         |    |1        |168 |
|2 |  TABLE SCAN            |t1  |1        |39  |
|3 |  LIMIT                 |    |1        |130 |
|4 |   HASH RIGHT OUTER JOIN|    |1        |130 |
|5 |    TABLE SCAN          |t3  |8        |38  |
|6 |    HASH OUTER JOIN     |    |1        |83  |
|7 |     TABLE SCAN         |t1  |8        |38  |
|8 |     TABLE SCAN         |t2  |2        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds([t2.c2 = 1])
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1 and t2.c2=1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |8        |124 |
|1 | HASH JOIN           |    |1        |82  |
|2 |  TABLE SCAN         |t3  |1        |39  |
|3 |  TABLE SCAN         |t2  |9        |38  |
|4 | TABLE SCAN          |t1  |8        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  2 - output([t3.c1], [t3.c2]), filter([t3.c2 = 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 | NULL | NULL | NULL | NULL |
|    3 |    2 | NULL | NULL | NULL | NULL |
|    4 |    2 | NULL | NULL | NULL | NULL |
|    5 |    5 | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |HASH RIGHT OUTER JOIN |    |8        |136 |
|1 | HASH RIGHT OUTER JOIN|    |2        |93  |
|2 |  TABLE SCAN          |t3  |8        |38  |
|3 |  TABLE SCAN          |t2  |9        |38  |
|4 | TABLE SCAN           |t1  |8        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter([t3.c2 = 1]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  2 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 | NULL | NULL | NULL | NULL |
|    3 |    2 | NULL | NULL | NULL | NULL |
|    4 |    2 | NULL | NULL | NULL | NULL |
|    5 |    5 | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+
EXPLAIN insert into t5_temp (select * from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |8        |126 |
|1 | SUBPLAN SCAN          |VIEW1|8        |125 |
|2 |  HASH RIGHT OUTER JOIN|     |8        |124 |
|3 |   HASH JOIN           |     |1        |82  |
|4 |    TABLE SCAN         |t3   |1        |39  |
|5 |    TABLE SCAN         |t2   |9        |38  |
|6 |   TABLE SCAN          |t1   |8        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.f, t5_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  4 - output([t3.c1], [t3.c2]), filter([t3.c2 = 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t5_temp (select * from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1);

rollback;
EXPLAIN insert into t5_temp (select /*+NO_REWRITE*/* from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |8        |138 |
|1 | SUBPLAN SCAN           |VIEW1|8        |137 |
|2 |  HASH RIGHT OUTER JOIN |     |8        |136 |
|3 |   HASH RIGHT OUTER JOIN|     |2        |93  |
|4 |    TABLE SCAN          |t3   |8        |38  |
|5 |    TABLE SCAN          |t2   |9        |38  |
|6 |   TABLE SCAN           |t1   |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.f, t5_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter([t3.c2 = 1]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  4 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t5_temp (select /*+NO_REWRITE*/* from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1 limit 1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE            |     |8        |166 |
|1 | SUBPLAN FILTER   |     |8        |158 |
|2 |  TABLE SCAN      |t1   |8        |38  |
|3 |  LIMIT           |     |1        |120 |
|4 |   HASH OUTER JOIN|     |1        |120 |
|5 |    SUBPLAN SCAN  |VIEW1|1        |37  |
|6 |     TABLE SCAN   |t1   |1        |36  |
|7 |    HASH JOIN     |     |1        |81  |
|8 |     TABLE SCAN   |t3   |1        |39  |
|9 |     TABLE SCAN   |t2   |9        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  5 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  7 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1]), filter([t3.c2 = 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |8        |177 |
|1 | SUBPLAN FILTER         |    |8        |169 |
|2 |  TABLE SCAN            |t1  |8        |38  |
|3 |  LIMIT                 |    |1        |131 |
|4 |   HASH RIGHT OUTER JOIN|    |1        |130 |
|5 |    HASH OUTER JOIN     |    |2        |92  |
|6 |     TABLE SCAN         |t2  |9        |38  |
|7 |     TABLE SCAN         |t3  |8        |38  |
|8 |    TABLE SCAN          |t1  |1        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter([t3.c2 = 1]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1 limit 1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |DELETE            |     |1        |159 |
|1 | SUBPLAN FILTER   |     |1        |158 |
|2 |  TABLE SCAN      |t1   |1        |39  |
|3 |  LIMIT           |     |1        |120 |
|4 |   HASH OUTER JOIN|     |1        |120 |
|5 |    SUBPLAN SCAN  |VIEW1|1        |37  |
|6 |     TABLE SCAN   |t1   |1        |36  |
|7 |    HASH JOIN     |     |1        |81  |
|8 |     TABLE SCAN   |t3   |1        |39  |
|9 |     TABLE SCAN   |t2   |9        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  5 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  7 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1]), filter([t3.c2 = 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |170 |
|1 | SUBPLAN FILTER         |    |1        |169 |
|2 |  TABLE SCAN            |t1  |1        |39  |
|3 |  LIMIT                 |    |1        |131 |
|4 |   HASH RIGHT OUTER JOIN|    |1        |130 |
|5 |    HASH OUTER JOIN     |    |2        |92  |
|6 |     TABLE SCAN         |t2  |9        |38  |
|7 |     TABLE SCAN         |t3  |8        |38  |
|8 |    TABLE SCAN          |t1  |1        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter([t3.c2 = 1]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join t3 on t2.c1=t3.c1) on t1.c1=t3.c1 and t3.c2 = 1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |9        |173 |
|1 | HASH RIGHT OUTER JOIN|    |9        |93  |
|2 |  TABLE SCAN          |t3  |8        |38  |
|3 |  TABLE SCAN          |t2  |9        |38  |
|4 | MATERIAL             |    |8        |41  |
|5 |  TABLE SCAN          |t1  |8        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      conds([t2.c1 = 1], [t3.c1 = 1]), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  2 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 |    1 |    1 |    1 |    1 |
|    2 |    2 |    1 |    1 |    1 |    1 |
|    3 |    2 |    1 |    1 |    1 |    1 |
|    3 |    2 |    1 |    1 |    1 |    1 |
|    4 |    2 |    1 |    1 |    1 |    1 |
|    4 |    2 |    1 |    1 |    1 |    1 |
|    5 |    5 |    1 |    1 |    1 |    1 |
|    5 |    5 |    1 |    1 |    1 |    1 |
|   10 |   10 |    1 |    1 |    1 |    1 |
|   10 |   10 |    1 |    1 |    1 |    1 |
| NULL |    1 |    1 |    1 |    1 |    1 |
| NULL |    1 |    1 |    1 |    1 |    1 |
| NULL |    5 |    1 |    1 |    1 |    1 |
| NULL |    5 |    1 |    1 |    1 |    1 |
| NULL | NULL |    2 |    2 | NULL | NULL |
| NULL | NULL |    3 |    3 |    3 |    3 |
| NULL | NULL |    4 |    4 |    4 |    4 |
| NULL | NULL |    6 |    6 | NULL | NULL |
| NULL | NULL | NULL |    2 | NULL | NULL |
| NULL | NULL | NULL |    6 | NULL | NULL |
| NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+
##不能消除，条件都处于右枝
EXPLAIN select /*+NO_REWRITE*/* from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |9        |173 |
|1 | HASH RIGHT OUTER JOIN|    |9        |93  |
|2 |  TABLE SCAN          |t3  |8        |38  |
|3 |  TABLE SCAN          |t2  |9        |38  |
|4 | MATERIAL             |    |8        |41  |
|5 |  TABLE SCAN          |t1  |8        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      conds([t2.c1 = 1], [t3.c1 = 1]), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  2 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+NO_REWRITE*/* from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 |    1 |    1 |    1 |    1 |
|    2 |    2 |    1 |    1 |    1 |    1 |
|    3 |    2 |    1 |    1 |    1 |    1 |
|    3 |    2 |    1 |    1 |    1 |    1 |
|    4 |    2 |    1 |    1 |    1 |    1 |
|    4 |    2 |    1 |    1 |    1 |    1 |
|    5 |    5 |    1 |    1 |    1 |    1 |
|    5 |    5 |    1 |    1 |    1 |    1 |
|   10 |   10 |    1 |    1 |    1 |    1 |
|   10 |   10 |    1 |    1 |    1 |    1 |
| NULL |    1 |    1 |    1 |    1 |    1 |
| NULL |    1 |    1 |    1 |    1 |    1 |
| NULL |    5 |    1 |    1 |    1 |    1 |
| NULL |    5 |    1 |    1 |    1 |    1 |
| NULL | NULL |    2 |    2 | NULL | NULL |
| NULL | NULL |    3 |    3 |    3 |    3 |
| NULL | NULL |    4 |    4 |    4 |    4 |
| NULL | NULL |    6 |    6 | NULL | NULL |
| NULL | NULL | NULL |    2 | NULL | NULL |
| NULL | NULL | NULL |    6 | NULL | NULL |
| NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+
EXPLAIN insert into t5_temp (select * from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |9        |176 |
|1 | SUBPLAN SCAN           |VIEW1|9        |175 |
|2 |  NESTED-LOOP OUTER JOIN|     |9        |173 |
|3 |   HASH RIGHT OUTER JOIN|     |9        |93  |
|4 |    TABLE SCAN          |t3   |8        |38  |
|5 |    TABLE SCAN          |t2   |9        |38  |
|6 |   MATERIAL             |     |8        |41  |
|7 |    TABLE SCAN          |t1   |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.f, t5_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      conds([t2.c1 = 1], [t3.c1 = 1]), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  4 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t5_temp (select * from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1);

rollback;
EXPLAIN insert into t5_temp (select /*+NO_REWRITE*/* from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |9        |176 |
|1 | SUBPLAN SCAN           |VIEW1|9        |175 |
|2 |  NESTED-LOOP OUTER JOIN|     |9        |173 |
|3 |   HASH RIGHT OUTER JOIN|     |9        |93  |
|4 |    TABLE SCAN          |t3   |8        |38  |
|5 |    TABLE SCAN          |t2   |9        |38  |
|6 |   MATERIAL             |     |8        |41  |
|7 |    TABLE SCAN          |t1   |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.f, t5_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      conds([t2.c1 = 1], [t3.c1 = 1]), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  4 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t5_temp (select /*+NO_REWRITE*/* from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                   |     |8        |168 |
|1 | SUBPLAN FILTER          |     |8        |160 |
|2 |  TABLE SCAN             |t1   |8        |38  |
|3 |  LIMIT                  |     |1        |122 |
|4 |   NESTED-LOOP OUTER JOIN|     |1        |122 |
|5 |    HASH OUTER JOIN      |     |1        |78  |
|6 |     SUBPLAN SCAN        |VIEW1|1        |37  |
|7 |      TABLE SCAN         |t2   |1        |36  |
|8 |     TABLE SCAN          |t3   |8        |38  |
|9 |    MATERIAL             |     |8        |39  |
|10|     TABLE SCAN          |t1   |8        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([VIEW1.t2.c1 = 1], [t3.c1 = 1]), nl_params_(nil)
  5 - output([VIEW1.t2.c1], [t3.c1]), filter(nil), 
      equal_conds([VIEW1.t2.c1 = t3.c1]), other_conds(nil)
  6 - output([VIEW1.t2.c1]), filter(nil), 
      access([VIEW1.t2.c1])
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |8        |173 |
|1 | SUBPLAN FILTER          |    |8        |165 |
|2 |  TABLE SCAN             |t1  |8        |38  |
|3 |  LIMIT                  |    |1        |126 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |126 |
|5 |    HASH RIGHT OUTER JOIN|    |1        |83  |
|6 |     TABLE SCAN          |t3  |8        |38  |
|7 |     TABLE SCAN          |t2  |1        |36  |
|8 |    MATERIAL             |    |8        |39  |
|9 |     TABLE SCAN          |t1  |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t2.c1 = 1], [t3.c1 = 1]), nl_params_(nil)
  5 - output([t2.c1], [t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                   |     |1        |161 |
|1 | SUBPLAN FILTER          |     |1        |160 |
|2 |  TABLE SCAN             |t1   |1        |39  |
|3 |  LIMIT                  |     |1        |122 |
|4 |   NESTED-LOOP OUTER JOIN|     |1        |122 |
|5 |    HASH OUTER JOIN      |     |1        |78  |
|6 |     SUBPLAN SCAN        |VIEW1|1        |37  |
|7 |      TABLE SCAN         |t2   |1        |36  |
|8 |     TABLE SCAN          |t3   |8        |38  |
|9 |    MATERIAL             |     |8        |39  |
|10|     TABLE SCAN          |t1   |8        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([VIEW1.t2.c1 = 1], [t3.c1 = 1]), nl_params_(nil)
  5 - output([VIEW1.t2.c1], [t3.c1]), filter(nil), 
      equal_conds([VIEW1.t2.c1 = t3.c1]), other_conds(nil)
  6 - output([VIEW1.t2.c1]), filter(nil), 
      access([VIEW1.t2.c1])
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |166 |
|1 | SUBPLAN FILTER          |    |1        |165 |
|2 |  TABLE SCAN             |t1  |1        |39  |
|3 |  LIMIT                  |    |1        |126 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |126 |
|5 |    HASH RIGHT OUTER JOIN|    |1        |83  |
|6 |     TABLE SCAN          |t3  |8        |38  |
|7 |     TABLE SCAN          |t2  |1        |36  |
|8 |    MATERIAL             |    |8        |39  |
|9 |     TABLE SCAN          |t1  |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t2.c1 = 1], [t3.c1 = 1]), nl_params_(nil)
  5 - output([t2.c1], [t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1;
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |1        |119 |
|1 | NESTED-LOOP JOIN CARTESIAN|    |1        |79  |
|2 |  TABLE SCAN               |t2  |1        |40  |
|3 |  MATERIAL                 |    |1        |40  |
|4 |   TABLE SCAN              |t1  |1        |39  |
|5 | MATERIAL                  |    |1        |40  |
|6 |  TABLE SCAN               |t3  |1        |39  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1], [t2.c2]), filter([t2.c1 = 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter([t1.c1 > 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2]), filter(nil)
  6 - output([t3.c1], [t3.c2]), filter([t3.c1 = 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)

select * from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
|    2 |    2 |    1 |    1 |    1 |    1 |
|    2 |    2 |    1 |    1 |    1 |    1 |
|    3 |    2 |    1 |    1 |    1 |    1 |
|    3 |    2 |    1 |    1 |    1 |    1 |
|    4 |    2 |    1 |    1 |    1 |    1 |
|    4 |    2 |    1 |    1 |    1 |    1 |
|    5 |    5 |    1 |    1 |    1 |    1 |
|    5 |    5 |    1 |    1 |    1 |    1 |
|   10 |   10 |    1 |    1 |    1 |    1 |
|   10 |   10 |    1 |    1 |    1 |    1 |
+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |1        |173 |
|1 | HASH RIGHT OUTER JOIN|    |9        |93  |
|2 |  TABLE SCAN          |t3  |8        |38  |
|3 |  TABLE SCAN          |t2  |9        |38  |
|4 | MATERIAL             |    |8        |41  |
|5 |  TABLE SCAN          |t1  |8        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter([t1.c1 > 1]), 
      conds([t2.c1 = 1], [t3.c1 = 1]), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  2 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+NO_REWRITE*/* from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
|    2 |    2 |    1 |    1 |    1 |    1 |
|    2 |    2 |    1 |    1 |    1 |    1 |
|    3 |    2 |    1 |    1 |    1 |    1 |
|    3 |    2 |    1 |    1 |    1 |    1 |
|    4 |    2 |    1 |    1 |    1 |    1 |
|    4 |    2 |    1 |    1 |    1 |    1 |
|    5 |    5 |    1 |    1 |    1 |    1 |
|    5 |    5 |    1 |    1 |    1 |    1 |
|   10 |   10 |    1 |    1 |    1 |    1 |
|   10 |   10 |    1 |    1 |    1 |    1 |
+------+------+------+------+------+------+
EXPLAIN insert into t5_temp (select * from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1);
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |1        |119 |
|1 | SUBPLAN SCAN                |VIEW1|1        |119 |
|2 |  NESTED-LOOP JOIN CARTESIAN |     |1        |119 |
|3 |   NESTED-LOOP JOIN CARTESIAN|     |1        |79  |
|4 |    TABLE SCAN               |t2   |1        |40  |
|5 |    MATERIAL                 |     |1        |40  |
|6 |     TABLE SCAN              |t1   |1        |39  |
|7 |   MATERIAL                  |     |1        |40  |
|8 |    TABLE SCAN               |t3   |1        |39  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.f, t5_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t2.c1], [t2.c2]), filter([t2.c1 = 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter([t1.c1 > 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t3.c1], [t3.c2]), filter(nil)
  8 - output([t3.c1], [t3.c2]), filter([t3.c1 = 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)

insert into t5_temp (select * from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1);

rollback;
EXPLAIN insert into t5_temp (select /*+NO_REWRITE*/* from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |1        |174 |
|1 | SUBPLAN SCAN           |VIEW1|1        |173 |
|2 |  NESTED-LOOP OUTER JOIN|     |1        |173 |
|3 |   HASH RIGHT OUTER JOIN|     |9        |93  |
|4 |    TABLE SCAN          |t3   |8        |38  |
|5 |    TABLE SCAN          |t2   |9        |38  |
|6 |   MATERIAL             |     |8        |41  |
|7 |    TABLE SCAN          |t1   |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.f, t5_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter([t1.c1 > 1]), 
      conds([t2.c1 = 1], [t3.c1 = 1]), nl_params_(nil)
  3 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  4 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into t5_temp (select /*+NO_REWRITE*/* from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1 limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |8        |165 |
|1 | SUBPLAN FILTER               |    |8        |157 |
|2 |  TABLE SCAN                  |t1  |8        |38  |
|3 |  LIMIT                       |    |1        |118 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |118 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |79  |
|6 |     TABLE SCAN               |t2  |1        |39  |
|7 |     MATERIAL                 |    |1        |39  |
|8 |      TABLE SCAN              |t1  |1        |39  |
|9 |    MATERIAL                  |    |1        |39  |
|10|     TABLE SCAN               |t3  |1        |39  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([1]), filter([t2.c1 = 1]), 
      access([t2.c1]), partitions(p0)
  7 - output([t1.c1]), filter(nil)
  8 - output([t1.c1]), filter([t1.c1 > 1]), 
      access([t1.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter([t3.c1 = 1]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |8        |216 |
|1 | SUBPLAN FILTER          |    |8        |208 |
|2 |  TABLE SCAN             |t1  |8        |38  |
|3 |  LIMIT                  |    |1        |169 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |169 |
|5 |    HASH RIGHT OUTER JOIN|    |9        |92  |
|6 |     TABLE SCAN          |t3  |8        |38  |
|7 |     TABLE SCAN          |t2  |9        |38  |
|8 |    MATERIAL             |    |8        |39  |
|9 |     TABLE SCAN          |t1  |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t1.c1 > 1]), 
      conds([t2.c1 = 1], [t3.c1 = 1]), nl_params_(nil)
  5 - output([t2.c1], [t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1 limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |157 |
|1 | SUBPLAN FILTER               |    |1        |156 |
|2 |  TABLE SCAN                  |t1  |1        |39  |
|3 |  LIMIT                       |    |1        |118 |
|4 |   NESTED-LOOP JOIN CARTESIAN |    |1        |118 |
|5 |    NESTED-LOOP JOIN CARTESIAN|    |1        |79  |
|6 |     TABLE SCAN               |t2  |1        |39  |
|7 |     MATERIAL                 |    |1        |39  |
|8 |      TABLE SCAN              |t1  |1        |39  |
|9 |    MATERIAL                  |    |1        |39  |
|10|     TABLE SCAN               |t3  |1        |39  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([1]), filter([t2.c1 = 1]), 
      access([t2.c1]), partitions(p0)
  7 - output([t1.c1]), filter(nil)
  8 - output([t1.c1]), filter([t1.c1 > 1]), 
      access([t1.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter([t3.c1 = 1]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.1622776601683795 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |208 |
|1 | SUBPLAN FILTER          |    |1        |207 |
|2 |  TABLE SCAN             |t1  |1        |39  |
|3 |  LIMIT                  |    |1        |169 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |169 |
|5 |    HASH RIGHT OUTER JOIN|    |9        |92  |
|6 |     TABLE SCAN          |t3  |8        |38  |
|7 |     TABLE SCAN          |t2  |9        |38  |
|8 |    MATERIAL             |    |8        |39  |
|9 |     TABLE SCAN          |t1  |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t1.c1 > 1]), 
      conds([t2.c1 = 1], [t3.c1 = 1]), nl_params_(nil)
  5 - output([t2.c1], [t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 right join (t2 left join t3 on t2.c1=t3.c1) on t2.c1=1 and t3.c1=1 where t1.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.1622776601683795 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |8        |136 |
|1 | TABLE SCAN          |t3  |1        |39  |
|2 | HASH OUTER JOIN     |    |8        |93  |
|3 |  TABLE SCAN         |t1  |8        |38  |
|4 |  TABLE SCAN         |t2  |9        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c1 > 1])
  1 - output([t3.c1], [t3.c2]), filter([t3.c1 > 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 | NULL | NULL |
|    1 |    1 |    1 |    1 | NULL | NULL |
|    2 |    2 |    2 |    2 | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |
|    5 |    5 | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |8        |146 |
|1 | TABLE SCAN          |t3  |8        |38  |
|2 | HASH OUTER JOIN     |    |8        |93  |
|3 |  TABLE SCAN         |t1  |8        |38  |
|4 |  TABLE SCAN         |t2  |9        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c1 > 1])
  1 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 | NULL | NULL |
|    1 |    1 |    1 |    1 | NULL | NULL |
|    2 |    2 |    2 |    2 | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |
|    5 |    5 | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+
EXPLAIN insert into t5_temp (select * from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |8        |138 |
|1 | SUBPLAN SCAN          |VIEW1|8        |137 |
|2 |  HASH RIGHT OUTER JOIN|     |8        |136 |
|3 |   TABLE SCAN          |t3   |1        |39  |
|4 |   HASH OUTER JOIN     |     |8        |93  |
|5 |    TABLE SCAN         |t1   |8        |38  |
|6 |    TABLE SCAN         |t2   |9        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.f, t5_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c1 > 1])
  3 - output([t3.c1], [t3.c2]), filter([t3.c1 > 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t5_temp (select * from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1);

rollback;
EXPLAIN insert into t5_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |8        |148 |
|1 | SUBPLAN SCAN          |VIEW1|8        |147 |
|2 |  HASH RIGHT OUTER JOIN|     |8        |146 |
|3 |   TABLE SCAN          |t3   |8        |38  |
|4 |   HASH OUTER JOIN     |     |8        |93  |
|5 |    TABLE SCAN         |t1   |8        |38  |
|6 |    TABLE SCAN         |t2   |9        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.f, t5_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c1 > 1])
  3 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t5_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                  |     |8        |165 |
|1 | SUBPLAN FILTER         |     |8        |157 |
|2 |  TABLE SCAN            |t1   |8        |38  |
|3 |  LIMIT                 |     |1        |119 |
|4 |   HASH RIGHT OUTER JOIN|     |1        |118 |
|5 |    TABLE SCAN          |t3   |1        |39  |
|6 |    HASH OUTER JOIN     |     |1        |79  |
|7 |     SUBPLAN SCAN       |VIEW1|1        |37  |
|8 |      TABLE SCAN        |t1   |1        |36  |
|9 |     TABLE SCAN         |t2   |9        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c1 > 1])
  5 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0)
  6 - output([VIEW1.t1.c1], [t2.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t2.c1]), other_conds(nil)
  7 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |8        |177 |
|1 | SUBPLAN FILTER         |    |8        |169 |
|2 |  TABLE SCAN            |t1  |8        |38  |
|3 |  LIMIT                 |    |1        |130 |
|4 |   HASH RIGHT OUTER JOIN|    |1        |130 |
|5 |    TABLE SCAN          |t3  |8        |38  |
|6 |    HASH OUTER JOIN     |    |1        |83  |
|7 |     TABLE SCAN         |t1  |8        |38  |
|8 |     TABLE SCAN         |t2  |2        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c1 > 1])
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                  |     |1        |158 |
|1 | SUBPLAN FILTER         |     |1        |157 |
|2 |  TABLE SCAN            |t1   |1        |39  |
|3 |  LIMIT                 |     |1        |119 |
|4 |   HASH RIGHT OUTER JOIN|     |1        |118 |
|5 |    TABLE SCAN          |t3   |1        |39  |
|6 |    HASH OUTER JOIN     |     |1        |79  |
|7 |     SUBPLAN SCAN       |VIEW1|1        |37  |
|8 |      TABLE SCAN        |t1   |1        |36  |
|9 |     TABLE SCAN         |t2   |9        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c1 > 1])
  5 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0)
  6 - output([VIEW1.t1.c1], [t2.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t2.c1]), other_conds(nil)
  7 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |169 |
|1 | SUBPLAN FILTER         |    |1        |168 |
|2 |  TABLE SCAN            |t1  |1        |39  |
|3 |  LIMIT                 |    |1        |130 |
|4 |   HASH RIGHT OUTER JOIN|    |1        |130 |
|5 |    TABLE SCAN          |t3  |8        |38  |
|6 |    HASH OUTER JOIN     |    |1        |83  |
|7 |     TABLE SCAN         |t1  |8        |38  |
|8 |     TABLE SCAN         |t2  |2        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c1 > 1])
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t3 on t2.c1=t3.c1 and t2.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1;
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |HASH JOIN                  |    |8        |179 |
|1 | TABLE SCAN                |t4  |8        |38  |
|2 | NESTED-LOOP JOIN CARTESIAN|    |9        |124 |
|3 |  TABLE SCAN               |t2  |9        |38  |
|4 |  MATERIAL                 |    |1        |80  |
|5 |   MERGE OUTER JOIN        |    |1        |79  |
|6 |    TABLE SCAN             |t1  |1        |39  |
|7 |    TABLE SCAN             |t3  |1        |39  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  1 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter([t1.c1 = 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t3.c1], [t3.c2]), filter([t3.c1 = 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    2 |    2 |    1 |    1 |    2 |    2 |
|    1 |    1 |    3 |    3 |    1 |    1 |    3 |    3 |
|    1 |    1 |    4 |    4 |    1 |    1 |    4 |    4 |
+------+------+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1;
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |HASH RIGHT OUTER JOIN   |    |8        |221 |
|1 | TABLE SCAN             |t3  |8        |38  |
|2 | HASH JOIN              |    |8        |166 |
|3 |  TABLE SCAN            |t4  |8        |38  |
|4 |  NESTED-LOOP OUTER JOIN|    |9        |110 |
|5 |   TABLE SCAN           |t1  |8        |38  |
|6 |   MATERIAL             |    |9        |41  |
|7 |    TABLE SCAN          |t2  |9        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  3 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    2 |    2 |    1 |    1 |    2 |    2 |
|    1 |    1 |    3 |    3 |    1 |    1 |    3 |    3 |
|    1 |    1 |    4 |    4 |    1 |    1 |    4 |    4 |
+------+------+------+------+------+------+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1);
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |8        |181 |
|1 | SUBPLAN SCAN                |VIEW1|8        |180 |
|2 |  HASH JOIN                  |     |8        |179 |
|3 |   TABLE SCAN                |t4   |8        |38  |
|4 |   NESTED-LOOP JOIN CARTESIAN|     |9        |124 |
|5 |    TABLE SCAN               |t2   |9        |38  |
|6 |    MATERIAL                 |     |1        |80  |
|7 |     MERGE OUTER JOIN        |     |1        |79  |
|8 |      TABLE SCAN             |t1   |1        |39  |
|9 |      TABLE SCAN             |t3   |1        |39  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  3 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t1.c1], [t1.c2]), filter([t1.c1 = 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([t3.c1], [t3.c2]), filter([t3.c1 = 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)

insert into t7_temp (select * from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1);

rollback;
EXPLAIN insert into t7_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT                    |     |8        |223 |
|1 | SUBPLAN SCAN             |VIEW1|8        |222 |
|2 |  HASH RIGHT OUTER JOIN   |     |8        |221 |
|3 |   TABLE SCAN             |t3   |8        |38  |
|4 |   HASH JOIN              |     |8        |166 |
|5 |    TABLE SCAN            |t4   |8        |38  |
|6 |    NESTED-LOOP OUTER JOIN|     |9        |110 |
|7 |     TABLE SCAN           |t1   |8        |38  |
|8 |     MATERIAL             |     |9        |41  |
|9 |      TABLE SCAN          |t2   |9        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  5 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t2.c1], [t2.c2]), filter(nil)
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t7_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1 limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |8        |209 |
|1 | SUBPLAN FILTER               |    |8        |201 |
|2 |  TABLE SCAN                  |t1  |8        |38  |
|3 |  LIMIT                       |    |1        |163 |
|4 |   HASH JOIN                  |    |1        |163 |
|5 |    TABLE SCAN                |t4  |8        |38  |
|6 |    NESTED-LOOP JOIN CARTESIAN|    |2        |116 |
|7 |     TABLE SCAN               |t2  |2        |36  |
|8 |     MATERIAL                 |    |1        |79  |
|9 |      MERGE OUTER JOIN        |    |1        |78  |
|10|       TABLE SCAN             |t1  |1        |39  |
|11|       TABLE SCAN             |t3  |1        |39  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  10 - output([t1.c1]), filter([t1.c1 = 1]), 
      access([t1.c1]), partitions(p0)
  11 - output([t3.c1]), filter([t3.c1 = 1]), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |8        |220 |
|1 | SUBPLAN FILTER           |    |8        |212 |
|2 |  TABLE SCAN              |t1  |8        |38  |
|3 |  LIMIT                   |    |1        |173 |
|4 |   HASH JOIN              |    |1        |173 |
|5 |    TABLE SCAN            |t4  |8        |38  |
|6 |    NESTED-LOOP OUTER JOIN|    |2        |126 |
|7 |     HASH OUTER JOIN      |    |1        |83  |
|8 |      TABLE SCAN          |t1  |8        |38  |
|9 |      TABLE SCAN          |t3  |1        |36  |
|10|     MATERIAL             |    |9        |40  |
|11|      TABLE SCAN          |t2  |9        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1 limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |202 |
|1 | SUBPLAN FILTER               |    |1        |201 |
|2 |  TABLE SCAN                  |t1  |1        |39  |
|3 |  LIMIT                       |    |1        |163 |
|4 |   HASH JOIN                  |    |1        |163 |
|5 |    TABLE SCAN                |t4  |8        |38  |
|6 |    NESTED-LOOP JOIN CARTESIAN|    |2        |116 |
|7 |     TABLE SCAN               |t2  |2        |36  |
|8 |     MATERIAL                 |    |1        |79  |
|9 |      MERGE OUTER JOIN        |    |1        |78  |
|10|       TABLE SCAN             |t1  |1        |39  |
|11|       TABLE SCAN             |t3  |1        |39  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  10 - output([t1.c1]), filter([t1.c1 = 1]), 
      access([t1.c1]), partitions(p0)
  11 - output([t3.c1]), filter([t3.c1 = 1]), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |212 |
|1 | SUBPLAN FILTER           |    |1        |211 |
|2 |  TABLE SCAN              |t1  |1        |39  |
|3 |  LIMIT                   |    |1        |173 |
|4 |   HASH JOIN              |    |1        |173 |
|5 |    TABLE SCAN            |t4  |8        |38  |
|6 |    NESTED-LOOP OUTER JOIN|    |2        |126 |
|7 |     HASH OUTER JOIN      |    |1        |83  |
|8 |      TABLE SCAN          |t1  |8        |38  |
|9 |      TABLE SCAN          |t3  |1        |36  |
|10|     MATERIAL             |    |9        |40  |
|11|      TABLE SCAN          |t2  |9        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 inner join t4 on t4.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |HASH RIGHT OUTER JOIN  |    |9        |221 |
|1 | TABLE SCAN            |t4  |8        |38  |
|2 | NESTED-LOOP OUTER JOIN|    |9        |165 |
|3 |  HASH OUTER JOIN      |    |8        |93  |
|4 |   TABLE SCAN          |t1  |8        |38  |
|5 |   TABLE SCAN          |t3  |8        |38  |
|6 |  MATERIAL             |    |9        |41  |
|7 |   TABLE SCAN          |t2  |9        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  1 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    2 |    2 |    1 |    1 |    2 |    2 |
|    1 |    1 |    3 |    3 |    1 |    1 |    3 |    3 |
|    1 |    1 |    4 |    4 |    1 |    1 |    4 |    4 |
|    1 |    1 |    6 |    6 |    1 |    1 | NULL | NULL |
|    1 |    1 | NULL |    2 |    1 |    1 | NULL | NULL |
|    1 |    1 | NULL |    6 |    1 |    1 | NULL | NULL |
|    1 |    1 | NULL | NULL |    1 |    1 | NULL | NULL |
|    2 |    2 | NULL | NULL | NULL | NULL | NULL | NULL |
|    3 |    2 | NULL | NULL |    3 |    3 | NULL | NULL |
|    4 |    2 | NULL | NULL |    4 |    4 | NULL | NULL |
|    5 |    5 | NULL | NULL |    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |HASH RIGHT OUTER JOIN  |    |9        |221 |
|1 | TABLE SCAN            |t4  |8        |38  |
|2 | NESTED-LOOP OUTER JOIN|    |9        |165 |
|3 |  HASH OUTER JOIN      |    |8        |93  |
|4 |   TABLE SCAN          |t1  |8        |38  |
|5 |   TABLE SCAN          |t3  |8        |38  |
|6 |  MATERIAL             |    |9        |41  |
|7 |   TABLE SCAN          |t2  |9        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  1 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    2 |    2 |    1 |    1 |    2 |    2 |
|    1 |    1 |    3 |    3 |    1 |    1 |    3 |    3 |
|    1 |    1 |    4 |    4 |    1 |    1 |    4 |    4 |
|    1 |    1 |    6 |    6 |    1 |    1 | NULL | NULL |
|    1 |    1 | NULL |    2 |    1 |    1 | NULL | NULL |
|    1 |    1 | NULL |    6 |    1 |    1 | NULL | NULL |
|    1 |    1 | NULL | NULL |    1 |    1 | NULL | NULL |
|    2 |    2 | NULL | NULL | NULL | NULL | NULL | NULL |
|    3 |    2 | NULL | NULL |    3 |    3 | NULL | NULL |
|    4 |    2 | NULL | NULL |    4 |    4 | NULL | NULL |
|    5 |    5 | NULL | NULL |    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |9        |223 |
|1 | SUBPLAN SCAN            |VIEW1|9        |222 |
|2 |  HASH RIGHT OUTER JOIN  |     |9        |221 |
|3 |   TABLE SCAN            |t4   |8        |38  |
|4 |   NESTED-LOOP OUTER JOIN|     |9        |165 |
|5 |    HASH OUTER JOIN      |     |8        |93  |
|6 |     TABLE SCAN          |t1   |8        |38  |
|7 |     TABLE SCAN          |t3   |8        |38  |
|8 |    MATERIAL             |     |9        |41  |
|9 |     TABLE SCAN          |t2   |9        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  3 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  8 - output([t2.c1], [t2.c2]), filter(nil)
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t7_temp (select * from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1);

rollback;
EXPLAIN insert into t7_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |9        |223 |
|1 | SUBPLAN SCAN            |VIEW1|9        |222 |
|2 |  HASH RIGHT OUTER JOIN  |     |9        |221 |
|3 |   TABLE SCAN            |t4   |8        |38  |
|4 |   NESTED-LOOP OUTER JOIN|     |9        |165 |
|5 |    HASH OUTER JOIN      |     |8        |93  |
|6 |     TABLE SCAN          |t1   |8        |38  |
|7 |     TABLE SCAN          |t3   |8        |38  |
|8 |    MATERIAL             |     |9        |41  |
|9 |     TABLE SCAN          |t2   |9        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  3 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  8 - output([t2.c1], [t2.c2]), filter(nil)
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t7_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1 limit 1);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                    |     |8        |207 |
|1 | SUBPLAN FILTER           |     |8        |199 |
|2 |  TABLE SCAN              |t1   |8        |38  |
|3 |  LIMIT                   |     |1        |161 |
|4 |   HASH RIGHT OUTER JOIN  |     |1        |161 |
|5 |    TABLE SCAN            |t4   |8        |38  |
|6 |    NESTED-LOOP OUTER JOIN|     |1        |114 |
|7 |     HASH OUTER JOIN      |     |1        |74  |
|8 |      SUBPLAN SCAN        |VIEW1|1        |37  |
|9 |       TABLE SCAN         |t1   |1        |36  |
|10|      TABLE SCAN          |t3   |1        |36  |
|11|     MATERIAL             |     |9        |40  |
|12|      TABLE SCAN          |t2   |9        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([VIEW1.t1.c1], [t2.c1]), filter(nil), 
      conds([VIEW1.t1.c1 = 1]), nl_params_(nil)
  7 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  8 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |8        |219 |
|1 | SUBPLAN FILTER           |    |8        |211 |
|2 |  TABLE SCAN              |t1  |8        |38  |
|3 |  LIMIT                   |    |1        |173 |
|4 |   HASH RIGHT OUTER JOIN  |    |1        |172 |
|5 |    TABLE SCAN            |t4  |8        |38  |
|6 |    NESTED-LOOP OUTER JOIN|    |1        |126 |
|7 |     HASH OUTER JOIN      |    |1        |83  |
|8 |      TABLE SCAN          |t1  |8        |38  |
|9 |      TABLE SCAN          |t3  |1        |36  |
|10|     MATERIAL             |    |9        |40  |
|11|      TABLE SCAN          |t2  |9        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1 limit 1);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                    |     |1        |200 |
|1 | SUBPLAN FILTER           |     |1        |199 |
|2 |  TABLE SCAN              |t1   |1        |39  |
|3 |  LIMIT                   |     |1        |161 |
|4 |   HASH RIGHT OUTER JOIN  |     |1        |161 |
|5 |    TABLE SCAN            |t4   |8        |38  |
|6 |    NESTED-LOOP OUTER JOIN|     |1        |114 |
|7 |     HASH OUTER JOIN      |     |1        |74  |
|8 |      SUBPLAN SCAN        |VIEW1|1        |37  |
|9 |       TABLE SCAN         |t1   |1        |36  |
|10|      TABLE SCAN          |t3   |1        |36  |
|11|     MATERIAL             |     |9        |40  |
|12|      TABLE SCAN          |t2   |9        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([VIEW1.t1.c1], [t2.c1]), filter(nil), 
      conds([VIEW1.t1.c1 = 1]), nl_params_(nil)
  7 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  8 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |212 |
|1 | SUBPLAN FILTER           |    |1        |211 |
|2 |  TABLE SCAN              |t1  |1        |39  |
|3 |  LIMIT                   |    |1        |173 |
|4 |   HASH RIGHT OUTER JOIN  |    |1        |172 |
|5 |    TABLE SCAN            |t4  |8        |38  |
|6 |    NESTED-LOOP OUTER JOIN|    |1        |126 |
|7 |     HASH OUTER JOIN      |    |1        |83  |
|8 |      TABLE SCAN          |t1  |8        |38  |
|9 |      TABLE SCAN          |t3  |1        |36  |
|10|     MATERIAL             |    |9        |40  |
|11|      TABLE SCAN          |t2  |9        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  7 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t4.c1=t2.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |8        |203 |
|1 | SORT           |    |8        |46  |
|2 |  TABLE SCAN    |t1  |8        |38  |
|3 | MERGE JOIN     |    |8        |151 |
|4 |  MERGE JOIN    |    |8        |99  |
|5 |   SORT         |    |8        |46  |
|6 |    TABLE SCAN  |t3  |8        |38  |
|7 |   SORT         |    |9        |47  |
|8 |    TABLE SCAN  |t2  |9        |38  |
|9 |  SORT          |    |8        |46  |
|10|   TABLE SCAN   |t4  |8        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  4 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  6 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  9 - output([t4.c1], [t4.c2]), filter(nil), sort_keys([t4.c1, ASC])
  10 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

select * from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 | NULL | NULL | NULL | NULL | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
|    5 |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |HASH OUTER JOIN        |    |9        |205 |
|1 | TABLE SCAN            |t1  |8        |38  |
|2 | HASH RIGHT OUTER JOIN |    |9        |149 |
|3 |  TABLE SCAN           |t4  |8        |38  |
|4 |  HASH RIGHT OUTER JOIN|    |9        |93  |
|5 |   TABLE SCAN          |t3  |8        |38  |
|6 |   TABLE SCAN          |t2  |9        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  3 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 | NULL | NULL | NULL | NULL | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
|    5 |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |8        |205 |
|1 | SUBPLAN SCAN     |VIEW1|8        |204 |
|2 |  MERGE OUTER JOIN|     |8        |203 |
|3 |   SORT           |     |8        |46  |
|4 |    TABLE SCAN    |t1   |8        |38  |
|5 |   MERGE JOIN     |     |8        |151 |
|6 |    MERGE JOIN    |     |8        |99  |
|7 |     SORT         |     |8        |46  |
|8 |      TABLE SCAN  |t3   |8        |38  |
|9 |     SORT         |     |9        |47  |
|10|      TABLE SCAN  |t2   |9        |38  |
|11|    SORT          |     |8        |46  |
|12|     TABLE SCAN   |t4   |8        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  8 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  9 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  11 - output([t4.c1], [t4.c2]), filter(nil), sort_keys([t4.c1, ASC])
  12 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

insert into t7_temp (select * from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1);

rollback;
EXPLAIN insert into t7_temp (select /*+NO_REWRITE*/* from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |9        |208 |
|1 | SUBPLAN SCAN            |VIEW1|9        |206 |
|2 |  HASH OUTER JOIN        |     |9        |205 |
|3 |   TABLE SCAN            |t1   |8        |38  |
|4 |   HASH RIGHT OUTER JOIN |     |9        |149 |
|5 |    TABLE SCAN           |t4   |8        |38  |
|6 |    HASH RIGHT OUTER JOIN|     |9        |93  |
|7 |     TABLE SCAN          |t3   |8        |38  |
|8 |     TABLE SCAN          |t2   |9        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  5 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t7_temp (select /*+NO_REWRITE*/* from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1 limit 1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE             |     |8        |231 |
|1 | SUBPLAN FILTER    |     |8        |223 |
|2 |  TABLE SCAN       |t1   |8        |38  |
|3 |  LIMIT            |     |1        |184 |
|4 |   MERGE OUTER JOIN|     |1        |184 |
|5 |    SORT           |     |1        |37  |
|6 |     SUBPLAN SCAN  |VIEW1|1        |37  |
|7 |      TABLE SCAN   |t1   |1        |36  |
|8 |    MERGE JOIN     |     |8        |146 |
|9 |     MERGE JOIN    |     |8        |94  |
|10|      SORT         |     |8        |44  |
|11|       TABLE SCAN  |t3   |8        |38  |
|12|      SORT         |     |8        |44  |
|13|       TABLE SCAN  |t4   |8        |38  |
|14|     SORT          |     |9        |45  |
|15|      TABLE SCAN   |t2   |9        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t4.c1]), other_conds(nil)
  5 - output([VIEW1.t1.c1]), filter(nil), sort_keys([VIEW1.t1.c1, ASC])
  6 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t4.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  9 - output([t4.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  10 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  14 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  15 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |8        |225 |
|1 | SUBPLAN FILTER     |    |8        |217 |
|2 |  TABLE SCAN        |t1  |8        |38  |
|3 |  LIMIT             |    |1        |178 |
|4 |   HASH OUTER JOIN  |    |1        |178 |
|5 |    TABLE SCAN      |t1  |8        |38  |
|6 |    HASH OUTER JOIN |    |1        |131 |
|7 |     TABLE SCAN     |t2  |9        |38  |
|8 |     HASH OUTER JOIN|    |1        |83  |
|9 |      TABLE SCAN    |t3  |8        |38  |
|10|      TABLE SCAN    |t4  |1        |36  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t4.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t4.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1 limit 1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |DELETE             |     |1        |223 |
|1 | SUBPLAN FILTER    |     |1        |222 |
|2 |  TABLE SCAN       |t1   |1        |39  |
|3 |  LIMIT            |     |1        |184 |
|4 |   MERGE OUTER JOIN|     |1        |184 |
|5 |    SORT           |     |1        |37  |
|6 |     SUBPLAN SCAN  |VIEW1|1        |37  |
|7 |      TABLE SCAN   |t1   |1        |36  |
|8 |    MERGE JOIN     |     |8        |146 |
|9 |     MERGE JOIN    |     |8        |94  |
|10|      SORT         |     |8        |44  |
|11|       TABLE SCAN  |t3   |8        |38  |
|12|      SORT         |     |8        |44  |
|13|       TABLE SCAN  |t4   |8        |38  |
|14|     SORT          |     |9        |45  |
|15|      TABLE SCAN   |t2   |9        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t4.c1]), other_conds(nil)
  5 - output([VIEW1.t1.c1]), filter(nil), sort_keys([VIEW1.t1.c1, ASC])
  6 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t4.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  9 - output([t4.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  10 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  14 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  15 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |217 |
|1 | SUBPLAN FILTER     |    |1        |216 |
|2 |  TABLE SCAN        |t1  |1        |39  |
|3 |  LIMIT             |    |1        |178 |
|4 |   HASH OUTER JOIN  |    |1        |178 |
|5 |    TABLE SCAN      |t1  |8        |38  |
|6 |    HASH OUTER JOIN |    |1        |131 |
|7 |     TABLE SCAN     |t2  |9        |38  |
|8 |     HASH OUTER JOIN|    |1        |83  |
|9 |      TABLE SCAN    |t3  |8        |38  |
|10|      TABLE SCAN    |t4  |1        |36  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t4.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t4.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |MERGE OUTER JOIN |    |8        |203 |
|1 | SORT            |    |8        |46  |
|2 |  TABLE SCAN     |t1  |8        |38  |
|3 | MERGE OUTER JOIN|    |8        |151 |
|4 |  MERGE JOIN     |    |8        |99  |
|5 |   SORT          |    |9        |47  |
|6 |    TABLE SCAN   |t2  |9        |38  |
|7 |   SORT          |    |8        |46  |
|8 |    TABLE SCAN   |t3  |8        |38  |
|9 |  SORT           |    |8        |46  |
|10|   TABLE SCAN    |t4  |8        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  4 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  8 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  9 - output([t4.c1], [t4.c2]), filter(nil), sort_keys([t4.c1, ASC])
  10 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

select * from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 | NULL | NULL | NULL | NULL | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
|    5 |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |HASH RIGHT OUTER JOIN  |    |9        |205 |
|1 | TABLE SCAN            |t4  |8        |38  |
|2 | HASH OUTER JOIN       |    |9        |149 |
|3 |  TABLE SCAN           |t1  |8        |38  |
|4 |  HASH RIGHT OUTER JOIN|    |9        |93  |
|5 |   TABLE SCAN          |t3  |8        |38  |
|6 |   TABLE SCAN          |t2  |9        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  1 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 | NULL | NULL | NULL | NULL | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
|    5 |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |8        |205 |
|1 | SUBPLAN SCAN      |VIEW1|8        |204 |
|2 |  MERGE OUTER JOIN |     |8        |203 |
|3 |   SORT            |     |8        |46  |
|4 |    TABLE SCAN     |t1   |8        |38  |
|5 |   MERGE OUTER JOIN|     |8        |151 |
|6 |    MERGE JOIN     |     |8        |99  |
|7 |     SORT          |     |9        |47  |
|8 |      TABLE SCAN   |t2   |9        |38  |
|9 |     SORT          |     |8        |46  |
|10|      TABLE SCAN   |t3   |8        |38  |
|11|    SORT           |     |8        |46  |
|12|     TABLE SCAN    |t4   |8        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  9 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  10 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  11 - output([t4.c1], [t4.c2]), filter(nil), sort_keys([t4.c1, ASC])
  12 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

insert into t7_temp (select * from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1);

rollback;
EXPLAIN insert into t7_temp (select /*+NO_REWRITE*/* from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |9        |208 |
|1 | SUBPLAN SCAN            |VIEW1|9        |206 |
|2 |  HASH RIGHT OUTER JOIN  |     |9        |205 |
|3 |   TABLE SCAN            |t4   |8        |38  |
|4 |   HASH OUTER JOIN       |     |9        |149 |
|5 |    TABLE SCAN           |t1   |8        |38  |
|6 |    HASH RIGHT OUTER JOIN|     |9        |93  |
|7 |     TABLE SCAN          |t3   |8        |38  |
|8 |     TABLE SCAN          |t2   |9        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  3 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t7_temp (select /*+NO_REWRITE*/* from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1 limit 1);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |UPDATE               |     |8        |231 |
|1 | SUBPLAN FILTER      |     |8        |223 |
|2 |  TABLE SCAN         |t1   |8        |38  |
|3 |  LIMIT              |     |1        |184 |
|4 |   MERGE OUTER JOIN  |     |1        |184 |
|5 |    SORT             |     |1        |37  |
|6 |     SUBPLAN SCAN    |VIEW1|1        |37  |
|7 |      TABLE SCAN     |t1   |1        |36  |
|8 |    MERGE JOIN       |     |8        |146 |
|9 |     MERGE OUTER JOIN|     |8        |94  |
|10|      SORT           |     |8        |44  |
|11|       TABLE SCAN    |t3   |8        |38  |
|12|      SORT           |     |8        |44  |
|13|       TABLE SCAN    |t4   |8        |38  |
|14|     SORT            |     |9        |45  |
|15|      TABLE SCAN     |t2   |9        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  5 - output([VIEW1.t1.c1]), filter(nil), sort_keys([VIEW1.t1.c1, ASC])
  6 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  10 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  14 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  15 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |8        |225 |
|1 | SUBPLAN FILTER     |    |8        |217 |
|2 |  TABLE SCAN        |t1  |8        |38  |
|3 |  LIMIT             |    |1        |178 |
|4 |   HASH OUTER JOIN  |    |1        |178 |
|5 |    TABLE SCAN      |t1  |8        |38  |
|6 |    HASH OUTER JOIN |    |1        |131 |
|7 |     TABLE SCAN     |t2  |9        |38  |
|8 |     HASH OUTER JOIN|    |1        |83  |
|9 |      TABLE SCAN    |t3  |8        |38  |
|10|      TABLE SCAN    |t4  |1        |36  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1 limit 1);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |DELETE               |     |1        |223 |
|1 | SUBPLAN FILTER      |     |1        |222 |
|2 |  TABLE SCAN         |t1   |1        |39  |
|3 |  LIMIT              |     |1        |184 |
|4 |   MERGE OUTER JOIN  |     |1        |184 |
|5 |    SORT             |     |1        |37  |
|6 |     SUBPLAN SCAN    |VIEW1|1        |37  |
|7 |      TABLE SCAN     |t1   |1        |36  |
|8 |    MERGE JOIN       |     |8        |146 |
|9 |     MERGE OUTER JOIN|     |8        |94  |
|10|      SORT           |     |8        |44  |
|11|       TABLE SCAN    |t3   |8        |38  |
|12|      SORT           |     |8        |44  |
|13|       TABLE SCAN    |t4   |8        |38  |
|14|     SORT            |     |9        |45  |
|15|      TABLE SCAN     |t2   |9        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  5 - output([VIEW1.t1.c1]), filter(nil), sort_keys([VIEW1.t1.c1, ASC])
  6 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  10 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  14 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  15 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1 limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |217 |
|1 | SUBPLAN FILTER     |    |1        |216 |
|2 |  TABLE SCAN        |t1  |1        |39  |
|3 |  LIMIT             |    |1        |178 |
|4 |   HASH OUTER JOIN  |    |1        |178 |
|5 |    TABLE SCAN      |t1  |8        |38  |
|6 |    HASH OUTER JOIN |    |1        |131 |
|7 |     TABLE SCAN     |t2  |9        |38  |
|8 |     HASH OUTER JOIN|    |1        |83  |
|9 |      TABLE SCAN    |t3  |8        |38  |
|10|      TABLE SCAN    |t4  |1        |36  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t1.c1=t3.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN |    |6        |169 |
|1 | NESTED-LOOP OUTER JOIN|    |1        |123 |
|2 |  HASH JOIN            |    |1        |80  |
|3 |   TABLE SCAN          |t3  |1        |39  |
|4 |   TABLE SCAN          |t1  |1        |39  |
|5 |  MATERIAL             |    |8        |41  |
|6 |   TABLE SCAN          |t4  |8        |38  |
|7 | MATERIAL              |    |9        |41  |
|8 |  TABLE SCAN           |t2  |9        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds([t1.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1], [t3.c2]), filter([t3.c1 > 0]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter([t1.c1 > 0]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t4.c1], [t4.c2]), filter(nil)
  6 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 | NULL | NULL |
|    1 |    1 |    1 |    1 |    1 |    1 | NULL | NULL |
|    1 |    1 |    2 |    2 |    1 |    1 | NULL | NULL |
|    1 |    1 |    3 |    3 |    1 |    1 | NULL | NULL |
|    1 |    1 |    4 |    4 |    1 |    1 | NULL | NULL |
|    1 |    1 |    6 |    6 |    1 |    1 | NULL | NULL |
|    1 |    1 | NULL |    2 |    1 |    1 | NULL | NULL |
|    1 |    1 | NULL |    6 |    1 |    1 | NULL | NULL |
|    1 |    1 | NULL | NULL |    1 |    1 | NULL | NULL |
|    3 |    2 | NULL | NULL |    3 |    3 |    1 |    1 |
|    3 |    2 | NULL | NULL |    3 |    3 |    2 |    2 |
|    3 |    2 | NULL | NULL |    3 |    3 |    3 |    3 |
|    3 |    2 | NULL | NULL |    3 |    3 |    4 |    4 |
|    3 |    2 | NULL | NULL |    3 |    3 |    8 |    8 |
|    3 |    2 | NULL | NULL |    3 |    3 |    8 |    8 |
|    3 |    2 | NULL | NULL |    3 |    3 | NULL |    4 |
|    3 |    2 | NULL | NULL |    3 |    3 | NULL |    8 |
|    4 |    2 | NULL | NULL |    4 |    4 |    1 |    1 |
|    4 |    2 | NULL | NULL |    4 |    4 |    2 |    2 |
|    4 |    2 | NULL | NULL |    4 |    4 |    3 |    3 |
|    4 |    2 | NULL | NULL |    4 |    4 |    4 |    4 |
|    4 |    2 | NULL | NULL |    4 |    4 |    8 |    8 |
|    4 |    2 | NULL | NULL |    4 |    4 |    8 |    8 |
|    4 |    2 | NULL | NULL |    4 |    4 | NULL |    4 |
|    4 |    2 | NULL | NULL |    4 |    4 | NULL |    8 |
|    5 |    5 | NULL | NULL |    5 |    5 |    1 |    1 |
|    5 |    5 | NULL | NULL |    5 |    5 |    2 |    2 |
|    5 |    5 | NULL | NULL |    5 |    5 |    3 |    3 |
|    5 |    5 | NULL | NULL |    5 |    5 |    4 |    4 |
|    5 |    5 | NULL | NULL |    5 |    5 |    8 |    8 |
|    5 |    5 | NULL | NULL |    5 |    5 |    8 |    8 |
|    5 |    5 | NULL | NULL |    5 |    5 | NULL |    4 |
|    5 |    5 | NULL | NULL |    5 |    5 | NULL |    8 |
+------+------+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN |    |1        |210 |
|1 | NESTED-LOOP OUTER JOIN|    |1        |165 |
|2 |  HASH OUTER JOIN      |    |8        |93  |
|3 |   TABLE SCAN          |t1  |8        |38  |
|4 |   TABLE SCAN          |t3  |8        |38  |
|5 |  MATERIAL             |    |9        |41  |
|6 |   TABLE SCAN          |t2  |9        |38  |
|7 | MATERIAL              |    |8        |41  |
|8 |  TABLE SCAN           |t4  |8        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds([t1.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter([t3.c1 > 0]), 
      conds([t1.c1 = 1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t4.c1], [t4.c2]), filter(nil)
  8 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 | NULL | NULL |
|    1 |    1 |    1 |    1 |    1 |    1 | NULL | NULL |
|    1 |    1 |    2 |    2 |    1 |    1 | NULL | NULL |
|    1 |    1 |    3 |    3 |    1 |    1 | NULL | NULL |
|    1 |    1 |    4 |    4 |    1 |    1 | NULL | NULL |
|    1 |    1 |    6 |    6 |    1 |    1 | NULL | NULL |
|    1 |    1 | NULL |    2 |    1 |    1 | NULL | NULL |
|    1 |    1 | NULL |    6 |    1 |    1 | NULL | NULL |
|    1 |    1 | NULL | NULL |    1 |    1 | NULL | NULL |
|    3 |    2 | NULL | NULL |    3 |    3 |    1 |    1 |
|    3 |    2 | NULL | NULL |    3 |    3 |    2 |    2 |
|    3 |    2 | NULL | NULL |    3 |    3 |    3 |    3 |
|    3 |    2 | NULL | NULL |    3 |    3 |    4 |    4 |
|    3 |    2 | NULL | NULL |    3 |    3 |    8 |    8 |
|    3 |    2 | NULL | NULL |    3 |    3 |    8 |    8 |
|    3 |    2 | NULL | NULL |    3 |    3 | NULL |    4 |
|    3 |    2 | NULL | NULL |    3 |    3 | NULL |    8 |
|    4 |    2 | NULL | NULL |    4 |    4 |    1 |    1 |
|    4 |    2 | NULL | NULL |    4 |    4 |    2 |    2 |
|    4 |    2 | NULL | NULL |    4 |    4 |    3 |    3 |
|    4 |    2 | NULL | NULL |    4 |    4 |    4 |    4 |
|    4 |    2 | NULL | NULL |    4 |    4 |    8 |    8 |
|    4 |    2 | NULL | NULL |    4 |    4 |    8 |    8 |
|    4 |    2 | NULL | NULL |    4 |    4 | NULL |    4 |
|    4 |    2 | NULL | NULL |    4 |    4 | NULL |    8 |
|    5 |    5 | NULL | NULL |    5 |    5 |    1 |    1 |
|    5 |    5 | NULL | NULL |    5 |    5 |    2 |    2 |
|    5 |    5 | NULL | NULL |    5 |    5 |    3 |    3 |
|    5 |    5 | NULL | NULL |    5 |    5 |    4 |    4 |
|    5 |    5 | NULL | NULL |    5 |    5 |    8 |    8 |
|    5 |    5 | NULL | NULL |    5 |    5 |    8 |    8 |
|    5 |    5 | NULL | NULL |    5 |    5 | NULL |    4 |
|    5 |    5 | NULL | NULL |    5 |    5 | NULL |    8 |
+------+------+------+------+------+------+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |6        |170 |
|1 | SUBPLAN SCAN            |VIEW1|6        |170 |
|2 |  NESTED-LOOP OUTER JOIN |     |6        |169 |
|3 |   NESTED-LOOP OUTER JOIN|     |1        |123 |
|4 |    HASH JOIN            |     |1        |80  |
|5 |     TABLE SCAN          |t3   |1        |39  |
|6 |     TABLE SCAN          |t1   |1        |39  |
|7 |    MATERIAL             |     |8        |41  |
|8 |     TABLE SCAN          |t4   |8        |38  |
|9 |   MATERIAL              |     |9        |41  |
|10|    TABLE SCAN           |t2   |9        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds([t1.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2]), filter([t3.c1 > 0]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter([t1.c1 > 0]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t4.c1], [t4.c2]), filter(nil)
  8 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  9 - output([t2.c1], [t2.c2]), filter(nil)
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t7_temp (select * from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0);

rollback;
EXPLAIN insert into t7_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |1        |210 |
|1 | SUBPLAN SCAN            |VIEW1|1        |210 |
|2 |  NESTED-LOOP OUTER JOIN |     |1        |210 |
|3 |   NESTED-LOOP OUTER JOIN|     |1        |165 |
|4 |    HASH OUTER JOIN      |     |8        |93  |
|5 |     TABLE SCAN          |t1   |8        |38  |
|6 |     TABLE SCAN          |t3   |8        |38  |
|7 |    MATERIAL             |     |9        |41  |
|8 |     TABLE SCAN          |t2   |9        |38  |
|9 |   MATERIAL              |     |8        |41  |
|10|    TABLE SCAN           |t4   |8        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds([t1.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter([t3.c1 > 0]), 
      conds([t1.c1 = 1]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  9 - output([t4.c1], [t4.c2]), filter(nil)
  10 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

insert into t7_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |8        |204 |
|1 | SUBPLAN FILTER           |    |8        |196 |
|2 |  TABLE SCAN              |t1  |8        |38  |
|3 |  LIMIT                   |    |1        |157 |
|4 |   NESTED-LOOP OUTER JOIN |    |1        |157 |
|5 |    NESTED-LOOP OUTER JOIN|    |1        |118 |
|6 |     MERGE JOIN           |    |1        |79  |
|7 |      SORT                |    |1        |39  |
|8 |       TABLE SCAN         |t3  |1        |39  |
|9 |      SORT                |    |1        |39  |
|10|       TABLE SCAN         |t1  |1        |39  |
|11|     MATERIAL             |    |8        |39  |
|12|      TABLE SCAN          |t4  |8        |38  |
|13|    MATERIAL              |    |9        |39  |
|14|     TABLE SCAN           |t2  |9        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds([t1.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  6 - output([t1.c1], [t3.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  8 - output([t3.c1]), filter([t3.c1 > 0]), 
      access([t3.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  10 - output([t1.c1]), filter([t1.c1 > 0]), 
      access([t1.c1]), partitions(p0)
  11 - output([1]), filter(nil)
  12 - output([1]), filter(nil), 
      access([t4.__pk_increment]), partitions(p0)
  13 - output([1]), filter(nil)
  14 - output([1]), filter(nil), 
      access([t2.__pk_increment]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |8        |250 |
|1 | SUBPLAN FILTER           |    |8        |242 |
|2 |  TABLE SCAN              |t1  |8        |38  |
|3 |  LIMIT                   |    |1        |203 |
|4 |   NESTED-LOOP OUTER JOIN |    |1        |203 |
|5 |    NESTED-LOOP OUTER JOIN|    |1        |161 |
|6 |     HASH OUTER JOIN      |    |8        |91  |
|7 |      TABLE SCAN          |t1  |8        |38  |
|8 |      TABLE SCAN          |t3  |8        |38  |
|9 |     MATERIAL             |    |9        |39  |
|10|      TABLE SCAN          |t2  |9        |38  |
|11|    MATERIAL              |    |8        |39  |
|12|     TABLE SCAN           |t4  |8        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1]), filter([t3.c1 > 0]), 
      conds([t1.c1 = 1]), nl_params_(nil)
  6 - output([t1.c1], [t3.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      access([t2.__pk_increment]), partitions(p0)
  11 - output([1]), filter(nil)
  12 - output([1]), filter(nil), 
      access([t4.__pk_increment]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |197 |
|1 | SUBPLAN FILTER           |    |1        |196 |
|2 |  TABLE SCAN              |t1  |1        |39  |
|3 |  LIMIT                   |    |1        |157 |
|4 |   NESTED-LOOP OUTER JOIN |    |1        |157 |
|5 |    NESTED-LOOP OUTER JOIN|    |1        |118 |
|6 |     MERGE JOIN           |    |1        |79  |
|7 |      SORT                |    |1        |39  |
|8 |       TABLE SCAN         |t3  |1        |39  |
|9 |      SORT                |    |1        |39  |
|10|       TABLE SCAN         |t1  |1        |39  |
|11|     MATERIAL             |    |8        |39  |
|12|      TABLE SCAN          |t4  |8        |38  |
|13|    MATERIAL              |    |9        |39  |
|14|     TABLE SCAN           |t2  |9        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 = 1]), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      conds([t1.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  6 - output([t1.c1], [t3.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  8 - output([t3.c1]), filter([t3.c1 > 0]), 
      access([t3.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  10 - output([t1.c1]), filter([t1.c1 > 0]), 
      access([t1.c1]), partitions(p0)
  11 - output([1]), filter(nil)
  12 - output([1]), filter(nil), 
      access([t4.__pk_increment]), partitions(p0)
  13 - output([1]), filter(nil)
  14 - output([1]), filter(nil), 
      access([t2.__pk_increment]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |242 |
|1 | SUBPLAN FILTER           |    |1        |241 |
|2 |  TABLE SCAN              |t1  |1        |39  |
|3 |  LIMIT                   |    |1        |203 |
|4 |   NESTED-LOOP OUTER JOIN |    |1        |203 |
|5 |    NESTED-LOOP OUTER JOIN|    |1        |161 |
|6 |     HASH OUTER JOIN      |    |8        |91  |
|7 |      TABLE SCAN          |t1  |8        |38  |
|8 |      TABLE SCAN          |t3  |8        |38  |
|9 |     MATERIAL             |    |9        |39  |
|10|      TABLE SCAN          |t2  |9        |38  |
|11|    MATERIAL              |    |8        |39  |
|12|     TABLE SCAN           |t4  |8        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds([t1.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  5 - output([t1.c1], [t3.c1]), filter([t3.c1 > 0]), 
      conds([t1.c1 = 1]), nl_params_(nil)
  6 - output([t1.c1], [t3.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([1]), filter(nil)
  10 - output([1]), filter(nil), 
      access([t2.__pk_increment]), partitions(p0)
  11 - output([1]), filter(nil)
  12 - output([1]), filter(nil), 
      access([t4.__pk_increment]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=1 left join t3 on t1.c1=t3.c1 left join t4 on t1.c1>1 and t3.c1>1 where t3.c1>0 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1;
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |6        |163 |
|1 | TABLE SCAN               |t1  |8        |38  |
|2 | MATERIAL                 |    |1        |121 |
|3 |  MERGE OUTER JOIN        |    |1        |120 |
|4 |   MERGE JOIN             |    |1        |80  |
|5 |    SORT                  |    |1        |40  |
|6 |     TABLE SCAN           |t2  |1        |40  |
|7 |    SORT                  |    |1        |40  |
|8 |     TABLE SCAN           |t3  |1        |39  |
|9 |   SORT                   |    |1        |40  |
|10|    TABLE SCAN            |t4  |1        |39  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil)
  3 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  4 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  5 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  6 - output([t2.c1], [t2.c2]), filter([t2.c1 > 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  8 - output([t3.c1], [t3.c2]), filter([t3.c1 > 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  9 - output([t4.c1], [t4.c2]), filter(nil), sort_keys([t4.c1, ASC])
  10 - output([t4.c1], [t4.c2]), filter([t4.c1 > 1]), 
      access([t4.c1], [t4.c2]), partitions(p0)

select * from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    3 |    3 |    3 |    3 |    3 |    3 |
|    1 |    1 |    4 |    4 |    4 |    4 |    4 |    4 |
|    2 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    2 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    3 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
|    4 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
|    5 |    5 |    3 |    3 |    3 |    3 |    3 |    3 |
|    5 |    5 |    4 |    4 |    4 |    4 |    4 |    4 |
|   10 |   10 |    3 |    3 |    3 |    3 |    3 |    3 |
|   10 |   10 |    4 |    4 |    4 |    4 |    4 |    4 |
| NULL |    1 |    3 |    3 |    3 |    3 |    3 |    3 |
| NULL |    1 |    4 |    4 |    4 |    4 |    4 |    4 |
| NULL |    5 |    3 |    3 |    3 |    3 |    3 |    3 |
| NULL |    5 |    4 |    4 |    4 |    4 |    4 |    4 |
+------+------+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1;
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN  |    |8        |193 |
|1 | TABLE SCAN             |t1  |8        |38  |
|2 | MATERIAL               |    |1        |150 |
|3 |  HASH RIGHT OUTER JOIN |    |1        |149 |
|4 |   TABLE SCAN           |t4  |8        |38  |
|5 |   HASH RIGHT OUTER JOIN|    |9        |93  |
|6 |    TABLE SCAN          |t3  |8        |38  |
|7 |    TABLE SCAN          |t2  |9        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter([t3.c1 > 1]), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil)
  3 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter([t3.c1 > 1]), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  4 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  6 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    3 |    3 |    3 |    3 |    3 |    3 |
|    1 |    1 |    4 |    4 |    4 |    4 |    4 |    4 |
|    2 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    2 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    3 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
|    4 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
|    5 |    5 |    3 |    3 |    3 |    3 |    3 |    3 |
|    5 |    5 |    4 |    4 |    4 |    4 |    4 |    4 |
|   10 |   10 |    3 |    3 |    3 |    3 |    3 |    3 |
|   10 |   10 |    4 |    4 |    4 |    4 |    4 |    4 |
| NULL |    1 |    3 |    3 |    3 |    3 |    3 |    3 |
| NULL |    1 |    4 |    4 |    4 |    4 |    4 |    4 |
| NULL |    5 |    3 |    3 |    3 |    3 |    3 |    3 |
| NULL |    5 |    4 |    4 |    4 |    4 |    4 |    4 |
+------+------+------+------+------+------+------+------+
EXPLAIN insert into t7_temp (select * from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1);
Query Plan
======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |INSERT                      |     |6        |164 |
|1 | SUBPLAN SCAN               |VIEW1|6        |163 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |6        |163 |
|3 |   TABLE SCAN               |t1   |8        |38  |
|4 |   MATERIAL                 |     |1        |121 |
|5 |    MERGE OUTER JOIN        |     |1        |120 |
|6 |     MERGE JOIN             |     |1        |80  |
|7 |      SORT                  |     |1        |40  |
|8 |       TABLE SCAN           |t2   |1        |40  |
|9 |      SORT                  |     |1        |40  |
|10|       TABLE SCAN           |t3   |1        |39  |
|11|     SORT                   |     |1        |40  |
|12|      TABLE SCAN            |t4   |1        |39  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  8 - output([t2.c1], [t2.c2]), filter([t2.c1 > 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  9 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  10 - output([t3.c1], [t3.c2]), filter([t3.c1 > 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  11 - output([t4.c1], [t4.c2]), filter(nil), sort_keys([t4.c1, ASC])
  12 - output([t4.c1], [t4.c2]), filter([t4.c1 > 1]), 
      access([t4.c1], [t4.c2]), partitions(p0)

insert into t7_temp (select * from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1);

rollback;
EXPLAIN insert into t7_temp (select /*+NO_REWRITE*/* from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT                    |     |8        |195 |
|1 | SUBPLAN SCAN             |VIEW1|8        |194 |
|2 |  NESTED-LOOP OUTER JOIN  |     |8        |193 |
|3 |   TABLE SCAN             |t1   |8        |38  |
|4 |   MATERIAL               |     |1        |150 |
|5 |    HASH RIGHT OUTER JOIN |     |1        |149 |
|6 |     TABLE SCAN           |t4   |8        |38  |
|7 |     HASH RIGHT OUTER JOIN|     |9        |93  |
|8 |      TABLE SCAN          |t3   |8        |38  |
|9 |      TABLE SCAN          |t2   |9        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter([t3.c1 > 1]), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter([t3.c1 > 1]), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  6 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t7_temp (select /*+NO_REWRITE*/* from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |UPDATE                       |    |8        |203 |
|1 | SUBPLAN FILTER              |    |8        |195 |
|2 |  TABLE SCAN                 |t1  |8        |38  |
|3 |  LIMIT                      |    |1        |156 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |156 |
|5 |    TABLE SCAN               |t1  |2        |36  |
|6 |    MATERIAL                 |    |1        |119 |
|7 |     MERGE OUTER JOIN        |    |1        |119 |
|8 |      MERGE JOIN             |    |1        |79  |
|9 |       SORT                  |    |1        |40  |
|10|        TABLE SCAN           |t2  |1        |39  |
|11|       SORT                  |    |1        |39  |
|12|        TABLE SCAN           |t3  |1        |39  |
|13|      SORT                   |    |1        |39  |
|14|       TABLE SCAN            |t4  |1        |39  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1]), filter([t2.c1 > 1]), 
      access([t2.c1]), partitions(p0)
  11 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  12 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0)
  13 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  14 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |8        |229 |
|1 | SUBPLAN FILTER          |    |8        |221 |
|2 |  TABLE SCAN             |t1  |8        |38  |
|3 |  LIMIT                  |    |1        |183 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |183 |
|5 |    TABLE SCAN           |t1  |2        |36  |
|6 |    MATERIAL             |    |1        |146 |
|7 |     HASH OUTER JOIN     |    |1        |146 |
|8 |      TABLE SCAN         |t2  |9        |38  |
|9 |      HASH OUTER JOIN    |    |8        |91  |
|10|       TABLE SCAN        |t3  |8        |38  |
|11|       TABLE SCAN        |t4  |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t3.c1 > 1]), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t3.c1]), filter(nil)
  7 - output([t3.c1]), filter([t3.c1 > 1]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1 limit 1);
Query Plan
======================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST|
------------------------------------------------------
|0 |DELETE                       |    |1        |195 |
|1 | SUBPLAN FILTER              |    |1        |194 |
|2 |  TABLE SCAN                 |t1  |1        |39  |
|3 |  LIMIT                      |    |1        |156 |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |1        |156 |
|5 |    TABLE SCAN               |t1  |2        |36  |
|6 |    MATERIAL                 |    |1        |119 |
|7 |     MERGE OUTER JOIN        |    |1        |119 |
|8 |      MERGE JOIN             |    |1        |79  |
|9 |       SORT                  |    |1        |40  |
|10|        TABLE SCAN           |t2  |1        |39  |
|11|       SORT                  |    |1        |39  |
|12|        TABLE SCAN           |t3  |1        |39  |
|13|      SORT                   |    |1        |39  |
|14|       TABLE SCAN            |t4  |1        |39  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1]), filter([t2.c1 > 1]), 
      access([t2.c1]), partitions(p0)
  11 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  12 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0)
  13 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  14 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |222 |
|1 | SUBPLAN FILTER          |    |1        |221 |
|2 |  TABLE SCAN             |t1  |1        |39  |
|3 |  LIMIT                  |    |1        |183 |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |183 |
|5 |    TABLE SCAN           |t1  |2        |36  |
|6 |    MATERIAL             |    |1        |146 |
|7 |     HASH OUTER JOIN     |    |1        |146 |
|8 |      TABLE SCAN         |t2  |9        |38  |
|9 |      HASH OUTER JOIN    |    |8        |91  |
|10|       TABLE SCAN        |t3  |8        |38  |
|11|       TABLE SCAN        |t4  |8        |38  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([t3.c1 > 1]), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t3.c1]), filter(nil)
  7 - output([t3.c1]), filter([t3.c1 > 1]), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join (t2 left join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t3.c1) on t3.c1>1 where t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |MERGE OUTER JOIN |    |8        |203 |
|1 | MERGE OUTER JOIN|    |8        |150 |
|2 |  SORT           |    |8        |46  |
|3 |   TABLE SCAN    |t1  |8        |38  |
|4 |  MERGE JOIN     |    |8        |98  |
|5 |   SORT          |    |8        |46  |
|6 |    TABLE SCAN   |t4  |8        |38  |
|7 |   SORT          |    |8        |46  |
|8 |    TABLE SCAN   |t3  |8        |38  |
|9 | SORT            |    |9        |47  |
|10|  TABLE SCAN     |t2  |9        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  5 - output([t4.c1], [t4.c2]), filter(nil), sort_keys([t4.c1, ASC])
  6 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  7 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  8 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  9 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 | NULL | NULL | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
|    5 |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |8        |204 |
|1 | TABLE SCAN          |t2  |9        |38  |
|2 | HASH OUTER JOIN     |    |8        |148 |
|3 |  TABLE SCAN         |t1  |8        |38  |
|4 |  HASH OUTER JOIN    |    |8        |93  |
|5 |   TABLE SCAN        |t3  |8        |38  |
|6 |   TABLE SCAN        |t4  |8        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  6 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 | NULL | NULL | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
|    5 |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |8        |205 |
|1 | SUBPLAN SCAN      |VIEW1|8        |204 |
|2 |  MERGE OUTER JOIN |     |8        |203 |
|3 |   MERGE OUTER JOIN|     |8        |150 |
|4 |    SORT           |     |8        |46  |
|5 |     TABLE SCAN    |t1   |8        |38  |
|6 |    MERGE JOIN     |     |8        |98  |
|7 |     SORT          |     |8        |46  |
|8 |      TABLE SCAN   |t4   |8        |38  |
|9 |     SORT          |     |8        |46  |
|10|      TABLE SCAN   |t3   |8        |38  |
|11|   SORT            |     |9        |47  |
|12|    TABLE SCAN     |t2   |9        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t4.c1], [t4.c2]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  9 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  10 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  11 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  12 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1);

rollback;
EXPLAIN insert into t7_temp (select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |8        |207 |
|1 | SUBPLAN SCAN          |VIEW1|8        |205 |
|2 |  HASH RIGHT OUTER JOIN|     |8        |204 |
|3 |   TABLE SCAN          |t2   |9        |38  |
|4 |   HASH OUTER JOIN     |     |8        |148 |
|5 |    TABLE SCAN         |t1   |8        |38  |
|6 |    HASH OUTER JOIN    |     |8        |93  |
|7 |     TABLE SCAN        |t3   |8        |38  |
|8 |     TABLE SCAN        |t4   |8        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  8 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

insert into t7_temp (select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE             |     |8        |220 |
|1 | SUBPLAN FILTER    |     |8        |212 |
|2 |  TABLE SCAN       |t1   |8        |38  |
|3 |  LIMIT            |     |1        |174 |
|4 |   HASH OUTER JOIN |     |1        |174 |
|5 |    HASH OUTER JOIN|     |1        |131 |
|6 |     SUBPLAN SCAN  |VIEW1|1        |37  |
|7 |      TABLE SCAN   |t1   |1        |36  |
|8 |     HASH JOIN     |     |8        |91  |
|9 |      TABLE SCAN   |t3   |8        |38  |
|10|      TABLE SCAN   |t4   |8        |38  |
|11|    TABLE SCAN     |t2   |9        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t2.c1]), other_conds(nil)
  5 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t4.c1]), other_conds(nil)
  6 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |8        |225 |
|1 | SUBPLAN FILTER         |    |8        |217 |
|2 |  TABLE SCAN            |t1  |8        |38  |
|3 |  LIMIT                 |    |1        |179 |
|4 |   HASH RIGHT OUTER JOIN|    |1        |178 |
|5 |    TABLE SCAN          |t2  |9        |38  |
|6 |    HASH OUTER JOIN     |    |1        |130 |
|7 |     TABLE SCAN         |t1  |8        |38  |
|8 |     HASH OUTER JOIN    |    |1        |83  |
|9 |      TABLE SCAN        |t3  |8        |38  |
|10|      TABLE SCAN        |t4  |1        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |DELETE             |     |1        |213 |
|1 | SUBPLAN FILTER    |     |1        |212 |
|2 |  TABLE SCAN       |t1   |1        |39  |
|3 |  LIMIT            |     |1        |174 |
|4 |   HASH OUTER JOIN |     |1        |174 |
|5 |    HASH OUTER JOIN|     |1        |131 |
|6 |     SUBPLAN SCAN  |VIEW1|1        |37  |
|7 |      TABLE SCAN   |t1   |1        |36  |
|8 |     HASH JOIN     |     |8        |91  |
|9 |      TABLE SCAN   |t3   |8        |38  |
|10|      TABLE SCAN   |t4   |8        |38  |
|11|    TABLE SCAN     |t2   |9        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t2.c1]), other_conds(nil)
  5 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t4.c1]), other_conds(nil)
  6 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |218 |
|1 | SUBPLAN FILTER         |    |1        |217 |
|2 |  TABLE SCAN            |t1  |1        |39  |
|3 |  LIMIT                 |    |1        |179 |
|4 |   HASH RIGHT OUTER JOIN|    |1        |178 |
|5 |    TABLE SCAN          |t2  |9        |38  |
|6 |    HASH OUTER JOIN     |    |1        |130 |
|7 |     TABLE SCAN         |t1  |8        |38  |
|8 |     HASH OUTER JOIN    |    |1        |83  |
|9 |      TABLE SCAN        |t3  |8        |38  |
|10|      TABLE SCAN        |t4  |1        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1) left join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |8        |204 |
|1 | TABLE SCAN          |t2  |9        |38  |
|2 | HASH FULL OUTER JOIN|    |8        |148 |
|3 |  TABLE SCAN         |t1  |8        |38  |
|4 |  HASH OUTER JOIN    |    |8        |93  |
|5 |   TABLE SCAN        |t3  |8        |38  |
|6 |   TABLE SCAN        |t4  |8        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  6 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

select * from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 | NULL | NULL | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
|    5 |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL | NULL | NULL | NULL |    5 |    5 | NULL | NULL |
| NULL | NULL | NULL | NULL |    7 |    7 | NULL | NULL |
| NULL | NULL | NULL | NULL |    7 |    7 | NULL | NULL |
| NULL | NULL | NULL | NULL | NULL |    3 | NULL | NULL |
| NULL | NULL | NULL | NULL | NULL |    7 | NULL | NULL |
+------+------+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT OUTER JOIN|    |8        |204 |
|1 | TABLE SCAN          |t2  |9        |38  |
|2 | HASH FULL OUTER JOIN|    |8        |148 |
|3 |  TABLE SCAN         |t1  |8        |38  |
|4 |  HASH OUTER JOIN    |    |8        |93  |
|5 |   TABLE SCAN        |t3  |8        |38  |
|6 |   TABLE SCAN        |t4  |8        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  6 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 | NULL | NULL | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
|    5 |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL | NULL | NULL | NULL |    5 |    5 | NULL | NULL |
| NULL | NULL | NULL | NULL |    7 |    7 | NULL | NULL |
| NULL | NULL | NULL | NULL |    7 |    7 | NULL | NULL |
| NULL | NULL | NULL | NULL | NULL |    3 | NULL | NULL |
| NULL | NULL | NULL | NULL | NULL |    7 | NULL | NULL |
+------+------+------+------+------+------+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |8        |207 |
|1 | SUBPLAN SCAN          |VIEW1|8        |205 |
|2 |  HASH RIGHT OUTER JOIN|     |8        |204 |
|3 |   TABLE SCAN          |t2   |9        |38  |
|4 |   HASH FULL OUTER JOIN|     |8        |148 |
|5 |    TABLE SCAN         |t1   |8        |38  |
|6 |    HASH OUTER JOIN    |     |8        |93  |
|7 |     TABLE SCAN        |t3   |8        |38  |
|8 |     TABLE SCAN        |t4   |8        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  8 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1);

rollback;
EXPLAIN insert into t7_temp (select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |8        |207 |
|1 | SUBPLAN SCAN          |VIEW1|8        |205 |
|2 |  HASH RIGHT OUTER JOIN|     |8        |204 |
|3 |   TABLE SCAN          |t2   |9        |38  |
|4 |   HASH FULL OUTER JOIN|     |8        |148 |
|5 |    TABLE SCAN         |t1   |8        |38  |
|6 |    HASH OUTER JOIN    |     |8        |93  |
|7 |     TABLE SCAN        |t3   |8        |38  |
|8 |     TABLE SCAN        |t4   |8        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  8 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

insert into t7_temp (select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |8        |225 |
|1 | SUBPLAN FILTER         |    |8        |217 |
|2 |  TABLE SCAN            |t1  |8        |38  |
|3 |  LIMIT                 |    |1        |179 |
|4 |   HASH RIGHT OUTER JOIN|    |1        |178 |
|5 |    TABLE SCAN          |t2  |9        |38  |
|6 |    HASH FULL OUTER JOIN|    |1        |130 |
|7 |     TABLE SCAN         |t1  |8        |38  |
|8 |     HASH OUTER JOIN    |    |1        |83  |
|9 |      TABLE SCAN        |t3  |8        |38  |
|10|      TABLE SCAN        |t4  |1        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                  |    |8        |225 |
|1 | SUBPLAN FILTER         |    |8        |217 |
|2 |  TABLE SCAN            |t1  |8        |38  |
|3 |  LIMIT                 |    |1        |179 |
|4 |   HASH RIGHT OUTER JOIN|    |1        |178 |
|5 |    TABLE SCAN          |t2  |9        |38  |
|6 |    HASH FULL OUTER JOIN|    |1        |130 |
|7 |     TABLE SCAN         |t1  |8        |38  |
|8 |     HASH OUTER JOIN    |    |1        |83  |
|9 |      TABLE SCAN        |t3  |8        |38  |
|10|      TABLE SCAN        |t4  |1        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |218 |
|1 | SUBPLAN FILTER         |    |1        |217 |
|2 |  TABLE SCAN            |t1  |1        |39  |
|3 |  LIMIT                 |    |1        |179 |
|4 |   HASH RIGHT OUTER JOIN|    |1        |178 |
|5 |    TABLE SCAN          |t2  |9        |38  |
|6 |    HASH FULL OUTER JOIN|    |1        |130 |
|7 |     TABLE SCAN         |t1  |8        |38  |
|8 |     HASH OUTER JOIN    |    |1        |83  |
|9 |      TABLE SCAN        |t3  |8        |38  |
|10|      TABLE SCAN        |t4  |1        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
Query Plan
=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                  |    |1        |218 |
|1 | SUBPLAN FILTER         |    |1        |217 |
|2 |  TABLE SCAN            |t1  |1        |39  |
|3 |  LIMIT                 |    |1        |179 |
|4 |   HASH RIGHT OUTER JOIN|    |1        |178 |
|5 |    TABLE SCAN          |t2  |9        |38  |
|6 |    HASH FULL OUTER JOIN|    |1        |130 |
|7 |     TABLE SCAN         |t1  |8        |38  |
|8 |     HASH OUTER JOIN    |    |1        |83  |
|9 |      TABLE SCAN        |t3  |8        |38  |
|10|      TABLE SCAN        |t4  |1        |36  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1) full join (t3 left join t4 on t3.c1=t4.c1) on t1.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1;
Query Plan
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH JOIN    |    |8        |202 |
|1 | TABLE SCAN  |t3  |8        |38  |
|2 | HASH JOIN   |    |8        |148 |
|3 |  TABLE SCAN |t4  |8        |38  |
|4 |  HASH JOIN  |    |8        |93  |
|5 |   TABLE SCAN|t1  |8        |38  |
|6 |   TABLE SCAN|t2  |9        |38  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  1 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t2.c1 = t4.c1]), other_conds(nil)
  3 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
+------+------+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |HASH JOIN       |    |8        |206 |
|1 | HASH OUTER JOIN|    |8        |93  |
|2 |  TABLE SCAN    |t1  |8        |38  |
|3 |  TABLE SCAN    |t2  |9        |38  |
|4 | HASH OUTER JOIN|    |8        |93  |
|5 |  TABLE SCAN    |t3  |8        |38  |
|6 |  TABLE SCAN    |t4  |8        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t2.c1 = t4.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  6 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |
+------+------+------+------+------+------+------+------+
EXPLAIN insert into t7_temp (select * from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1);
Query Plan
=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |INSERT         |     |8        |204 |
|1 | SUBPLAN SCAN  |VIEW1|8        |203 |
|2 |  HASH JOIN    |     |8        |202 |
|3 |   TABLE SCAN  |t3   |8        |38  |
|4 |   HASH JOIN   |     |8        |148 |
|5 |    TABLE SCAN |t4   |8        |38  |
|6 |    HASH JOIN  |     |8        |93  |
|7 |     TABLE SCAN|t1   |8        |38  |
|8 |     TABLE SCAN|t2   |9        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  3 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t2.c1 = t4.c1]), other_conds(nil)
  5 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t7_temp (select * from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1);

rollback;
EXPLAIN insert into t7_temp (select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |8        |208 |
|1 | SUBPLAN SCAN     |VIEW1|8        |207 |
|2 |  HASH JOIN       |     |8        |206 |
|3 |   HASH OUTER JOIN|     |8        |93  |
|4 |    TABLE SCAN    |t1   |8        |38  |
|5 |    TABLE SCAN    |t2   |9        |38  |
|6 |   HASH OUTER JOIN|     |8        |93  |
|7 |    TABLE SCAN    |t3   |8        |38  |
|8 |    TABLE SCAN    |t4   |8        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t7_temp: ({t7_temp: (t7_temp.__pk_increment, t7_temp.a, t7_temp.b, t7_temp.c, t7_temp.d, t7_temp.f, t7_temp.g, t7_temp.i, t7_temp.j)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t2.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  8 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

insert into t7_temp (select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1 limit 1);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |UPDATE          |    |8        |224 |
|1 | SUBPLAN FILTER |    |8        |216 |
|2 |  TABLE SCAN    |t1  |8        |38  |
|3 |  LIMIT         |    |1        |177 |
|4 |   HASH JOIN    |    |1        |177 |
|5 |    TABLE SCAN  |t3  |8        |38  |
|6 |    HASH JOIN   |    |1        |130 |
|7 |     TABLE SCAN |t4  |8        |38  |
|8 |     HASH JOIN  |    |2        |84  |
|9 |      TABLE SCAN|t1  |8        |38  |
|10|      TABLE SCAN|t2  |2        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t1.c1], [t4.c1]), filter(nil), 
      equal_conds([t2.c1 = t4.c1]), other_conds(nil)
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE             |    |8        |232 |
|1 | SUBPLAN FILTER    |    |8        |224 |
|2 |  TABLE SCAN       |t1  |8        |38  |
|3 |  LIMIT            |    |1        |186 |
|4 |   HASH JOIN       |    |1        |186 |
|5 |    HASH OUTER JOIN|    |8        |92  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |9        |38  |
|8 |    HASH OUTER JOIN|    |2        |83  |
|9 |     TABLE SCAN    |t3  |8        |38  |
|10|     TABLE SCAN    |t4  |2        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1 limit 1);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |DELETE          |    |1        |217 |
|1 | SUBPLAN FILTER |    |1        |216 |
|2 |  TABLE SCAN    |t1  |1        |39  |
|3 |  LIMIT         |    |1        |177 |
|4 |   HASH JOIN    |    |1        |177 |
|5 |    TABLE SCAN  |t3  |8        |38  |
|6 |    HASH JOIN   |    |1        |130 |
|7 |     TABLE SCAN |t4  |8        |38  |
|8 |     HASH JOIN  |    |2        |84  |
|9 |      TABLE SCAN|t1  |8        |38  |
|10|      TABLE SCAN|t2  |2        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t1.c1], [t4.c1]), filter(nil), 
      equal_conds([t2.c1 = t4.c1]), other_conds(nil)
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |DELETE             |    |1        |225 |
|1 | SUBPLAN FILTER    |    |1        |224 |
|2 |  TABLE SCAN       |t1  |1        |39  |
|3 |  LIMIT            |    |1        |186 |
|4 |   HASH JOIN       |    |1        |186 |
|5 |    HASH OUTER JOIN|    |8        |92  |
|6 |     TABLE SCAN    |t1  |8        |38  |
|7 |     TABLE SCAN    |t2  |9        |38  |
|8 |    HASH OUTER JOIN|    |2        |83  |
|9 |     TABLE SCAN    |t3  |8        |38  |
|10|     TABLE SCAN    |t4  |2        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t4.c1]), other_conds(nil)
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1) inner join (t3 left join t4 on t3.c1=t4.c1) on t2.c1=t4.c1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |HASH RIGHT OUTER JOIN  |    |8        |283 |
|1 | TABLE SCAN            |t5  |5        |37  |
|2 | NESTED-LOOP OUTER JOIN|    |8        |234 |
|3 |  HASH RIGHT OUTER JOIN|    |8        |148 |
|4 |   TABLE SCAN          |t3  |8        |38  |
|5 |   HASH OUTER JOIN     |    |8        |93  |
|6 |    TABLE SCAN         |t1  |8        |38  |
|7 |    TABLE SCAN         |t2  |9        |38  |
|8 |  MATERIAL             |    |8        |41  |
|9 |   TABLE SCAN          |t4  |8        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t4.c1 = t5.c1]), other_conds(nil)
  1 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds([t1.c1 > 1], [t2.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t4.c1], [t4.c2]), filter(nil)
  9 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

select * from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1;
+------+------+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 | NULL | NULL | NULL | NULL |
|    1 |    1 |    1 |    1 |    1 |    1 | NULL | NULL | NULL | NULL |
|    2 |    2 |    2 |    2 | NULL | NULL | NULL | NULL | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |    3 |    3 |    2 |    2 |    2 |    2 |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |    3 |    3 |
|    3 |    2 |    3 |    3 |    3 |    3 |    4 |    4 |    4 |    4 |
|    3 |    2 |    3 |    3 |    3 |    3 |    8 |    8 | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |    8 |    8 | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 | NULL |    4 | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 | NULL |    8 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 |    1 |    1 |    1 |    1 |
|    4 |    2 |    4 |    4 |    4 |    4 |    2 |    2 |    2 |    2 |
|    4 |    2 |    4 |    4 |    4 |    4 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |    4 |    4 |
|    4 |    2 |    4 |    4 |    4 |    4 |    8 |    8 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 |    8 |    8 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 | NULL |    4 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 | NULL |    8 | NULL | NULL |
|    5 |    5 | NULL | NULL |    5 |    5 | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |HASH RIGHT OUTER JOIN  |    |8        |283 |
|1 | TABLE SCAN            |t5  |5        |37  |
|2 | NESTED-LOOP OUTER JOIN|    |8        |234 |
|3 |  HASH RIGHT OUTER JOIN|    |8        |148 |
|4 |   TABLE SCAN          |t3  |8        |38  |
|5 |   HASH OUTER JOIN     |    |8        |93  |
|6 |    TABLE SCAN         |t1  |8        |38  |
|7 |    TABLE SCAN         |t2  |9        |38  |
|8 |  MATERIAL             |    |8        |41  |
|9 |   TABLE SCAN          |t4  |8        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t4.c1 = t5.c1]), other_conds(nil)
  1 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds([t1.c1 > 1], [t2.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t4.c1], [t4.c2]), filter(nil)
  9 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1;
+------+------+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 | NULL | NULL | NULL | NULL |
|    1 |    1 |    1 |    1 |    1 |    1 | NULL | NULL | NULL | NULL |
|    2 |    2 |    2 |    2 | NULL | NULL | NULL | NULL | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |    3 |    3 |    2 |    2 |    2 |    2 |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |    3 |    3 |
|    3 |    2 |    3 |    3 |    3 |    3 |    4 |    4 |    4 |    4 |
|    3 |    2 |    3 |    3 |    3 |    3 |    8 |    8 | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |    8 |    8 | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 | NULL |    4 | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 | NULL |    8 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 |    1 |    1 |    1 |    1 |
|    4 |    2 |    4 |    4 |    4 |    4 |    2 |    2 |    2 |    2 |
|    4 |    2 |    4 |    4 |    4 |    4 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |    4 |    4 |
|    4 |    2 |    4 |    4 |    4 |    4 |    8 |    8 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 |    8 |    8 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 | NULL |    4 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 | NULL |    8 | NULL | NULL |
|    5 |    5 | NULL | NULL |    5 |    5 | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+------+------+------+------+
EXPLAIN insert into t15_temp (select * from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |8        |285 |
|1 | SUBPLAN SCAN            |VIEW1|8        |284 |
|2 |  HASH RIGHT OUTER JOIN  |     |8        |283 |
|3 |   TABLE SCAN            |t5   |5        |37  |
|4 |   NESTED-LOOP OUTER JOIN|     |8        |234 |
|5 |    HASH RIGHT OUTER JOIN|     |8        |148 |
|6 |     TABLE SCAN          |t3   |8        |38  |
|7 |     HASH OUTER JOIN     |     |8        |93  |
|8 |      TABLE SCAN         |t1   |8        |38  |
|9 |      TABLE SCAN         |t2   |9        |38  |
|10|    MATERIAL             |     |8        |41  |
|11|     TABLE SCAN          |t4   |8        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t15_temp: ({t15_temp: (t15_temp.__pk_increment, t15_temp.a, t15_temp.b, t15_temp.c, t15_temp.d, t15_temp.f, t15_temp.g, t15_temp.i, t15_temp.j, t15_temp.l, t15_temp.m)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t4.c1 = t5.c1]), other_conds(nil)
  3 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds([t1.c1 > 1], [t2.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  7 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  10 - output([t4.c1], [t4.c2]), filter(nil)
  11 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

insert into t15_temp (select * from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1);

rollback;
EXPLAIN insert into t15_temp (select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |8        |285 |
|1 | SUBPLAN SCAN            |VIEW1|8        |284 |
|2 |  HASH RIGHT OUTER JOIN  |     |8        |283 |
|3 |   TABLE SCAN            |t5   |5        |37  |
|4 |   NESTED-LOOP OUTER JOIN|     |8        |234 |
|5 |    HASH RIGHT OUTER JOIN|     |8        |148 |
|6 |     TABLE SCAN          |t3   |8        |38  |
|7 |     HASH OUTER JOIN     |     |8        |93  |
|8 |      TABLE SCAN         |t1   |8        |38  |
|9 |      TABLE SCAN         |t2   |9        |38  |
|10|    MATERIAL             |     |8        |41  |
|11|     TABLE SCAN          |t4   |8        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t15_temp: ({t15_temp: (t15_temp.__pk_increment, t15_temp.a, t15_temp.b, t15_temp.c, t15_temp.d, t15_temp.f, t15_temp.g, t15_temp.i, t15_temp.j, t15_temp.l, t15_temp.m)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t4.c1 = t5.c1]), other_conds(nil)
  3 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds([t1.c1 > 1], [t2.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  7 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  10 - output([t4.c1], [t4.c2]), filter(nil)
  11 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

insert into t15_temp (select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE                    |     |8        |252 |
|1 | SUBPLAN FILTER           |     |8        |244 |
|2 |  TABLE SCAN              |t1   |8        |38  |
|3 |  LIMIT                   |     |1        |205 |
|4 |   HASH OUTER JOIN        |     |1        |205 |
|5 |    NESTED-LOOP OUTER JOIN|     |1        |165 |
|6 |     HASH OUTER JOIN      |     |1        |120 |
|7 |      HASH OUTER JOIN     |     |1        |78  |
|8 |       SUBPLAN SCAN       |VIEW1|1        |37  |
|9 |        TABLE SCAN        |t1   |1        |36  |
|10|       TABLE SCAN         |t3   |8        |38  |
|11|      TABLE SCAN          |t2   |9        |38  |
|12|     MATERIAL             |     |8        |39  |
|13|      TABLE SCAN          |t4   |8        |38  |
|14|    TABLE SCAN            |t5   |5        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t5.c1]), other_conds(nil)
  5 - output([VIEW1.t1.c1], [t4.c1]), filter(nil), 
      conds([VIEW1.t1.c1 > 1], [t2.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  6 - output([VIEW1.t1.c1], [t2.c1], [t3.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t2.c1]), other_conds(nil)
  7 - output([VIEW1.t1.c1], [t3.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  8 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  14 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |8        |264 |
|1 | SUBPLAN FILTER           |    |8        |256 |
|2 |  TABLE SCAN              |t1  |8        |38  |
|3 |  LIMIT                   |    |1        |218 |
|4 |   HASH RIGHT OUTER JOIN  |    |1        |217 |
|5 |    TABLE SCAN            |t5  |5        |37  |
|6 |    NESTED-LOOP OUTER JOIN|    |1        |175 |
|7 |     HASH RIGHT OUTER JOIN|    |1        |130 |
|8 |      TABLE SCAN          |t3  |8        |38  |
|9 |      HASH OUTER JOIN     |    |1        |83  |
|10|       TABLE SCAN         |t1  |8        |38  |
|11|       TABLE SCAN         |t2  |2        |36  |
|12|     MATERIAL             |    |8        |39  |
|13|      TABLE SCAN          |t4  |8        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t5.c1]), other_conds(nil)
  5 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  6 - output([t1.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 > 1], [t2.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  7 - output([t1.c1], [t2.c1], [t3.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE                    |     |1        |244 |
|1 | SUBPLAN FILTER           |     |1        |243 |
|2 |  TABLE SCAN              |t1   |1        |39  |
|3 |  LIMIT                   |     |1        |205 |
|4 |   HASH OUTER JOIN        |     |1        |205 |
|5 |    NESTED-LOOP OUTER JOIN|     |1        |165 |
|6 |     HASH OUTER JOIN      |     |1        |120 |
|7 |      HASH OUTER JOIN     |     |1        |78  |
|8 |       SUBPLAN SCAN       |VIEW1|1        |37  |
|9 |        TABLE SCAN        |t1   |1        |36  |
|10|       TABLE SCAN         |t3   |8        |38  |
|11|      TABLE SCAN          |t2   |9        |38  |
|12|     MATERIAL             |     |8        |39  |
|13|      TABLE SCAN          |t4   |8        |38  |
|14|    TABLE SCAN            |t5   |5        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t5.c1]), other_conds(nil)
  5 - output([VIEW1.t1.c1], [t4.c1]), filter(nil), 
      conds([VIEW1.t1.c1 > 1], [t2.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  6 - output([VIEW1.t1.c1], [t2.c1], [t3.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t2.c1]), other_conds(nil)
  7 - output([VIEW1.t1.c1], [t3.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  8 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  14 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |257 |
|1 | SUBPLAN FILTER           |    |1        |256 |
|2 |  TABLE SCAN              |t1  |1        |39  |
|3 |  LIMIT                   |    |1        |218 |
|4 |   HASH RIGHT OUTER JOIN  |    |1        |217 |
|5 |    TABLE SCAN            |t5  |5        |37  |
|6 |    NESTED-LOOP OUTER JOIN|    |1        |175 |
|7 |     HASH RIGHT OUTER JOIN|    |1        |130 |
|8 |      TABLE SCAN          |t3  |8        |38  |
|9 |      HASH OUTER JOIN     |    |1        |83  |
|10|       TABLE SCAN         |t1  |8        |38  |
|11|       TABLE SCAN         |t2  |2        |36  |
|12|     MATERIAL             |    |8        |39  |
|13|      TABLE SCAN          |t4  |8        |38  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t5.c1]), other_conds(nil)
  5 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  6 - output([t1.c1], [t4.c1]), filter(nil), 
      conds([t1.c1 > 1], [t2.c1 > 1], [t3.c1 > 1]), nl_params_(nil)
  7 - output([t1.c1], [t2.c1], [t3.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  12 - output([t4.c1]), filter(nil)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) left join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1;
Query Plan
==========================================================
|ID|OPERATOR                         |NAME|EST. ROWS|COST|
----------------------------------------------------------
|0 |HASH RIGHT OUTER JOIN            |    |8        |210 |
|1 | TABLE SCAN                      |t5  |5        |37  |
|2 | NESTED-LOOP OUTER JOIN CARTESIAN|    |8        |161 |
|3 |  TABLE SCAN                     |t4  |8        |38  |
|4 |  MATERIAL                       |    |1        |121 |
|5 |   MERGE JOIN                    |    |1        |120 |
|6 |    MERGE JOIN                   |    |1        |80  |
|7 |     SORT                        |    |1        |40  |
|8 |      TABLE SCAN                 |t1  |1        |39  |
|9 |     SORT                        |    |1        |40  |
|10|      TABLE SCAN                 |t3  |1        |39  |
|11|    SORT                         |    |1        |40  |
|12|     TABLE SCAN                  |t2  |1        |40  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t4.c1 = t5.c1]), other_conds(nil)
  1 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  8 - output([t1.c1], [t1.c2]), filter([t1.c1 > 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  10 - output([t3.c1], [t3.c2]), filter([t3.c1 > 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  11 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  12 - output([t2.c1], [t2.c2]), filter([t2.c1 > 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1;
+------+------+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+------+------+
|    3 |    2 |    3 |    3 |    3 |    3 |    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |    3 |    3 |    2 |    2 |    2 |    2 |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |    3 |    3 |
|    3 |    2 |    3 |    3 |    3 |    3 |    4 |    4 |    4 |    4 |
|    3 |    2 |    3 |    3 |    3 |    3 |    8 |    8 | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |    8 |    8 | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 | NULL |    4 | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 | NULL |    8 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 |    1 |    1 |    1 |    1 |
|    4 |    2 |    4 |    4 |    4 |    4 |    2 |    2 |    2 |    2 |
|    4 |    2 |    4 |    4 |    4 |    4 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |    4 |    4 |
|    4 |    2 |    4 |    4 |    4 |    4 |    8 |    8 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 |    8 |    8 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 | NULL |    4 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 | NULL |    8 | NULL | NULL |
+------+------+------+------+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1;
Query Plan
==========================================================
|ID|OPERATOR                         |NAME|EST. ROWS|COST|
----------------------------------------------------------
|0 |HASH RIGHT OUTER JOIN            |    |8        |208 |
|1 | TABLE SCAN                      |t5  |5        |37  |
|2 | NESTED-LOOP OUTER JOIN CARTESIAN|    |8        |159 |
|3 |  TABLE SCAN                     |t4  |8        |38  |
|4 |  MATERIAL                       |    |1        |121 |
|5 |   HASH OUTER JOIN               |    |1        |121 |
|6 |    HASH OUTER JOIN              |    |1        |81  |
|7 |     TABLE SCAN                  |t1  |1        |39  |
|8 |     TABLE SCAN                  |t2  |9        |38  |
|9 |    TABLE SCAN                   |t3  |8        |38  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t4.c1 = t5.c1]), other_conds(nil)
  1 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter([t3.c1 > 1]), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([t2.c1 > 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter([t1.c1 > 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  9 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)

select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1;
+------+------+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+------+------+
|    3 |    2 |    3 |    3 |    3 |    3 |    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |    3 |    3 |    2 |    2 |    2 |    2 |
|    3 |    2 |    3 |    3 |    3 |    3 |    3 |    3 |    3 |    3 |
|    3 |    2 |    3 |    3 |    3 |    3 |    4 |    4 |    4 |    4 |
|    3 |    2 |    3 |    3 |    3 |    3 |    8 |    8 | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 |    8 |    8 | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 | NULL |    4 | NULL | NULL |
|    3 |    2 |    3 |    3 |    3 |    3 | NULL |    8 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 |    1 |    1 |    1 |    1 |
|    4 |    2 |    4 |    4 |    4 |    4 |    2 |    2 |    2 |    2 |
|    4 |    2 |    4 |    4 |    4 |    4 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |    4 |    4 |    4 |    4 |
|    4 |    2 |    4 |    4 |    4 |    4 |    8 |    8 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 |    8 |    8 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 | NULL |    4 | NULL | NULL |
|    4 |    2 |    4 |    4 |    4 |    4 | NULL |    8 | NULL | NULL |
+------+------+------+------+------+------+------+------+------+------+
EXPLAIN insert into t15_temp (select * from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1);
Query Plan
=============================================================
|ID|OPERATOR                           |NAME |EST. ROWS|COST|
-------------------------------------------------------------
|0 |INSERT                             |     |8        |212 |
|1 | SUBPLAN SCAN                      |VIEW1|8        |211 |
|2 |  HASH RIGHT OUTER JOIN            |     |8        |210 |
|3 |   TABLE SCAN                      |t5   |5        |37  |
|4 |   NESTED-LOOP OUTER JOIN CARTESIAN|     |8        |161 |
|5 |    TABLE SCAN                     |t4   |8        |38  |
|6 |    MATERIAL                       |     |1        |121 |
|7 |     MERGE JOIN                    |     |1        |120 |
|8 |      MERGE JOIN                   |     |1        |80  |
|9 |       SORT                        |     |1        |40  |
|10|        TABLE SCAN                 |t1   |1        |39  |
|11|       SORT                        |     |1        |40  |
|12|        TABLE SCAN                 |t3   |1        |39  |
|13|      SORT                         |     |1        |40  |
|14|       TABLE SCAN                  |t2   |1        |40  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t15_temp: ({t15_temp: (t15_temp.__pk_increment, t15_temp.a, t15_temp.b, t15_temp.c, t15_temp.d, t15_temp.f, t15_temp.g, t15_temp.i, t15_temp.j, t15_temp.l, t15_temp.m)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t4.c1 = t5.c1]), other_conds(nil)
  3 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  10 - output([t1.c1], [t1.c2]), filter([t1.c1 > 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  11 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  12 - output([t3.c1], [t3.c2]), filter([t3.c1 > 1]), 
      access([t3.c1], [t3.c2]), partitions(p0)
  13 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  14 - output([t2.c1], [t2.c2]), filter([t2.c1 > 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t15_temp (select * from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1);

rollback;
EXPLAIN insert into t15_temp (select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1);
Query Plan
=============================================================
|ID|OPERATOR                           |NAME |EST. ROWS|COST|
-------------------------------------------------------------
|0 |INSERT                             |     |8        |210 |
|1 | SUBPLAN SCAN                      |VIEW1|8        |209 |
|2 |  HASH RIGHT OUTER JOIN            |     |8        |208 |
|3 |   TABLE SCAN                      |t5   |5        |37  |
|4 |   NESTED-LOOP OUTER JOIN CARTESIAN|     |8        |159 |
|5 |    TABLE SCAN                     |t4   |8        |38  |
|6 |    MATERIAL                       |     |1        |121 |
|7 |     HASH OUTER JOIN               |     |1        |121 |
|8 |      HASH OUTER JOIN              |     |1        |81  |
|9 |       TABLE SCAN                  |t1   |1        |39  |
|10|       TABLE SCAN                  |t2   |9        |38  |
|11|      TABLE SCAN                   |t3   |8        |38  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t15_temp: ({t15_temp: (t15_temp.__pk_increment, t15_temp.a, t15_temp.b, t15_temp.c, t15_temp.d, t15_temp.f, t15_temp.g, t15_temp.i, t15_temp.j, t15_temp.l, t15_temp.m)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t4.c1 = t5.c1]), other_conds(nil)
  3 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  6 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t3.c1], [t3.c2]), filter([t3.c1 > 1]), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([t2.c1 > 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  9 - output([t1.c1], [t1.c2]), filter([t1.c1 > 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  11 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)

insert into t15_temp (select /*+NO_REWRITE*/* from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1);

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
Query Plan
==============================================================
|ID|OPERATOR                            |NAME |EST. ROWS|COST|
--------------------------------------------------------------
|0 |UPDATE                              |     |8        |243 |
|1 | SUBPLAN FILTER                     |     |8        |235 |
|2 |  TABLE SCAN                        |t1   |8        |38  |
|3 |  LIMIT                             |     |1        |196 |
|4 |   HASH OUTER JOIN                  |     |1        |196 |
|5 |    NESTED-LOOP OUTER JOIN CARTESIAN|     |1        |156 |
|6 |     SUBPLAN SCAN                   |VIEW1|1        |37  |
|7 |      TABLE SCAN                    |t4   |1        |36  |
|8 |     MATERIAL                       |     |1        |119 |
|9 |      MERGE JOIN                    |     |1        |119 |
|10|       MERGE JOIN                   |     |1        |79  |
|11|        SORT                        |     |1        |39  |
|12|         TABLE SCAN                 |t3   |1        |39  |
|13|        SORT                        |     |1        |39  |
|14|         TABLE SCAN                 |t1   |1        |39  |
|15|       SORT                         |     |1        |40  |
|16|        TABLE SCAN                  |t2   |1        |39  |
|17|    TABLE SCAN                      |t5   |5        |37  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([VIEW1.t4.c1 = t5.c1]), other_conds(nil)
  5 - output([t1.c1], [VIEW1.t4.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([VIEW1.t4.c1]), filter(nil), 
      access([VIEW1.t4.c1])
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  10 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  11 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  12 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0)
  13 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  14 - output([t1.c1]), filter([t1.c1 > 1]), 
      access([t1.c1]), partitions(p0)
  15 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  16 - output([t2.c1]), filter([t2.c1 > 1]), 
      access([t2.c1]), partitions(p0)
  17 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
Query Plan
=============================================================
|ID|OPERATOR                            |NAME|EST. ROWS|COST|
-------------------------------------------------------------
|0 |UPDATE                              |    |8        |246 |
|1 | SUBPLAN FILTER                     |    |8        |238 |
|2 |  TABLE SCAN                        |t1  |8        |38  |
|3 |  LIMIT                             |    |1        |200 |
|4 |   HASH RIGHT OUTER JOIN            |    |1        |199 |
|5 |    TABLE SCAN                      |t5  |5        |37  |
|6 |    NESTED-LOOP OUTER JOIN CARTESIAN|    |1        |157 |
|7 |     TABLE SCAN                     |t4  |1        |36  |
|8 |     MATERIAL                       |    |1        |121 |
|9 |      HASH OUTER JOIN               |    |1        |121 |
|10|       HASH OUTER JOIN              |    |1        |81  |
|11|        TABLE SCAN                  |t1  |1        |39  |
|12|        TABLE SCAN                  |t2  |9        |38  |
|13|       TABLE SCAN                   |t3  |8        |38  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t5.c1]), other_conds(nil)
  5 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  6 - output([t1.c1], [t4.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter([t3.c1 > 1]), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  10 - output([t1.c1]), filter([t2.c1 > 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  11 - output([t1.c1]), filter([t1.c1 > 1]), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  13 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
Query Plan
==============================================================
|ID|OPERATOR                            |NAME |EST. ROWS|COST|
--------------------------------------------------------------
|0 |DELETE                              |     |1        |236 |
|1 | SUBPLAN FILTER                     |     |1        |235 |
|2 |  TABLE SCAN                        |t1   |1        |39  |
|3 |  LIMIT                             |     |1        |196 |
|4 |   HASH OUTER JOIN                  |     |1        |196 |
|5 |    NESTED-LOOP OUTER JOIN CARTESIAN|     |1        |156 |
|6 |     SUBPLAN SCAN                   |VIEW1|1        |37  |
|7 |      TABLE SCAN                    |t4   |1        |36  |
|8 |     MATERIAL                       |     |1        |119 |
|9 |      MERGE JOIN                    |     |1        |119 |
|10|       MERGE JOIN                   |     |1        |79  |
|11|        SORT                        |     |1        |39  |
|12|         TABLE SCAN                 |t3   |1        |39  |
|13|        SORT                        |     |1        |39  |
|14|         TABLE SCAN                 |t1   |1        |39  |
|15|       SORT                         |     |1        |40  |
|16|        TABLE SCAN                  |t2   |1        |39  |
|17|    TABLE SCAN                      |t5   |5        |37  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([VIEW1.t4.c1 = t5.c1]), other_conds(nil)
  5 - output([t1.c1], [VIEW1.t4.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([VIEW1.t4.c1]), filter(nil), 
      access([VIEW1.t4.c1])
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      limit(1), offset(nil)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  10 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  11 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  12 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0)
  13 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  14 - output([t1.c1]), filter([t1.c1 > 1]), 
      access([t1.c1]), partitions(p0)
  15 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  16 - output([t2.c1]), filter([t2.c1 > 1]), 
      access([t2.c1]), partitions(p0)
  17 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
Query Plan
=============================================================
|ID|OPERATOR                            |NAME|EST. ROWS|COST|
-------------------------------------------------------------
|0 |DELETE                              |    |1        |239 |
|1 | SUBPLAN FILTER                     |    |1        |238 |
|2 |  TABLE SCAN                        |t1  |1        |39  |
|3 |  LIMIT                             |    |1        |200 |
|4 |   HASH RIGHT OUTER JOIN            |    |1        |199 |
|5 |    TABLE SCAN                      |t5  |5        |37  |
|6 |    NESTED-LOOP OUTER JOIN CARTESIAN|    |1        |157 |
|7 |     TABLE SCAN                     |t4  |1        |36  |
|8 |     MATERIAL                       |    |1        |121 |
|9 |      HASH OUTER JOIN               |    |1        |121 |
|10|       HASH OUTER JOIN              |    |1        |81  |
|11|        TABLE SCAN                  |t1  |1        |39  |
|12|        TABLE SCAN                  |t2  |9        |38  |
|13|       TABLE SCAN                   |t3  |8        |38  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t5.c1]), other_conds(nil)
  5 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  6 - output([t1.c1], [t4.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter([t3.c1 > 1]), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  10 - output([t1.c1]), filter([t2.c1 > 1]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  11 - output([t1.c1]), filter([t1.c1 > 1]), 
      access([t1.c1]), partitions(p0)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  13 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from (t1 left join t2 on t1.c1=t2.c1 left join t3 on t1.c1=t3.c1) right join (t4 left join t5 on t4.c1=t5.c1) on t1.c1>1 and t2.c1>1 and t3.c1>1 limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8722813232690143 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |SUBPLAN FILTER    |     |3        |221 |
|1 | HASH OUTER JOIN  |     |5        |142 |
|2 |  TABLE SCAN      |t5   |5        |37  |
|3 |  HASH JOIN       |     |8        |93  |
|4 |   TABLE SCAN     |t1   |8        |38  |
|5 |   TABLE SCAN     |t2   |9        |38  |
|6 | LIMIT            |     |1        |79  |
|7 |  MERGE OUTER JOIN|     |1        |79  |
|8 |   SORT           |     |1        |40  |
|9 |    SUBPLAN SCAN  |VIEW1|1        |39  |
|10|     TABLE SCAN   |t3   |1        |39  |
|11|   SORT           |     |1        |39  |
|12|    TABLE SCAN    |t4   |1        |39  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  2 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([NULL]), filter(nil), limit(1), offset(nil)
  7 - output([1]), filter(nil), 
      equal_conds([VIEW1.t3.c1 = t4.c1]), other_conds(nil)
  8 - output([VIEW1.t3.c1]), filter(nil), sort_keys([VIEW1.t3.c1, ASC])
  9 - output([VIEW1.t3.c1]), filter(nil), 
      access([VIEW1.t3.c1])
  10 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0), 
      limit(1), offset(nil)
  11 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  12 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1);
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 |    2 |    2 |
|    3 |    2 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |
| NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER   |    |3        |221 |
|1 | HASH OUTER JOIN |    |5        |142 |
|2 |  TABLE SCAN     |t5  |5        |37  |
|3 |  HASH OUTER JOIN|    |8        |93  |
|4 |   TABLE SCAN    |t1  |8        |38  |
|5 |   TABLE SCAN    |t2  |9        |38  |
|6 | MERGE OUTER JOIN|    |1        |79  |
|7 |  SORT           |    |1        |39  |
|8 |   TABLE SCAN    |t3  |1        |39  |
|9 |  SORT           |    |1        |39  |
|10|   TABLE SCAN    |t4  |1        |39  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  2 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([NULL]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  8 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0)
  9 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  10 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1);
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 |    2 |    2 |
|    3 |    2 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |
| NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+
EXPLAIN insert into t5_temp (select * from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1));
Query Plan
==============================================
|ID|OPERATOR            |NAME |EST. ROWS|COST|
----------------------------------------------
|0 |INSERT              |     |3        |222 |
|1 | SUBPLAN SCAN       |VIEW1|3        |222 |
|2 |  SUBPLAN FILTER    |     |3        |221 |
|3 |   HASH OUTER JOIN  |     |5        |142 |
|4 |    TABLE SCAN      |t5   |5        |37  |
|5 |    HASH JOIN       |     |8        |93  |
|6 |     TABLE SCAN     |t1   |8        |38  |
|7 |     TABLE SCAN     |t2   |9        |38  |
|8 |   LIMIT            |     |1        |79  |
|9 |    MERGE OUTER JOIN|     |1        |79  |
|10|     SORT           |     |1        |40  |
|11|      SUBPLAN SCAN  |VIEW2|1        |39  |
|12|       TABLE SCAN   |t3   |1        |39  |
|13|     SORT           |     |1        |39  |
|14|      TABLE SCAN    |t4   |1        |39  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.f, t5_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  4 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([NULL]), filter(nil), limit(1), offset(nil)
  9 - output([1]), filter(nil), 
      equal_conds([VIEW2.t3.c1 = t4.c1]), other_conds(nil)
  10 - output([VIEW2.t3.c1]), filter(nil), sort_keys([VIEW2.t3.c1, ASC])
  11 - output([VIEW2.t3.c1]), filter(nil), 
      access([VIEW2.t3.c1])
  12 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0), 
      limit(1), offset(nil)
  13 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  14 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

insert into t5_temp (select * from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1));

rollback;
EXPLAIN insert into t5_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1));
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |INSERT             |     |3        |222 |
|1 | SUBPLAN SCAN      |VIEW1|3        |221 |
|2 |  SUBPLAN FILTER   |     |3        |221 |
|3 |   HASH OUTER JOIN |     |5        |142 |
|4 |    TABLE SCAN     |t5   |5        |37  |
|5 |    HASH OUTER JOIN|     |8        |93  |
|6 |     TABLE SCAN    |t1   |8        |38  |
|7 |     TABLE SCAN    |t2   |9        |38  |
|8 |   MERGE OUTER JOIN|     |1        |79  |
|9 |    SORT           |     |1        |39  |
|10|     TABLE SCAN    |t3   |1        |39  |
|11|    SORT           |     |1        |39  |
|12|     TABLE SCAN    |t4   |1        |39  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.f, t5_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  4 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([NULL]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  10 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  12 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

insert into t5_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |UPDATE               |     |8        |256 |
|1 | SUBPLAN FILTER      |     |8        |248 |
|2 |  TABLE SCAN         |t1   |8        |38  |
|3 |  LIMIT              |     |1        |209 |
|4 |   SUBPLAN FILTER    |     |1        |209 |
|5 |    HASH OUTER JOIN  |     |2        |130 |
|6 |     TABLE SCAN      |t5   |5        |37  |
|7 |     HASH JOIN       |     |4        |86  |
|8 |      TABLE SCAN     |t1   |8        |38  |
|9 |      TABLE SCAN     |t2   |4        |37  |
|10|    LIMIT            |     |1        |79  |
|11|     MERGE OUTER JOIN|     |1        |79  |
|12|      SORT           |     |1        |40  |
|13|       SUBPLAN SCAN  |VIEW1|1        |39  |
|14|        TABLE SCAN   |t3   |1        |39  |
|15|      SORT           |     |1        |39  |
|16|       TABLE SCAN    |t4   |1        |39  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  6 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  7 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([NULL]), filter(nil), limit(1), offset(nil)
  11 - output([1]), filter(nil), 
      equal_conds([VIEW1.t3.c1 = t4.c1]), other_conds(nil)
  12 - output([VIEW1.t3.c1]), filter(nil), sort_keys([VIEW1.t3.c1, ASC])
  13 - output([VIEW1.t3.c1]), filter(nil), 
      access([VIEW1.t3.c1])
  14 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0), 
      limit(1), offset(nil)
  15 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  16 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |UPDATE              |    |8        |256 |
|1 | SUBPLAN FILTER     |    |8        |248 |
|2 |  TABLE SCAN        |t1  |8        |38  |
|3 |  LIMIT             |    |1        |209 |
|4 |   SUBPLAN FILTER   |    |1        |209 |
|5 |    HASH OUTER JOIN |    |2        |130 |
|6 |     TABLE SCAN     |t5  |5        |37  |
|7 |     HASH OUTER JOIN|    |4        |86  |
|8 |      TABLE SCAN    |t1  |8        |38  |
|9 |      TABLE SCAN    |t2  |4        |37  |
|10|    MERGE OUTER JOIN|    |1        |79  |
|11|     SORT           |    |1        |39  |
|12|      TABLE SCAN    |t3  |1        |39  |
|13|     SORT           |    |1        |39  |
|14|      TABLE SCAN    |t4  |1        |39  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  6 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  7 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([NULL]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  11 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  12 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0)
  13 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  14 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |DELETE               |     |1        |249 |
|1 | SUBPLAN FILTER      |     |1        |248 |
|2 |  TABLE SCAN         |t1   |1        |39  |
|3 |  LIMIT              |     |1        |209 |
|4 |   SUBPLAN FILTER    |     |1        |209 |
|5 |    HASH OUTER JOIN  |     |2        |130 |
|6 |     TABLE SCAN      |t5   |5        |37  |
|7 |     HASH JOIN       |     |4        |86  |
|8 |      TABLE SCAN     |t1   |8        |38  |
|9 |      TABLE SCAN     |t2   |4        |37  |
|10|    LIMIT            |     |1        |79  |
|11|     MERGE OUTER JOIN|     |1        |79  |
|12|      SORT           |     |1        |40  |
|13|       SUBPLAN SCAN  |VIEW1|1        |39  |
|14|        TABLE SCAN   |t3   |1        |39  |
|15|      SORT           |     |1        |39  |
|16|       TABLE SCAN    |t4   |1        |39  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  6 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  7 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([NULL]), filter(nil), limit(1), offset(nil)
  11 - output([1]), filter(nil), 
      equal_conds([VIEW1.t3.c1 = t4.c1]), other_conds(nil)
  12 - output([VIEW1.t3.c1]), filter(nil), sort_keys([VIEW1.t3.c1, ASC])
  13 - output([VIEW1.t3.c1]), filter(nil), 
      access([VIEW1.t3.c1])
  14 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0), 
      limit(1), offset(nil)
  15 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  16 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |DELETE              |    |1        |248 |
|1 | SUBPLAN FILTER     |    |1        |247 |
|2 |  TABLE SCAN        |t1  |1        |39  |
|3 |  LIMIT             |    |1        |209 |
|4 |   SUBPLAN FILTER   |    |1        |209 |
|5 |    HASH OUTER JOIN |    |2        |130 |
|6 |     TABLE SCAN     |t5  |5        |37  |
|7 |     HASH OUTER JOIN|    |4        |86  |
|8 |      TABLE SCAN    |t1  |8        |38  |
|9 |      TABLE SCAN    |t2  |4        |37  |
|10|    MERGE OUTER JOIN|    |1        |79  |
|11|     SORT           |    |1        |39  |
|12|      TABLE SCAN    |t3  |1        |39  |
|13|     SORT           |    |1        |39  |
|14|      TABLE SCAN    |t4  |1        |39  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  6 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  7 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([NULL]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  11 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  12 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0)
  13 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  14 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 right join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1);
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |SUBPLAN FILTER        |     |4        |222 |
|1 | HASH RIGHT OUTER JOIN|     |8        |142 |
|2 |  TABLE SCAN          |t5   |5        |37  |
|3 |  HASH OUTER JOIN     |     |8        |93  |
|4 |   TABLE SCAN         |t1   |8        |38  |
|5 |   TABLE SCAN         |t2   |9        |38  |
|6 | LIMIT                |     |1        |79  |
|7 |  MERGE OUTER JOIN    |     |1        |79  |
|8 |   SORT               |     |1        |40  |
|9 |    SUBPLAN SCAN      |VIEW1|1        |39  |
|10|     TABLE SCAN       |t3   |1        |39  |
|11|   SORT               |     |1        |39  |
|12|    TABLE SCAN        |t4   |1        |39  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  2 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([NULL]), filter(nil), limit(1), offset(nil)
  7 - output([1]), filter(nil), 
      equal_conds([VIEW1.t3.c1 = t4.c1]), other_conds(nil)
  8 - output([VIEW1.t3.c1]), filter(nil), sort_keys([VIEW1.t3.c1, ASC])
  9 - output([VIEW1.t3.c1]), filter(nil), 
      access([VIEW1.t3.c1])
  10 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0), 
      limit(1), offset(nil)
  11 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  12 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1);
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 |    2 |    2 |
|    3 |    2 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |
|    5 |    5 | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1);
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |SUBPLAN FILTER        |    |4        |221 |
|1 | HASH RIGHT OUTER JOIN|    |8        |142 |
|2 |  TABLE SCAN          |t5  |5        |37  |
|3 |  HASH OUTER JOIN     |    |8        |93  |
|4 |   TABLE SCAN         |t1  |8        |38  |
|5 |   TABLE SCAN         |t2  |9        |38  |
|6 | MERGE OUTER JOIN     |    |1        |79  |
|7 |  SORT                |    |1        |39  |
|8 |   TABLE SCAN         |t3  |1        |39  |
|9 |  SORT                |    |1        |39  |
|10|   TABLE SCAN         |t4  |1        |39  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  2 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([NULL]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  7 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  8 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0)
  9 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  10 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1);
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
|    1 |    1 |    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 |    2 |    2 |
|    3 |    2 |    3 |    3 |    3 |    3 |
|    4 |    2 |    4 |    4 |    4 |    4 |
|    5 |    5 | NULL | NULL | NULL | NULL |
|   10 |   10 | NULL | NULL | NULL | NULL |
| NULL |    1 | NULL | NULL | NULL | NULL |
| NULL |    5 | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+
EXPLAIN insert into t5_temp (select * from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |4        |223 |
|1 | SUBPLAN SCAN           |VIEW1|4        |222 |
|2 |  SUBPLAN FILTER        |     |4        |222 |
|3 |   HASH RIGHT OUTER JOIN|     |8        |142 |
|4 |    TABLE SCAN          |t5   |5        |37  |
|5 |    HASH OUTER JOIN     |     |8        |93  |
|6 |     TABLE SCAN         |t1   |8        |38  |
|7 |     TABLE SCAN         |t2   |9        |38  |
|8 |   LIMIT                |     |1        |79  |
|9 |    MERGE OUTER JOIN    |     |1        |79  |
|10|     SORT               |     |1        |40  |
|11|      SUBPLAN SCAN      |VIEW2|1        |39  |
|12|       TABLE SCAN       |t3   |1        |39  |
|13|     SORT               |     |1        |39  |
|14|      TABLE SCAN        |t4   |1        |39  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.f, t5_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  4 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([NULL]), filter(nil), limit(1), offset(nil)
  9 - output([1]), filter(nil), 
      equal_conds([VIEW2.t3.c1 = t4.c1]), other_conds(nil)
  10 - output([VIEW2.t3.c1]), filter(nil), sort_keys([VIEW2.t3.c1, ASC])
  11 - output([VIEW2.t3.c1]), filter(nil), 
      access([VIEW2.t3.c1])
  12 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0), 
      limit(1), offset(nil)
  13 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  14 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

insert into t5_temp (select * from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1));

rollback;
EXPLAIN insert into t5_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |4        |223 |
|1 | SUBPLAN SCAN           |VIEW1|4        |222 |
|2 |  SUBPLAN FILTER        |     |4        |221 |
|3 |   HASH RIGHT OUTER JOIN|     |8        |142 |
|4 |    TABLE SCAN          |t5   |5        |37  |
|5 |    HASH OUTER JOIN     |     |8        |93  |
|6 |     TABLE SCAN         |t1   |8        |38  |
|7 |     TABLE SCAN         |t2   |9        |38  |
|8 |   MERGE OUTER JOIN     |     |1        |79  |
|9 |    SORT                |     |1        |39  |
|10|     TABLE SCAN         |t3   |1        |39  |
|11|    SORT                |     |1        |39  |
|12|     TABLE SCAN         |t4   |1        |39  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t5_temp: ({t5_temp: (t5_temp.__pk_increment, t5_temp.a, t5_temp.b, t5_temp.c, t5_temp.d, t5_temp.f, t5_temp.g)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  4 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([NULL]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  9 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  10 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  12 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

insert into t5_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                   |     |8        |254 |
|1 | SUBPLAN FILTER          |     |8        |246 |
|2 |  TABLE SCAN             |t1   |8        |38  |
|3 |  LIMIT                  |     |1        |207 |
|4 |   SUBPLAN FILTER        |     |1        |207 |
|5 |    HASH RIGHT OUTER JOIN|     |2        |128 |
|6 |     TABLE SCAN          |t5   |5        |37  |
|7 |     HASH OUTER JOIN     |     |2        |85  |
|8 |      TABLE SCAN         |t1   |8        |38  |
|9 |      TABLE SCAN         |t2   |3        |37  |
|10|    LIMIT                |     |1        |79  |
|11|     MERGE OUTER JOIN    |     |1        |79  |
|12|      SORT               |     |1        |40  |
|13|       SUBPLAN SCAN      |VIEW1|1        |39  |
|14|        TABLE SCAN       |t3   |1        |39  |
|15|      SORT               |     |1        |39  |
|16|       TABLE SCAN        |t4   |1        |39  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  6 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  7 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([NULL]), filter(nil), limit(1), offset(nil)
  11 - output([1]), filter(nil), 
      equal_conds([VIEW1.t3.c1 = t4.c1]), other_conds(nil)
  12 - output([VIEW1.t3.c1]), filter(nil), sort_keys([VIEW1.t3.c1, ASC])
  13 - output([VIEW1.t3.c1]), filter(nil), 
      access([VIEW1.t3.c1])
  14 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0), 
      limit(1), offset(nil)
  15 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  16 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |8        |253 |
|1 | SUBPLAN FILTER          |    |8        |245 |
|2 |  TABLE SCAN             |t1  |8        |38  |
|3 |  LIMIT                  |    |1        |207 |
|4 |   SUBPLAN FILTER        |    |1        |207 |
|5 |    HASH RIGHT OUTER JOIN|    |2        |128 |
|6 |     TABLE SCAN          |t5  |5        |37  |
|7 |     HASH OUTER JOIN     |    |2        |85  |
|8 |      TABLE SCAN         |t1  |8        |38  |
|9 |      TABLE SCAN         |t2  |3        |37  |
|10|    MERGE OUTER JOIN     |    |1        |79  |
|11|     SORT                |    |1        |39  |
|12|      TABLE SCAN         |t3  |1        |39  |
|13|     SORT                |    |1        |39  |
|14|      TABLE SCAN         |t4  |1        |39  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  6 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  7 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([NULL]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  11 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  12 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0)
  13 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  14 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                   |     |1        |246 |
|1 | SUBPLAN FILTER          |     |1        |245 |
|2 |  TABLE SCAN             |t1   |1        |39  |
|3 |  LIMIT                  |     |1        |207 |
|4 |   SUBPLAN FILTER        |     |1        |207 |
|5 |    HASH RIGHT OUTER JOIN|     |2        |128 |
|6 |     TABLE SCAN          |t5   |5        |37  |
|7 |     HASH OUTER JOIN     |     |2        |85  |
|8 |      TABLE SCAN         |t1   |8        |38  |
|9 |      TABLE SCAN         |t2   |3        |37  |
|10|    LIMIT                |     |1        |79  |
|11|     MERGE OUTER JOIN    |     |1        |79  |
|12|      SORT               |     |1        |40  |
|13|       SUBPLAN SCAN      |VIEW1|1        |39  |
|14|        TABLE SCAN       |t3   |1        |39  |
|15|      SORT               |     |1        |39  |
|16|       TABLE SCAN        |t4   |1        |39  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  6 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  7 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([NULL]), filter(nil), limit(1), offset(nil)
  11 - output([1]), filter(nil), 
      equal_conds([VIEW1.t3.c1 = t4.c1]), other_conds(nil)
  12 - output([VIEW1.t3.c1]), filter(nil), sort_keys([VIEW1.t3.c1, ASC])
  13 - output([VIEW1.t3.c1]), filter(nil), 
      access([VIEW1.t3.c1])
  14 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0), 
      limit(1), offset(nil)
  15 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  16 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                   |    |1        |246 |
|1 | SUBPLAN FILTER          |    |1        |245 |
|2 |  TABLE SCAN             |t1  |1        |39  |
|3 |  LIMIT                  |    |1        |207 |
|4 |   SUBPLAN FILTER        |    |1        |207 |
|5 |    HASH RIGHT OUTER JOIN|    |2        |128 |
|6 |     TABLE SCAN          |t5  |5        |37  |
|7 |     HASH OUTER JOIN     |    |2        |85  |
|8 |      TABLE SCAN         |t1  |8        |38  |
|9 |      TABLE SCAN         |t2  |3        |37  |
|10|    MERGE OUTER JOIN     |    |1        |79  |
|11|     SORT                |    |1        |39  |
|12|      TABLE SCAN         |t3  |1        |39  |
|13|     SORT                |    |1        |39  |
|14|      TABLE SCAN         |t4  |1        |39  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  6 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  7 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([NULL]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  11 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  12 - output([t3.c1]), filter([t3.c1 > 1]), 
      access([t3.c1]), partitions(p0)
  13 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  14 - output([t4.c1]), filter([t4.c1 > 1]), 
      access([t4.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 left join t5 on t2.c1=t5.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 where t3.c1>1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |HASH OUTER JOIN      |     |5        |234 |
|1 | HASH RIGHT SEMI JOIN|     |5        |184 |
|2 |  SUBPLAN SCAN       |VIEW1|5        |135 |
|3 |   HASH OUTER JOIN   |     |5        |135 |
|4 |    HASH JOIN        |     |5        |85  |
|5 |     TABLE SCAN      |t5   |5        |37  |
|6 |     TABLE SCAN      |t3   |8        |38  |
|7 |    TABLE SCAN       |t4   |8        |38  |
|8 |  TABLE SCAN         |t1   |8        |38  |
|9 | TABLE SCAN          |t2   |9        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t5.c1]), other_conds(nil)
  2 - output([VIEW1.t5.c1]), filter(nil), 
      access([VIEW1.t5.c1])
  3 - output([t5.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  4 - output([t5.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t5.c1]), other_conds(nil)
  5 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN select /*+NO_REWIRTE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |HASH OUTER JOIN      |     |5        |234 |
|1 | HASH RIGHT SEMI JOIN|     |5        |184 |
|2 |  SUBPLAN SCAN       |VIEW1|5        |135 |
|3 |   HASH OUTER JOIN   |     |5        |135 |
|4 |    HASH JOIN        |     |5        |85  |
|5 |     TABLE SCAN      |t5   |5        |37  |
|6 |     TABLE SCAN      |t3   |8        |38  |
|7 |    TABLE SCAN       |t4   |8        |38  |
|8 |  TABLE SCAN         |t1   |8        |38  |
|9 | TABLE SCAN          |t2   |9        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t5.c1]), other_conds(nil)
  2 - output([VIEW1.t5.c1]), filter(nil), 
      access([VIEW1.t5.c1])
  3 - output([t5.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  4 - output([t5.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t5.c1]), other_conds(nil)
  5 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select /*+NO_REWIRTE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
|    3 |    2 |    3 |    3 |
|    4 |    2 |    4 |    4 |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1));
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |5        |235 |
|1 | SUBPLAN SCAN          |VIEW1|5        |234 |
|2 |  HASH OUTER JOIN      |     |5        |234 |
|3 |   HASH RIGHT SEMI JOIN|     |5        |184 |
|4 |    SUBPLAN SCAN       |VIEW2|5        |135 |
|5 |     HASH OUTER JOIN   |     |5        |135 |
|6 |      HASH JOIN        |     |5        |85  |
|7 |       TABLE SCAN      |t5   |5        |37  |
|8 |       TABLE SCAN      |t3   |8        |38  |
|9 |      TABLE SCAN       |t4   |8        |38  |
|10|    TABLE SCAN         |t1   |8        |38  |
|11|   TABLE SCAN          |t2   |9        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.t5.c1]), other_conds(nil)
  4 - output([VIEW2.t5.c1]), filter(nil), 
      access([VIEW2.t5.c1])
  5 - output([t5.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  6 - output([t5.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t5.c1]), other_conds(nil)
  7 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWIRTE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1));
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |5        |235 |
|1 | SUBPLAN SCAN          |VIEW1|5        |234 |
|2 |  HASH OUTER JOIN      |     |5        |234 |
|3 |   HASH RIGHT SEMI JOIN|     |5        |184 |
|4 |    SUBPLAN SCAN       |VIEW2|5        |135 |
|5 |     HASH OUTER JOIN   |     |5        |135 |
|6 |      HASH JOIN        |     |5        |85  |
|7 |       TABLE SCAN      |t5   |5        |37  |
|8 |       TABLE SCAN      |t3   |8        |38  |
|9 |      TABLE SCAN       |t4   |8        |38  |
|10|    TABLE SCAN         |t1   |8        |38  |
|11|   TABLE SCAN          |t2   |9        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.t5.c1]), other_conds(nil)
  4 - output([VIEW2.t5.c1]), filter(nil), 
      access([VIEW2.t5.c1])
  5 - output([t5.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  6 - output([t5.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t5.c1]), other_conds(nil)
  7 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t4_temp (select /*+NO_REWIRTE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                  |     |8        |273 |
|1 | SUBPLAN FILTER         |     |8        |265 |
|2 |  TABLE SCAN            |t1   |8        |38  |
|3 |  LIMIT                 |     |1        |226 |
|4 |   HASH OUTER JOIN      |     |1        |226 |
|5 |    HASH RIGHT SEMI JOIN|     |5        |184 |
|6 |     SUBPLAN SCAN       |VIEW1|5        |135 |
|7 |      HASH OUTER JOIN   |     |5        |135 |
|8 |       HASH JOIN        |     |5        |85  |
|9 |        TABLE SCAN      |t5   |5        |37  |
|10|        TABLE SCAN      |t3   |8        |38  |
|11|       TABLE SCAN       |t4   |8        |38  |
|12|     TABLE SCAN         |t1   |8        |38  |
|13|    TABLE SCAN          |t2   |2        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t5.c1]), other_conds(nil)
  6 - output([VIEW1.t5.c1]), filter(nil), 
      access([VIEW1.t5.c1])
  7 - output([t5.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  8 - output([t5.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t5.c1]), other_conds(nil)
  9 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+NO_REWIRTE*/t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                  |     |8        |273 |
|1 | SUBPLAN FILTER         |     |8        |265 |
|2 |  TABLE SCAN            |t1   |8        |38  |
|3 |  LIMIT                 |     |1        |226 |
|4 |   HASH OUTER JOIN      |     |1        |226 |
|5 |    HASH RIGHT SEMI JOIN|     |5        |184 |
|6 |     SUBPLAN SCAN       |VIEW1|5        |135 |
|7 |      HASH OUTER JOIN   |     |5        |135 |
|8 |       HASH JOIN        |     |5        |85  |
|9 |        TABLE SCAN      |t5   |5        |37  |
|10|        TABLE SCAN      |t3   |8        |38  |
|11|       TABLE SCAN       |t4   |8        |38  |
|12|     TABLE SCAN         |t1   |8        |38  |
|13|    TABLE SCAN          |t2   |2        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t5.c1]), other_conds(nil)
  6 - output([VIEW1.t5.c1]), filter(nil), 
      access([VIEW1.t5.c1])
  7 - output([t5.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  8 - output([t5.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t5.c1]), other_conds(nil)
  9 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select /*+NO_REWIRTE*/t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                  |     |1        |266 |
|1 | SUBPLAN FILTER         |     |1        |265 |
|2 |  TABLE SCAN            |t1   |1        |39  |
|3 |  LIMIT                 |     |1        |226 |
|4 |   HASH OUTER JOIN      |     |1        |226 |
|5 |    HASH RIGHT SEMI JOIN|     |5        |184 |
|6 |     SUBPLAN SCAN       |VIEW1|5        |135 |
|7 |      HASH OUTER JOIN   |     |5        |135 |
|8 |       HASH JOIN        |     |5        |85  |
|9 |        TABLE SCAN      |t5   |5        |37  |
|10|        TABLE SCAN      |t3   |8        |38  |
|11|       TABLE SCAN       |t4   |8        |38  |
|12|     TABLE SCAN         |t1   |8        |38  |
|13|    TABLE SCAN          |t2   |2        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t5.c1]), other_conds(nil)
  6 - output([VIEW1.t5.c1]), filter(nil), 
      access([VIEW1.t5.c1])
  7 - output([t5.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  8 - output([t5.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t5.c1]), other_conds(nil)
  9 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+NO_REWIRTE*/t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                  |     |1        |266 |
|1 | SUBPLAN FILTER         |     |1        |265 |
|2 |  TABLE SCAN            |t1   |1        |39  |
|3 |  LIMIT                 |     |1        |226 |
|4 |   HASH OUTER JOIN      |     |1        |226 |
|5 |    HASH RIGHT SEMI JOIN|     |5        |184 |
|6 |     SUBPLAN SCAN       |VIEW1|5        |135 |
|7 |      HASH OUTER JOIN   |     |5        |135 |
|8 |       HASH JOIN        |     |5        |85  |
|9 |        TABLE SCAN      |t5   |5        |37  |
|10|        TABLE SCAN      |t3   |8        |38  |
|11|       TABLE SCAN       |t4   |8        |38  |
|12|     TABLE SCAN         |t1   |8        |38  |
|13|    TABLE SCAN          |t2   |2        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t5.c1]), other_conds(nil)
  6 - output([VIEW1.t5.c1]), filter(nil), 
      access([VIEW1.t5.c1])
  7 - output([t5.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  8 - output([t5.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t5.c1]), other_conds(nil)
  9 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select /*+NO_REWIRTE*/t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1);
Query Plan
=========================================================
|ID|OPERATOR                       |NAME |EST. ROWS|COST|
---------------------------------------------------------
|0 |NESTED-LOOP SEMI JOIN CARTESIAN|     |1        |226 |
|1 | MERGE OUTER JOIN              |     |1        |79  |
|2 |  TABLE SCAN                   |t1   |1        |39  |
|3 |  TABLE SCAN                   |t2   |1        |40  |
|4 | MATERIAL                      |     |8        |145 |
|5 |  SUBPLAN SCAN                 |VIEW1|8        |143 |
|6 |   NESTED-LOOP OUTER JOIN      |     |8        |142 |
|7 |    HASH OUTER JOIN            |     |8        |91  |
|8 |     TABLE SCAN                |t3   |8        |38  |
|9 |     TABLE SCAN                |t4   |8        |38  |
|10|    MATERIAL                   |     |5        |38  |
|11|     TABLE SCAN                |t5   |5        |37  |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c1 = 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter([t2.c1 = 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter(nil)
  5 - output([1]), filter(nil), 
      access(nil)
  6 - output([1]), filter(nil), 
      conds([t3.c1 = t4.c1]), nl_params_(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), 
      access([t5.__pk_increment]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1);
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |SUBPLAN FILTER         |    |4        |1238|
|1 | HASH OUTER JOIN       |    |8        |93  |
|2 |  TABLE SCAN           |t1  |8        |38  |
|3 |  TABLE SCAN           |t2  |9        |38  |
|4 | NESTED-LOOP OUTER JOIN|    |8        |142 |
|5 |  HASH OUTER JOIN      |    |8        |91  |
|6 |   TABLE SCAN          |t3  |8        |38  |
|7 |   TABLE SCAN          |t4  |8        |38  |
|8 |  MATERIAL             |    |5        |38  |
|9 |   TABLE SCAN          |t5  |5        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1 = 1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([NULL]), filter(nil), startup_filter([?]), 
      conds([t3.c1 = t4.c1]), nl_params_(nil)
  5 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      access([t5.__pk_increment]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    1 |    1 |    1 |    1 |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1));
Query Plan
===========================================================
|ID|OPERATOR                         |NAME |EST. ROWS|COST|
-----------------------------------------------------------
|0 |INSERT                           |     |1        |226 |
|1 | SUBPLAN SCAN                    |VIEW1|1        |226 |
|2 |  NESTED-LOOP SEMI JOIN CARTESIAN|     |1        |226 |
|3 |   MERGE OUTER JOIN              |     |1        |79  |
|4 |    TABLE SCAN                   |t1   |1        |39  |
|5 |    TABLE SCAN                   |t2   |1        |40  |
|6 |   MATERIAL                      |     |8        |145 |
|7 |    SUBPLAN SCAN                 |VIEW2|8        |143 |
|8 |     NESTED-LOOP OUTER JOIN      |     |8        |142 |
|9 |      HASH OUTER JOIN            |     |8        |91  |
|10|       TABLE SCAN                |t3   |8        |38  |
|11|       TABLE SCAN                |t4   |8        |38  |
|12|      MATERIAL                   |     |5        |38  |
|13|       TABLE SCAN                |t5   |5        |37  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter([t1.c1 = 1]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter([t2.c1 = 1]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access(nil)
  8 - output([1]), filter(nil), 
      conds([t3.c1 = t4.c1]), nl_params_(nil)
  9 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t5.__pk_increment]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1));
Query Plan
===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |INSERT                   |     |4        |1239|
|1 | SUBPLAN SCAN            |VIEW1|4        |1239|
|2 |  SUBPLAN FILTER         |     |4        |1238|
|3 |   HASH OUTER JOIN       |     |8        |93  |
|4 |    TABLE SCAN           |t1   |8        |38  |
|5 |    TABLE SCAN           |t2   |9        |38  |
|6 |   NESTED-LOOP OUTER JOIN|     |8        |142 |
|7 |    HASH OUTER JOIN      |     |8        |91  |
|8 |     TABLE SCAN          |t3   |8        |38  |
|9 |     TABLE SCAN          |t4   |8        |38  |
|10|    MATERIAL             |     |5        |38  |
|11|     TABLE SCAN          |t5   |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1 = 1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([NULL]), filter(nil), startup_filter([?]), 
      conds([t3.c1 = t4.c1]), nl_params_(nil)
  7 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), 
      access([t5.__pk_increment]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1) limit 1);
Query Plan
============================================================
|ID|OPERATOR                          |NAME |EST. ROWS|COST|
------------------------------------------------------------
|0 |UPDATE                            |     |8        |272 |
|1 | SUBPLAN FILTER                   |     |8        |264 |
|2 |  TABLE SCAN                      |t1   |8        |38  |
|3 |  LIMIT                           |     |1        |225 |
|4 |   NESTED-LOOP SEMI JOIN CARTESIAN|     |1        |225 |
|5 |    MERGE OUTER JOIN              |     |1        |79  |
|6 |     TABLE SCAN                   |t1   |1        |39  |
|7 |     TABLE SCAN                   |t2   |1        |39  |
|8 |    MATERIAL                      |     |8        |145 |
|9 |     SUBPLAN SCAN                 |VIEW1|8        |143 |
|10|      NESTED-LOOP OUTER JOIN      |     |8        |142 |
|11|       HASH OUTER JOIN            |     |8        |91  |
|12|        TABLE SCAN                |t3   |8        |38  |
|13|        TABLE SCAN                |t4   |8        |38  |
|14|       MATERIAL                   |     |5        |38  |
|15|        TABLE SCAN                |t5   |5        |37  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter([t1.c1 = 1]), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter([t2.c1 = 1]), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      access(nil)
  10 - output([1]), filter(nil), 
      conds([t3.c1 = t4.c1]), nl_params_(nil)
  11 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  14 - output([1]), filter(nil)
  15 - output([1]), filter(nil), 
      access([t5.__pk_increment]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1) limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |UPDATE                    |    |8        |417 |
|1 | SUBPLAN FILTER           |    |8        |409 |
|2 |  TABLE SCAN              |t1  |8        |38  |
|3 |  LIMIT                   |    |1        |371 |
|4 |   SUBPLAN FILTER         |    |1        |371 |
|5 |    HASH OUTER JOIN       |    |2        |85  |
|6 |     TABLE SCAN           |t1  |8        |38  |
|7 |     TABLE SCAN           |t2  |3        |37  |
|8 |    NESTED-LOOP OUTER JOIN|    |8        |142 |
|9 |     HASH OUTER JOIN      |    |8        |91  |
|10|      TABLE SCAN          |t3  |8        |38  |
|11|      TABLE SCAN          |t4  |8        |38  |
|12|     MATERIAL             |    |5        |38  |
|13|      TABLE SCAN          |t5  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1 = 1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([NULL]), filter(nil), startup_filter([?]), 
      conds([t3.c1 = t4.c1]), nl_params_(nil)
  9 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t5.__pk_increment]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1) limit 1);
Query Plan
============================================================
|ID|OPERATOR                          |NAME |EST. ROWS|COST|
------------------------------------------------------------
|0 |DELETE                            |     |1        |265 |
|1 | SUBPLAN FILTER                   |     |1        |264 |
|2 |  TABLE SCAN                      |t1   |1        |39  |
|3 |  LIMIT                           |     |1        |225 |
|4 |   NESTED-LOOP SEMI JOIN CARTESIAN|     |1        |225 |
|5 |    MERGE OUTER JOIN              |     |1        |79  |
|6 |     TABLE SCAN                   |t1   |1        |39  |
|7 |     TABLE SCAN                   |t2   |1        |39  |
|8 |    MATERIAL                      |     |8        |145 |
|9 |     SUBPLAN SCAN                 |VIEW1|8        |143 |
|10|      NESTED-LOOP OUTER JOIN      |     |8        |142 |
|11|       HASH OUTER JOIN            |     |8        |91  |
|12|        TABLE SCAN                |t3   |8        |38  |
|13|        TABLE SCAN                |t4   |8        |38  |
|14|       MATERIAL                   |     |5        |38  |
|15|        TABLE SCAN                |t5   |5        |37  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter([t1.c1 = 1]), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter([t2.c1 = 1]), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), 
      access(nil)
  10 - output([1]), filter(nil), 
      conds([t3.c1 = t4.c1]), nl_params_(nil)
  11 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  14 - output([1]), filter(nil)
  15 - output([1]), filter(nil), 
      access([t5.__pk_increment]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1) limit 1);
Query Plan
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |DELETE                    |    |1        |410 |
|1 | SUBPLAN FILTER           |    |1        |409 |
|2 |  TABLE SCAN              |t1  |1        |39  |
|3 |  LIMIT                   |    |1        |371 |
|4 |   SUBPLAN FILTER         |    |1        |371 |
|5 |    HASH OUTER JOIN       |    |2        |85  |
|6 |     TABLE SCAN           |t1  |8        |38  |
|7 |     TABLE SCAN           |t2  |3        |37  |
|8 |    NESTED-LOOP OUTER JOIN|    |8        |142 |
|9 |     HASH OUTER JOIN      |    |8        |91  |
|10|      TABLE SCAN          |t3  |8        |38  |
|11|      TABLE SCAN          |t4  |8        |38  |
|12|     MATERIAL             |    |5        |38  |
|13|      TABLE SCAN          |t5  |5        |37  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1 = 1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([NULL]), filter(nil), startup_filter([?]), 
      conds([t3.c1 = t4.c1]), nl_params_(nil)
  9 - output([t3.c1], [t4.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), 
      access([t5.__pk_increment]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t4.c1 where t1.c1=1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 2.8674417556808756 |
+--------------------+
rollback;

EXPLAIN select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |HASH OUTER JOIN      |     |3        |230 |
|1 | HASH RIGHT ANTI JOIN|     |3        |184 |
|2 |  SUBPLAN SCAN       |VIEW1|5        |135 |
|3 |   HASH OUTER JOIN   |     |5        |135 |
|4 |    HASH JOIN        |     |5        |85  |
|5 |     TABLE SCAN      |t5   |5        |37  |
|6 |     TABLE SCAN      |t3   |8        |38  |
|7 |    TABLE SCAN       |t4   |8        |38  |
|8 |  TABLE SCAN         |t1   |8        |38  |
|9 | TABLE SCAN          |t2   |9        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t5.c1]), other_conds(nil)
  2 - output([VIEW1.t5.c1]), filter(nil), 
      access([VIEW1.t5.c1])
  3 - output([t5.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  4 - output([t5.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t5.c1]), other_conds(nil)
  5 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
|    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL |
| NULL |    1 | NULL | NULL |
| NULL |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1);
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |4        |1012|
|1 | HASH OUTER JOIN           |    |8        |93  |
|2 |  TABLE SCAN               |t1  |8        |38  |
|3 |  TABLE SCAN               |t2  |9        |38  |
|4 | NESTED-LOOP JOIN CARTESIAN|    |1        |115 |
|5 |  MERGE OUTER JOIN         |    |1        |77  |
|6 |   TABLE SCAN              |t3  |1        |38  |
|7 |   TABLE SCAN              |t4  |1        |38  |
|8 |  MATERIAL                 |    |1        |38  |
|9 |   TABLE SCAN              |t5  |1        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([NULL]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  6 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  7 - output([t4.c1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)

select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
|    5 |    5 | NULL | NULL |
|   10 |   10 | NULL | NULL |
| NULL |    1 | NULL | NULL |
| NULL |    5 | NULL | NULL |
+------+------+------+------+
EXPLAIN insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1));
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |3        |231 |
|1 | SUBPLAN SCAN          |VIEW1|3        |230 |
|2 |  HASH OUTER JOIN      |     |3        |230 |
|3 |   HASH RIGHT ANTI JOIN|     |3        |184 |
|4 |    SUBPLAN SCAN       |VIEW2|5        |135 |
|5 |     HASH OUTER JOIN   |     |5        |135 |
|6 |      HASH JOIN        |     |5        |85  |
|7 |       TABLE SCAN      |t5   |5        |37  |
|8 |       TABLE SCAN      |t3   |8        |38  |
|9 |      TABLE SCAN       |t4   |8        |38  |
|10|    TABLE SCAN         |t1   |8        |38  |
|11|   TABLE SCAN          |t2   |9        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.t5.c1]), other_conds(nil)
  4 - output([VIEW2.t5.c1]), filter(nil), 
      access([VIEW2.t5.c1])
  5 - output([t5.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  6 - output([t5.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t5.c1]), other_conds(nil)
  7 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  9 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t4_temp (select * from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1));

rollback;
EXPLAIN insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1));
Query Plan
=======================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST|
-------------------------------------------------------
|0 |INSERT                       |     |4        |1013|
|1 | SUBPLAN SCAN                |VIEW1|4        |1013|
|2 |  SUBPLAN FILTER             |     |4        |1012|
|3 |   HASH OUTER JOIN           |     |8        |93  |
|4 |    TABLE SCAN               |t1   |8        |38  |
|5 |    TABLE SCAN               |t2   |9        |38  |
|6 |   NESTED-LOOP JOIN CARTESIAN|     |1        |115 |
|7 |    MERGE OUTER JOIN         |     |1        |77  |
|8 |     TABLE SCAN              |t3   |1        |38  |
|9 |     TABLE SCAN              |t4   |1        |38  |
|10|    MATERIAL                 |     |1        |38  |
|11|     TABLE SCAN              |t5   |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  6 - output([NULL]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  8 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  9 - output([t4.c1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)
  10 - output([1]), filter(nil)
  11 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)

insert into t4_temp (select /*+NO_REWRITE*/* from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1));

rollback;
EXPLAIN update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                  |     |8        |271 |
|1 | SUBPLAN FILTER         |     |8        |263 |
|2 |  TABLE SCAN            |t1   |8        |38  |
|3 |  LIMIT                 |     |1        |225 |
|4 |   HASH OUTER JOIN      |     |1        |225 |
|5 |    HASH RIGHT ANTI JOIN|     |3        |184 |
|6 |     SUBPLAN SCAN       |VIEW1|5        |135 |
|7 |      HASH OUTER JOIN   |     |5        |135 |
|8 |       HASH JOIN        |     |5        |85  |
|9 |        TABLE SCAN      |t5   |5        |37  |
|10|        TABLE SCAN      |t3   |8        |38  |
|11|       TABLE SCAN       |t4   |8        |38  |
|12|     TABLE SCAN         |t1   |8        |38  |
|13|    TABLE SCAN          |t2   |3        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t5.c1]), other_conds(nil)
  6 - output([VIEW1.t5.c1]), filter(nil), 
      access([VIEW1.t5.c1])
  7 - output([t5.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  8 - output([t5.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t5.c1]), other_conds(nil)
  9 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t1 set c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |UPDATE                        |    |8        |361 |
|1 | SUBPLAN FILTER               |    |8        |353 |
|2 |  TABLE SCAN                  |t1  |8        |38  |
|3 |  LIMIT                       |    |1        |314 |
|4 |   SUBPLAN FILTER             |    |1        |314 |
|5 |    HASH OUTER JOIN           |    |2        |85  |
|6 |     TABLE SCAN               |t1  |8        |38  |
|7 |     TABLE SCAN               |t2  |3        |37  |
|8 |    NESTED-LOOP JOIN CARTESIAN|    |1        |115 |
|9 |     MERGE OUTER JOIN         |    |1        |77  |
|10|      TABLE SCAN              |t3  |1        |38  |
|11|      TABLE SCAN              |t4  |1        |38  |
|12|     MATERIAL                 |    |1        |38  |
|13|      TABLE SCAN              |t5  |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([NULL]), filter(nil), 
      conds(nil), nl_params_(nil)
  9 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  10 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)

update t1 set c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |DELETE                  |     |1        |264 |
|1 | SUBPLAN FILTER         |     |1        |263 |
|2 |  TABLE SCAN            |t1   |1        |39  |
|3 |  LIMIT                 |     |1        |225 |
|4 |   HASH OUTER JOIN      |     |1        |225 |
|5 |    HASH RIGHT ANTI JOIN|     |3        |184 |
|6 |     SUBPLAN SCAN       |VIEW1|5        |135 |
|7 |      HASH OUTER JOIN   |     |5        |135 |
|8 |       HASH JOIN        |     |5        |85  |
|9 |        TABLE SCAN      |t5   |5        |37  |
|10|        TABLE SCAN      |t3   |8        |38  |
|11|       TABLE SCAN       |t4   |8        |38  |
|12|     TABLE SCAN         |t1   |8        |38  |
|13|    TABLE SCAN          |t2   |3        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t5.c1]), other_conds(nil)
  6 - output([VIEW1.t5.c1]), filter(nil), 
      access([VIEW1.t5.c1])
  7 - output([t5.c1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  8 - output([t5.c1], [t3.c1]), filter(nil), 
      equal_conds([t3.c1 = t5.c1]), other_conds(nil)
  9 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t1 where c2 = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.3226495451672298 |
+--------------------+
rollback;
EXPLAIN delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
Query Plan
=======================================================
|ID|OPERATOR                      |NAME|EST. ROWS|COST|
-------------------------------------------------------
|0 |DELETE                        |    |1        |354 |
|1 | SUBPLAN FILTER               |    |1        |353 |
|2 |  TABLE SCAN                  |t1  |1        |39  |
|3 |  LIMIT                       |    |1        |314 |
|4 |   SUBPLAN FILTER             |    |1        |314 |
|5 |    HASH OUTER JOIN           |    |2        |85  |
|6 |     TABLE SCAN               |t1  |8        |38  |
|7 |     TABLE SCAN               |t2  |3        |37  |
|8 |    NESTED-LOOP JOIN CARTESIAN|    |1        |115 |
|9 |     MERGE OUTER JOIN         |    |1        |77  |
|10|      TABLE SCAN              |t3  |1        |38  |
|11|      TABLE SCAN              |t4  |1        |38  |
|12|     MATERIAL                 |    |1        |38  |
|13|      TABLE SCAN              |t5  |1        |38  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([NULL]), filter(nil), 
      conds(nil), nl_params_(nil)
  9 - output([1]), filter(nil), 
      equal_conds([t3.c1 = t4.c1]), other_conds(nil)
  10 - output([t3.c1]), filter([? = t3.c1]), 
      access([t3.c1]), partitions(p0)
  11 - output([t4.c1]), filter([? = t4.c1]), 
      access([t4.c1]), partitions(p0)
  12 - output([1]), filter(nil)
  13 - output([1]), filter([? = t5.c1]), 
      access([t5.c1]), partitions(p0)

delete from t1 where c2 = (select /*+ NO_REWRITE */t1.c1 from t1 left join t2 on t1.c1=t2.c1 where not exists (select null from t3 left join t4 on t3.c1=t4.c1 left join t5 on t3.c1=t5.c1 where t1.c1=t5.c1) limit 1);
EXPLAIN select stddev(c2) from t1;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t1.c2 * t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2 * t1.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t1.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t1.c2) * T_FUN_COUNT(t1.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c2)], [T_FUN_SUM(t1.c2 * t1.c2)], [T_FUN_COUNT(t1.c2)], [T_FUN_COUNT(t1.c2 * t1.c2)])
  1 - output([t1.c2], [t1.c2 * t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0)

select stddev(c2) from t1;
+--------------------+
| stddev(c2)         |
+--------------------+
| 3.3226495451672298 |
+--------------------+
rollback;

set autocommit=1;

drop table if exists t5, t6, t7, t8, t9, t10, t11;
create table t5(c1 int primary key, c2 int, c3 varchar(32));
create table t6(c1 int, c2 int, c3 varchar(32), primary key(c1,c2));
create table t7(c1 int primary key, c2 int, c3 varchar(32))
                                partition by hash(c1) partitions 5;
create table t8(c1 int, c2 int not null, c3 varchar(32),
                foreign key(c1) references t5(c1),
                foreign key(c2) references t5(c1));
create table t9(c1 int not null, c2 int, c3 varchar(32),
                foreign key(c1) references t7(c1))
                partition by list(c1) (
                    partition p0 values in(1,2),
                    partition p1 values in(3,4),
                    partition p2 values in(5,6),
                    partition p3 values in(7,8),
                    partition p4 values in(9,10));
create table t10(c1 int not null, c2 int, c3 varchar(32),
                foreign key(c1) references t7(c1))
                partition by hash(c1) partitions 5;
create table t11(c1 int not null, c2 int not null, c3 varchar(32),
            foreign key(c1,c2) references t6(c1,c2));

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({1, 1, 'a'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({2, 5, 'b'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({3, 5, 'c'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({4, 6, 'd'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({5, 7, 'e'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({6, 8, 'f'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t6: ({t6: (t6.c1, t6.c2, t6.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({1, 1, 'a'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t6: ({t6: (t6.c1, t6.c2, t6.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({2, 2, 'b'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t6: ({t6: (t6.c1, t6.c2, t6.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({3, 3, 'c'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t6: ({t6: (t6.c1, t6.c2, t6.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({4, 4, 'd'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t6: ({t6: (t6.c1, t6.c2, t6.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({5, 5, 'e'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t6: ({t6: (t6.c1, t6.c2, t6.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({6, 6, 'f'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t7: ({t7: (t7.c1, t7.c2, t7.c3)})}]), partitions(p1)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({1, 1, 'a'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t7: ({t7: (t7.c1, t7.c2, t7.c3)})}]), partitions(p2)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({2, 5, 'b'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t7: ({t7: (t7.c1, t7.c2, t7.c3)})}]), partitions(p3)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({3, 5, 'c'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t7: ({t7: (t7.c1, t7.c2, t7.c3)})}]), partitions(p4)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({4, 6, 'd'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t7: ({t7: (t7.c1, t7.c2, t7.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({5, 7, 'e'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t7: ({t7: (t7.c1, t7.c2, t7.c3)})}]), partitions(p1)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({6, 8, 'f'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t8: ({t8: (t8.__pk_increment, t8.c1, t8.c2, t8.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({1, 1, 'a'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t8: ({t8: (t8.__pk_increment, t8.c1, t8.c2, t8.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({1, 2, 'b'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t8: ({t8: (t8.__pk_increment, t8.c1, t8.c2, t8.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({3, 3, 'c'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t8: ({t8: (t8.__pk_increment, t8.c1, t8.c2, t8.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({3, 3, 'd'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t8: ({t8: (t8.__pk_increment, t8.c1, t8.c2, t8.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({NULL, 4, 'e'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t8: ({t8: (t8.__pk_increment, t8.c1, t8.c2, t8.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({NULL, 4, 'f'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t9: ({t9: (t9.c1, t9.__pk_increment, t9.c2, t9.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({1, 2, 'a'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t9: ({t9: (t9.c1, t9.__pk_increment, t9.c2, t9.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({1, 2, 'b'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t9: ({t9: (t9.c1, t9.__pk_increment, t9.c2, t9.c3)})}]), partitions(p1)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({3, 3, 'c'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t9: ({t9: (t9.c1, t9.__pk_increment, t9.c2, t9.c3)})}]), partitions(p1)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({3, 3, 'd'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t9: ({t9: (t9.c1, t9.__pk_increment, t9.c2, t9.c3)})}]), partitions(p1)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({4, 4, 'e'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t9: ({t9: (t9.c1, t9.__pk_increment, t9.c2, t9.c3)})}]), partitions(p1)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({4, 4, 'f'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t10: ({t10: (t10.c1, t10.__pk_increment, t10.c2, t10.c3)})}]), partitions(p1)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({1, 2, 'a'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t10: ({t10: (t10.c1, t10.__pk_increment, t10.c2, t10.c3)})}]), partitions(p1)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({1, 2, 'b'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t10: ({t10: (t10.c1, t10.__pk_increment, t10.c2, t10.c3)})}]), partitions(p3)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({3, 3, 'c'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t10: ({t10: (t10.c1, t10.__pk_increment, t10.c2, t10.c3)})}]), partitions(p3)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({3, 3, 'd'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t10: ({t10: (t10.c1, t10.__pk_increment, t10.c2, t10.c3)})}]), partitions(p4)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({4, 4, 'e'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t10: ({t10: (t10.c1, t10.__pk_increment, t10.c2, t10.c3)})}]), partitions(p4)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({4, 4, 'f'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t11: ({t11: (t11.__pk_increment, t11.c1, t11.c2, t11.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({1, 1, 'a'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t11: ({t11: (t11.__pk_increment, t11.c1, t11.c2, t11.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({1, 1, 'b'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t11: ({t11: (t11.__pk_increment, t11.c1, t11.c2, t11.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({3, 3, 'c'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t11: ({t11: (t11.__pk_increment, t11.c1, t11.c2, t11.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({3, 3, 'd'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t11: ({t11: (t11.__pk_increment, t11.c1, t11.c2, t11.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({4, 4, 'e'})

Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NOT NULL,__values.c1)], [column_conv(INT,PS:(11,0),NOT NULL,__values.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,__values.c3)]), filter(nil), 
      columns([{t11: ({t11: (t11.__pk_increment, t11.c1, t11.c2, t11.c3)})}]), partitions(p0)
  1 - output([__values.c1], [__values.c2], [__values.c3]), filter(nil)
      values({4, 4, 'f'})

set autocommit=0;

##cases 增强功能，根据主外键消除外连接
##case 简单主外键连接
##外键没有非空约束，不能消除
EXPLAIN select * from t8 a left join t5 b on a.c1=b.c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |90  |
|1 | SORT           |    |6        |48  |
|2 |  TABLE SCAN    |a   |6        |38  |
|3 | TABLE SCAN     |b   |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c1, ASC])
  2 - output([a.c1], [a.c2], [a.c3]), filter(nil), 
      access([a.c1], [a.c2], [a.c3]), partitions(p0)
  3 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

select * from t8 a left join t5 b on a.c1=b.c1;
+------+----+------+----+------+------+
| c1   | c2 | c3   | c1 | c2   | c3   |
+------+----+------+----+------+------+
|    1 |  1 | a    |  1 |    1 | a    |
|    1 |  2 | b    |  1 |    1 | a    |
|    3 |  3 | c    |  3 |    5 | c    |
|    3 |  3 | d    |  3 |    5 | c    |
| NULL |  4 | e    | NULL | NULL | NULL |
| NULL |  4 | f    | NULL | NULL | NULL |
+------+----+------+----+------+------+
##左表为父表，不能消除
EXPLAIN select * from t8 a right join t5 b on a.c2=b.c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |90  |
|1 | TABLE SCAN     |b   |6        |37  |
|2 | SORT           |    |6        |48  |
|3 |  TABLE SCAN    |a   |6        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  1 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)
  2 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  3 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)

select * from t8 a right join t5 b on a.c2=b.c1;
+------+----+------+----+------+------+
| c1   | c2 | c3   | c1 | c2   | c3   |
+------+----+------+----+------+------+
|    1 |  1 | a    |  1 |    1 | a    |
|    1 |  2 | b    |  2 |    5 | b    |
|    3 |  3 | c    |  3 |    5 | c    |
|    3 |  3 | d    |  3 |    5 | c    |
| NULL |  4 | e    |  4 |    6 | d    |
| NULL |  4 | f    |  4 |    6 | d    |
| NULL | NULL | NULL |  5 |    7 | e    |
| NULL | NULL | NULL |  6 |    8 | f    |
+------+----+------+----+------+------+
##主键在generated table中，不能消除
EXPLAIN select * from t8 a left join (select * from t5 where t5.c1>0) b on a.c2=b.c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |90  |
|1 | SORT           |    |6        |48  |
|2 |  TABLE SCAN    |a   |6        |38  |
|3 | TABLE SCAN     |t5  |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([a.c2 = t5.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  2 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  3 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0)

select * from t8 a left join (select * from t5 where t5.c1>0) b on a.c2=b.c1;
+------+----+------+----+------+------+
| c1   | c2 | c3   | c1 | c2   | c3   |
+------+----+------+----+------+------+
|    1 |  1 | a    |  1 |    1 | a    |
|    1 |  2 | b    |  2 |    5 | b    |
|    3 |  3 | c    |  3 |    5 | c    |
|    3 |  3 | d    |  3 |    5 | c    |
| NULL |  4 | e    |  4 |    6 | d    |
| NULL |  4 | f    |  4 |    6 | d    |
+------+----+------+----+------+------+
##主键在generated table中，不能消除
EXPLAIN select * from (select * from t8 where t8.c1>0) a left join (select * from t5 where t5.c1>0) b on a.c2=b.c1;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |1        |61  |
|1 | TABLE SCAN           |t8  |1        |39  |
|2 | TABLE GET            |t5  |1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t8.c1], [t8.c2], [t8.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      conds(nil), nl_params_([t8.c2])
  1 - output([t8.c1], [t8.c2], [t8.c3]), filter([t8.c1 > 0]), 
      access([t8.c1], [t8.c2], [t8.c3]), partitions(p0)
  2 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0)

select * from (select * from t8 where t8.c1>0) a left join (select * from t5 where t5.c1>0) b on a.c2=b.c1;
+------+----+------+----+------+------+
| c1   | c2 | c3   | c1 | c2   | c3   |
+------+----+------+----+------+------+
|    1 |  1 | a    |  1 |    1 | a    |
|    1 |  2 | b    |  2 |    5 | b    |
|    3 |  3 | c    |  3 |    5 | c    |
|    3 |  3 | d    |  3 |    5 | c    |
+------+----+------+----+------+------+
##非等值连接，不能消除
EXPLAIN select * from t8 a left join t5 b on a.c2>b.c1;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |12       |263 |
|1 | TABLE SCAN           |a   |6        |38  |
|2 | TABLE SCAN           |b   |2        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      conds(nil), nl_params_([a.c2])
  1 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  2 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

select * from t8 a left join t5 b on a.c2>b.c1;
+------+----+------+----+------+------+
| c1   | c2 | c3   | c1 | c2   | c3   |
+------+----+------+----+------+------+
|    1 |  1 | a    | NULL | NULL | NULL |
|    1 |  2 | b    |  1 |    1 | a    |
|    3 |  3 | c    |  1 |    1 | a    |
|    3 |  3 | c    |  2 |    5 | b    |
|    3 |  3 | d    |  1 |    1 | a    |
|    3 |  3 | d    |  2 |    5 | b    |
| NULL |  4 | e    |  1 |    1 | a    |
| NULL |  4 | e    |  2 |    5 | b    |
| NULL |  4 | e    |  3 |    5 | c    |
| NULL |  4 | f    |  1 |    1 | a    |
| NULL |  4 | f    |  2 |    5 | b    |
| NULL |  4 | f    |  3 |    5 | c    |
+------+----+------+----+------+------+
##含有非主外键连接条件，不能消除
EXPLAIN select * from t8 a left join t5 b on a.c2=b.c1 and a.c1<3;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |88  |
|1 | SORT           |    |6        |48  |
|2 |  TABLE SCAN    |a   |6        |38  |
|3 | TABLE SCAN     |b   |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds([a.c1 < 3])
  1 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  2 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  3 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

select * from t8 a left join t5 b on a.c2=b.c1 and a.c1<3;
+------+----+------+----+------+------+
| c1   | c2 | c3   | c1 | c2   | c3   |
+------+----+------+----+------+------+
|    1 |  1 | a    |  1 |    1 | a    |
|    1 |  2 | b    |  2 |    5 | b    |
|    3 |  3 | c    | NULL | NULL | NULL |
|    3 |  3 | d    | NULL | NULL | NULL |
| NULL |  4 | e    | NULL | NULL | NULL |
| NULL |  4 | f    | NULL | NULL | NULL |
+------+----+------+----+------+------+
##on condition有重复expr
EXPLAIN select * from t8 a left join t5 b on a.c2=b.c1 and a.c2=b.c1 and a.c2=b.c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |90  |
|1 | SORT           |    |6        |48  |
|2 |  TABLE SCAN    |a   |6        |38  |
|3 | TABLE SCAN     |b   |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  2 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  3 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

select * from t8 a left join t5 b on a.c2=b.c1 and a.c2=b.c1 and a.c2=b.c1;
+------+----+------+----+------+------+
| c1   | c2 | c3   | c1 | c2   | c3   |
+------+----+------+----+------+------+
|    1 |  1 | a    |  1 |    1 | a    |
|    1 |  2 | b    |  2 |    5 | b    |
|    3 |  3 | c    |  3 |    5 | c    |
|    3 |  3 | d    |  3 |    5 | c    |
| NULL |  4 | e    |  4 |    6 | d    |
| NULL |  4 | f    |  4 |    6 | d    |
+------+----+------+----+------+------+
EXPLAIN select * from t8 a left join t5 b on a.c2=b.c1;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |6        |90  |
|1 | SORT       |    |6        |48  |
|2 |  TABLE SCAN|a   |6        |38  |
|3 | TABLE SCAN |b   |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  2 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  3 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

select * from t8 a left join t5 b on a.c2=b.c1;
+------+----+------+----+------+------+
| c1   | c2 | c3   | c1 | c2   | c3   |
+------+----+------+----+------+------+
|    1 |  1 | a    |  1 |    1 | a    |
|    1 |  2 | b    |  2 |    5 | b    |
|    3 |  3 | c    |  3 |    5 | c    |
|    3 |  3 | d    |  3 |    5 | c    |
| NULL |  4 | e    |  4 |    6 | d    |
| NULL |  4 | f    |  4 |    6 | d    |
+------+----+------+----+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t8 a left join t5 b on a.c2=b.c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |90  |
|1 | SORT           |    |6        |48  |
|2 |  TABLE SCAN    |a   |6        |38  |
|3 | TABLE SCAN     |b   |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  2 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  3 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

select /*+NO_REWRITE*/* from t8 a left join t5 b on a.c2=b.c1;
+------+----+------+----+------+------+
| c1   | c2 | c3   | c1 | c2   | c3   |
+------+----+------+----+------+------+
|    1 |  1 | a    |  1 |    1 | a    |
|    1 |  2 | b    |  2 |    5 | b    |
|    3 |  3 | c    |  3 |    5 | c    |
|    3 |  3 | d    |  3 |    5 | c    |
| NULL |  4 | e    |  4 |    6 | d    |
| NULL |  4 | f    |  4 |    6 | d    |
+------+----+------+----+------+------+
EXPLAIN insert into t16_temp (select * from t8 a left join t5 b on a.c2=b.c1);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |92  |
|1 | SUBPLAN SCAN |VIEW1|6        |91  |
|2 |  MERGE JOIN  |     |6        |90  |
|3 |   SORT       |     |6        |48  |
|4 |    TABLE SCAN|a    |6        |38  |
|5 |   TABLE SCAN |b    |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t16_temp: ({t16_temp: (t16_temp.__pk_increment, t16_temp.a, t16_temp.b, t16_temp.c, t16_temp.d, t16_temp.e, t16_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  3 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  4 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  5 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

insert into t16_temp (select * from t8 a left join t5 b on a.c2=b.c1);
rollback;
EXPLAIN insert into t16_temp (select /*+NO_REWRITE*/ * from t8 a left join t5 b on a.c2=b.c1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |92  |
|1 | SUBPLAN SCAN     |VIEW1|6        |91  |
|2 |  MERGE OUTER JOIN|     |6        |90  |
|3 |   SORT           |     |6        |48  |
|4 |    TABLE SCAN    |a    |6        |38  |
|5 |   TABLE SCAN     |b    |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t16_temp: ({t16_temp: (t16_temp.__pk_increment, t16_temp.a, t16_temp.b, t16_temp.c, t16_temp.d, t16_temp.e, t16_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  3 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  4 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  5 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

insert into t16_temp (select /*+NO_REWRITE*/ * from t8 a left join t5 b on a.c2=b.c1);
rollback;
EXPLAIN update t5 set c2 = (select a.c1 from t8 a left join t5 b on a.c2=b.c1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |80  |
|1 | SUBPLAN FILTER|    |6        |74  |
|2 |  TABLE SCAN   |t5  |6        |37  |
|3 |  TABLE SCAN   |a   |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([a.c1]), filter(nil), 
      access([a.c1]), partitions(p0), 
      limit(1), offset(nil)

update t5 set c2 = (select a.c1 from t8 a left join t5 b on a.c2=b.c1 limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t5 set c2 = (select /*+NO_REWRITE*/ a.c1 from t8 a left join t5 b on a.c2=b.c1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |117 |
|1 | SUBPLAN FILTER          |    |6        |111 |
|2 |  TABLE SCAN             |t5  |6        |37  |
|3 |  LIMIT                  |    |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |73  |
|5 |    TABLE SCAN           |a   |1        |36  |
|6 |    TABLE GET            |b   |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([a.c1]), filter(nil), limit(1), offset(nil)
  4 - output([a.c1]), filter(nil), 
      conds(nil), nl_params_([a.c2])
  5 - output([a.c2], [a.c1]), filter(nil), 
      access([a.c2], [a.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([b.c1]), partitions(p0)

update t5 set c2 = (select /*+NO_REWRITE*/ a.c1 from t8 a left join t5 b on a.c2=b.c1 limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;

EXPLAIN select * from t8 a left join t5 b on a.c1=b.c1 where a.c1>0;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |61  |
|1 | TABLE SCAN     |a   |1        |39  |
|2 | TABLE GET      |b   |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      conds(nil), nl_params_([a.c1])
  1 - output([a.c1], [a.c2], [a.c3]), filter([a.c1 > 0]), 
      access([a.c1], [a.c2], [a.c3]), partitions(p0)
  2 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

select * from t8 a left join t5 b on a.c1=b.c1 where a.c1>0;
+------+----+------+----+------+------+
| c1   | c2 | c3   | c1 | c2   | c3   |
+------+----+------+----+------+------+
|    1 |  1 | a    |  1 |    1 | a    |
|    1 |  2 | b    |  1 |    1 | a    |
|    3 |  3 | c    |  3 |    5 | c    |
|    3 |  3 | d    |  3 |    5 | c    |
+------+----+------+----+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t8 a left join t5 b on a.c1=b.c1 where a.c1>0;
Query Plan
===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |1        |61  |
|1 | TABLE SCAN           |a   |1        |39  |
|2 | TABLE GET            |b   |1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      conds(nil), nl_params_([a.c1])
  1 - output([a.c1], [a.c2], [a.c3]), filter([a.c1 > 0]), 
      access([a.c1], [a.c2], [a.c3]), partitions(p0)
  2 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

select /*+NO_REWRITE*/* from t8 a left join t5 b on a.c1=b.c1 where a.c1>0;
+------+----+------+----+------+------+
| c1   | c2 | c3   | c1 | c2   | c3   |
+------+----+------+----+------+------+
|    1 |  1 | a    |  1 |    1 | a    |
|    1 |  2 | b    |  1 |    1 | a    |
|    3 |  3 | c    |  3 |    5 | c    |
|    3 |  3 | d    |  3 |    5 | c    |
+------+----+------+----+------+------+
EXPLAIN insert into t16_temp (select * from t8 a left join t5 b on a.c1=b.c1 where a.c1>0);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |1        |61  |
|1 | SUBPLAN SCAN     |VIEW1|1        |61  |
|2 |  NESTED-LOOP JOIN|     |1        |61  |
|3 |   TABLE SCAN     |a    |1        |39  |
|4 |   TABLE GET      |b    |1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t16_temp: ({t16_temp: (t16_temp.__pk_increment, t16_temp.a, t16_temp.b, t16_temp.c, t16_temp.d, t16_temp.e, t16_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      conds(nil), nl_params_([a.c1])
  3 - output([a.c1], [a.c2], [a.c3]), filter([a.c1 > 0]), 
      access([a.c1], [a.c2], [a.c3]), partitions(p0)
  4 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

insert into t16_temp (select * from t8 a left join t5 b on a.c1=b.c1 where a.c1>0);
rollback;
EXPLAIN insert into t16_temp (select /*+NO_REWRITE*/ * from t8 a left join t5 b on a.c1=b.c1 where a.c1>0);
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |1        |61  |
|1 | SUBPLAN SCAN           |VIEW1|1        |61  |
|2 |  NESTED-LOOP OUTER JOIN|     |1        |61  |
|3 |   TABLE SCAN           |a    |1        |39  |
|4 |   TABLE GET            |b    |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t16_temp: ({t16_temp: (t16_temp.__pk_increment, t16_temp.a, t16_temp.b, t16_temp.c, t16_temp.d, t16_temp.e, t16_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      conds(nil), nl_params_([a.c1])
  3 - output([a.c1], [a.c2], [a.c3]), filter([a.c1 > 0]), 
      access([a.c1], [a.c2], [a.c3]), partitions(p0)
  4 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

insert into t16_temp (select /*+NO_REWRITE*/ * from t8 a left join t5 b on a.c1=b.c1 where a.c1>0);
rollback;
EXPLAIN update t5 set c2 = (select a.c1 from t8 a left join t5 b on a.c1=b.c1 where a.c1>0 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |82  |
|1 | SUBPLAN FILTER|    |6        |76  |
|2 |  TABLE SCAN   |t5  |6        |37  |
|3 |  TABLE SCAN   |a   |1        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([a.c1]), filter([a.c1 > 0]), 
      access([a.c1]), partitions(p0), 
      limit(1), offset(nil)

update t5 set c2 = (select a.c1 from t8 a left join t5 b on a.c1=b.c1 where a.c1>0 limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t5 set c2 = (select /*+NO_REWRITE*/ a.c1 from t8 a left join t5 b on a.c1=b.c1 where a.c1>0 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |104 |
|1 | SUBPLAN FILTER          |    |6        |98  |
|2 |  TABLE SCAN             |t5  |6        |37  |
|3 |  LIMIT                  |    |1        |60  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |60  |
|5 |    TABLE SCAN           |a   |1        |38  |
|6 |    TABLE GET            |b   |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([a.c1]), filter(nil), limit(1), offset(nil)
  4 - output([a.c1]), filter(nil), 
      conds(nil), nl_params_([a.c1])
  5 - output([a.c1]), filter([a.c1 > 0]), 
      access([a.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([b.c1]), partitions(p0)

update t5 set c2 = (select /*+NO_REWRITE*/ a.c1 from t8 a left join t5 b on a.c1=b.c1 where a.c1>0 limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;

##case 多列主外键连接
##主外键没有一一对应连接，不能消除
EXPLAIN select * from t11 a left join t6 b on a.c1=b.c2 and a.c2=b.c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |91  |
|1 | SORT           |    |6        |48  |
|2 |  TABLE SCAN    |a   |6        |38  |
|3 | TABLE SCAN     |b   |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1], [a.c1 = b.c2]), other_conds(nil)
  1 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC], [a.c1, ASC])
  2 - output([a.c1], [a.c2], [a.c3]), filter(nil), 
      access([a.c1], [a.c2], [a.c3]), partitions(p0)
  3 - output([b.c2], [b.c1], [b.c3]), filter(nil), 
      access([b.c2], [b.c1], [b.c3]), partitions(p0)

select * from t11 a left join t6 b on a.c1=b.c2 and a.c2=b.c1;
+----+----+------+----+----+------+
| c1 | c2 | c3   | c1 | c2 | c3   |
+----+----+------+----+----+------+
|  1 |  1 | a    |  1 |  1 | a    |
|  1 |  1 | b    |  1 |  1 | a    |
|  3 |  3 | c    |  3 |  3 | c    |
|  3 |  3 | d    |  3 |  3 | c    |
|  4 |  4 | e    |  4 |  4 | d    |
|  4 |  4 | f    |  4 |  4 | d    |
+----+----+------+----+----+------+
EXPLAIN select * from t11 a left join t6 b on a.c1=b.c1 and a.c2=b.c2;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |6        |91  |
|1 | SORT       |    |6        |48  |
|2 |  TABLE SCAN|a   |6        |38  |
|3 | TABLE SCAN |b   |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c1 = b.c1], [a.c2 = b.c2]), other_conds(nil)
  1 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c1, ASC], [a.c2, ASC])
  2 - output([a.c1], [a.c2], [a.c3]), filter(nil), 
      access([a.c1], [a.c2], [a.c3]), partitions(p0)
  3 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

select * from t11 a left join t6 b on a.c1=b.c1 and a.c2=b.c2;
+----+----+------+----+----+------+
| c1 | c2 | c3   | c1 | c2 | c3   |
+----+----+------+----+----+------+
|  1 |  1 | a    |  1 |  1 | a    |
|  1 |  1 | b    |  1 |  1 | a    |
|  3 |  3 | c    |  3 |  3 | c    |
|  3 |  3 | d    |  3 |  3 | c    |
|  4 |  4 | e    |  4 |  4 | d    |
|  4 |  4 | f    |  4 |  4 | d    |
+----+----+------+----+----+------+
EXPLAIN select /*+NO_REWRITE*/* from t11 a left join t6 b on a.c1=b.c1 and a.c2=b.c2;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |91  |
|1 | SORT           |    |6        |48  |
|2 |  TABLE SCAN    |a   |6        |38  |
|3 | TABLE SCAN     |b   |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c1 = b.c1], [a.c2 = b.c2]), other_conds(nil)
  1 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c1, ASC], [a.c2, ASC])
  2 - output([a.c1], [a.c2], [a.c3]), filter(nil), 
      access([a.c1], [a.c2], [a.c3]), partitions(p0)
  3 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

select /*+NO_REWRITE*/* from t11 a left join t6 b on a.c1=b.c1 and a.c2=b.c2;
+----+----+------+----+----+------+
| c1 | c2 | c3   | c1 | c2 | c3   |
+----+----+------+----+----+------+
|  1 |  1 | a    |  1 |  1 | a    |
|  1 |  1 | b    |  1 |  1 | a    |
|  3 |  3 | c    |  3 |  3 | c    |
|  3 |  3 | d    |  3 |  3 | c    |
|  4 |  4 | e    |  4 |  4 | d    |
|  4 |  4 | f    |  4 |  4 | d    |
+----+----+------+----+----+------+
EXPLAIN insert into t16_temp (select * from t11 a left join t6 b on a.c1=b.c1 and a.c2=b.c2);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |92  |
|1 | SUBPLAN SCAN |VIEW1|6        |91  |
|2 |  MERGE JOIN  |     |6        |91  |
|3 |   SORT       |     |6        |48  |
|4 |    TABLE SCAN|a    |6        |38  |
|5 |   TABLE SCAN |b    |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t16_temp: ({t16_temp: (t16_temp.__pk_increment, t16_temp.a, t16_temp.b, t16_temp.c, t16_temp.d, t16_temp.e, t16_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c1 = b.c1], [a.c2 = b.c2]), other_conds(nil)
  3 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c1, ASC], [a.c2, ASC])
  4 - output([a.c1], [a.c2], [a.c3]), filter(nil), 
      access([a.c1], [a.c2], [a.c3]), partitions(p0)
  5 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

insert into t16_temp (select * from t11 a left join t6 b on a.c1=b.c1 and a.c2=b.c2);
rollback;
EXPLAIN insert into t16_temp (select /*+NO_REWRITE*/ * from t11 a left join t6 b on a.c1=b.c1 and a.c2=b.c2);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |92  |
|1 | SUBPLAN SCAN     |VIEW1|6        |91  |
|2 |  MERGE OUTER JOIN|     |6        |91  |
|3 |   SORT           |     |6        |48  |
|4 |    TABLE SCAN    |a    |6        |38  |
|5 |   TABLE SCAN     |b    |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t16_temp: ({t16_temp: (t16_temp.__pk_increment, t16_temp.a, t16_temp.b, t16_temp.c, t16_temp.d, t16_temp.e, t16_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c1 = b.c1], [a.c2 = b.c2]), other_conds(nil)
  3 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c1, ASC], [a.c2, ASC])
  4 - output([a.c1], [a.c2], [a.c3]), filter(nil), 
      access([a.c1], [a.c2], [a.c3]), partitions(p0)
  5 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

insert into t16_temp (select /*+NO_REWRITE*/ * from t11 a left join t6 b on a.c1=b.c1 and a.c2=b.c2);
rollback;
EXPLAIN update t5 set c2 = (select a.c1 from t11 a left join t6 b on a.c1=b.c1 and a.c2=b.c2 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |80  |
|1 | SUBPLAN FILTER|    |6        |74  |
|2 |  TABLE SCAN   |t5  |6        |37  |
|3 |  TABLE SCAN   |a   |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([a.c1]), filter(nil), 
      access([a.c1]), partitions(p0), 
      limit(1), offset(nil)

update t5 set c2 = (select a.c1 from t11 a left join t6 b on a.c1=b.c1 and a.c2=b.c2 limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t5 set c2 = (select /*+NO_REWRITE*/ a.c1 from t11 a left join t6 b on a.c1=b.c1 and a.c2=b.c2 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |117 |
|1 | SUBPLAN FILTER          |    |6        |111 |
|2 |  TABLE SCAN             |t5  |6        |37  |
|3 |  LIMIT                  |    |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |73  |
|5 |    TABLE SCAN           |a   |1        |36  |
|6 |    TABLE GET            |b   |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([a.c1]), filter(nil), limit(1), offset(nil)
  4 - output([a.c1]), filter(nil), 
      conds(nil), nl_params_([a.c1], [a.c2])
  5 - output([a.c1], [a.c2]), filter(nil), 
      access([a.c1], [a.c2]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([b.c1]), partitions(p0)

update t5 set c2 = (select /*+NO_REWRITE*/ a.c1 from t11 a left join t6 b on a.c1=b.c1 and a.c2=b.c2 limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;

##case 分区表的主外键连接
##父表有partition hint，不能消除
EXPLAIN select * from t10 partition(p1) a left join t7 partition(p1) b on a.c1=b.c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |2        |75  |
|1 | TABLE SCAN     |a   |2        |37  |
|2 | TABLE SCAN     |b   |2        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2], [a.c3]), filter(nil), 
      access([a.c1], [a.c2], [a.c3]), partitions(p1)
  2 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p1)

select * from t10 partition(p1) a left join t7 partition(p1) b on a.c1=b.c1;
+----+------+------+----+------+------+
| c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+------+----+------+------+
|  1 |    2 | a    |  1 |    1 | a    |
|  1 |    2 | b    |  1 |    1 | a    |
+----+------+------+----+------+------+
EXPLAIN select * from t10 partition(p1) a left join t7 b on a.c1=b.c1;
Query Plan
==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |2        |86  |
|1 | EXCHANGE OUT DISTR          |:EX10001|2        |85  |
|2 |  MERGE JOIN                 |        |2        |85  |
|3 |   EXCHANGE IN DISTR         |        |2        |37  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|2        |37  |
|5 |     TABLE SCAN              |a       |2        |37  |
|6 |   SORT                      |        |5        |46  |
|7 |    PX PARTITION ITERATOR    |        |5        |37  |
|8 |     TABLE SCAN              |b       |5        |37  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil)
  1 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), dop=1
  2 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  3 - output([a.c1], [a.c2], [a.c3]), filter(nil)
  4 - (#keys=1, [a.c1]), output([a.c1], [a.c2], [a.c3]), filter(nil), is_single, dop=1
  5 - output([a.c1], [a.c2], [a.c3]), filter(nil), 
      access([a.c1], [a.c2], [a.c3]), partitions(p1)
  6 - output([b.c1], [b.c2], [b.c3]), filter(nil), sort_keys([b.c1, ASC]), local merge sort
  7 - output([b.c1], [b.c2], [b.c3]), filter(nil)
  8 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p[0-4])

select * from t10 partition(p1) a left join t7 b on a.c1=b.c1;
+----+------+------+----+------+------+
| c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+------+----+------+------+
|  1 |    2 | a    |  1 |    1 | a    |
|  1 |    2 | b    |  1 |    1 | a    |
+----+------+------+----+------+------+
EXPLAIN select /*+NO_REWRITE*/ * from t10 partition(p1) a left join t7 b on a.c1=b.c1;
Query Plan
==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |2        |86  |
|1 | EXCHANGE OUT DISTR          |:EX10001|2        |85  |
|2 |  MERGE OUTER JOIN           |        |2        |85  |
|3 |   EXCHANGE IN DISTR         |        |2        |37  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|2        |37  |
|5 |     TABLE SCAN              |a       |2        |37  |
|6 |   SORT                      |        |5        |46  |
|7 |    PX PARTITION ITERATOR    |        |5        |37  |
|8 |     TABLE SCAN              |b       |5        |37  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil)
  1 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), dop=1
  2 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  3 - output([a.c1], [a.c2], [a.c3]), filter(nil)
  4 - (#keys=1, [a.c1]), output([a.c1], [a.c2], [a.c3]), filter(nil), is_single, dop=1
  5 - output([a.c1], [a.c2], [a.c3]), filter(nil), 
      access([a.c1], [a.c2], [a.c3]), partitions(p1)
  6 - output([b.c1], [b.c2], [b.c3]), filter(nil), sort_keys([b.c1, ASC]), local merge sort
  7 - output([b.c1], [b.c2], [b.c3]), filter(nil)
  8 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p[0-4])

select /*+NO_REWRITE*/ * from t10 partition(p1) a left join t7 b on a.c1=b.c1;
+----+------+------+----+------+------+
| c1 | c2   | c3   | c1 | c2   | c3   |
+----+------+------+----+------+------+
|  1 |    2 | a    |  1 |    1 | a    |
|  1 |    2 | b    |  1 |    1 | a    |
+----+------+------+----+------+------+
EXPLAIN insert into t16_temp (select * from t10 partition(p1) a left join t7 b on a.c1=b.c1);
Query Plan
============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |INSERT                         |        |2        |86  |
|1 | PX COORDINATOR                |        |2        |86  |
|2 |  EXCHANGE OUT DISTR           |:EX10001|2        |85  |
|3 |   SUBPLAN SCAN                |VIEW1   |2        |85  |
|4 |    MERGE JOIN                 |        |2        |85  |
|5 |     EXCHANGE IN DISTR         |        |2        |37  |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|2        |37  |
|7 |       TABLE SCAN              |a       |2        |37  |
|8 |     SORT                      |        |5        |46  |
|9 |      PX PARTITION ITERATOR    |        |5        |37  |
|10|       TABLE SCAN              |b       |5        |37  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t16_temp: ({t16_temp: (t16_temp.__pk_increment, t16_temp.a, t16_temp.b, t16_temp.c, t16_temp.d, t16_temp.e, t16_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil)
  2 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), dop=1
  3 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  4 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  5 - output([a.c1], [a.c2], [a.c3]), filter(nil)
  6 - (#keys=1, [a.c1]), output([a.c1], [a.c2], [a.c3]), filter(nil), is_single, dop=1
  7 - output([a.c1], [a.c2], [a.c3]), filter(nil), 
      access([a.c1], [a.c2], [a.c3]), partitions(p1)
  8 - output([b.c1], [b.c2], [b.c3]), filter(nil), sort_keys([b.c1, ASC]), local merge sort
  9 - output([b.c1], [b.c2], [b.c3]), filter(nil)
  10 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p[0-4])

insert into t16_temp (select * from t10 partition(p1) a left join t7 b on a.c1=b.c1);
rollback;
EXPLAIN insert into t16_temp (select /*+NO_REWRITE*/ * from t10 partition(p1) a left join t7 b on a.c1=b.c1);
Query Plan
============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |INSERT                         |        |2        |86  |
|1 | PX COORDINATOR                |        |2        |86  |
|2 |  EXCHANGE OUT DISTR           |:EX10001|2        |85  |
|3 |   SUBPLAN SCAN                |VIEW1   |2        |85  |
|4 |    MERGE OUTER JOIN           |        |2        |85  |
|5 |     EXCHANGE IN DISTR         |        |2        |37  |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|2        |37  |
|7 |       TABLE SCAN              |a       |2        |37  |
|8 |     SORT                      |        |5        |46  |
|9 |      PX PARTITION ITERATOR    |        |5        |37  |
|10|       TABLE SCAN              |b       |5        |37  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t16_temp: ({t16_temp: (t16_temp.__pk_increment, t16_temp.a, t16_temp.b, t16_temp.c, t16_temp.d, t16_temp.e, t16_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil)
  2 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), dop=1
  3 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  4 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  5 - output([a.c1], [a.c2], [a.c3]), filter(nil)
  6 - (#keys=1, [a.c1]), output([a.c1], [a.c2], [a.c3]), filter(nil), is_single, dop=1
  7 - output([a.c1], [a.c2], [a.c3]), filter(nil), 
      access([a.c1], [a.c2], [a.c3]), partitions(p1)
  8 - output([b.c1], [b.c2], [b.c3]), filter(nil), sort_keys([b.c1, ASC]), local merge sort
  9 - output([b.c1], [b.c2], [b.c3]), filter(nil)
  10 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p[0-4])

insert into t16_temp (select /*+NO_REWRITE*/ * from t10 partition(p1) a left join t7 b on a.c1=b.c1);
rollback;
EXPLAIN update t5 set c2 = (select a.c1 from t10 partition(p1) a left join t7 b on a.c1=b.c1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |80  |
|1 | SUBPLAN FILTER|    |6        |74  |
|2 |  TABLE SCAN   |t5  |6        |37  |
|3 |  TABLE SCAN   |a   |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([a.c1]), filter(nil), 
      access([a.c1]), partitions(p1), 
      limit(1), offset(nil)

update t5 set c2 = (select a.c1 from t10 partition(p1) a left join t7 b on a.c1=b.c1 limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t5 set c2 = (select /*+NO_REWRITE*/ a.c1 from t10 partition(p1) a left join t7 b on a.c1=b.c1 limit 1);
Query Plan
==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |UPDATE                           |        |6        |117 |
|1 | SUBPLAN FILTER                  |        |6        |111 |
|2 |  TABLE SCAN                     |t5      |6        |37  |
|3 |  LIMIT                          |        |1        |74  |
|4 |   PX COORDINATOR                |        |1        |73  |
|5 |    EXCHANGE OUT DISTR           |:EX10001|1        |73  |
|6 |     LIMIT                       |        |1        |73  |
|7 |      NESTED-LOOP OUTER JOIN     |        |1        |73  |
|8 |       EXCHANGE IN DISTR         |        |1        |36  |
|9 |        EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |36  |
|10|         TABLE SCAN              |a       |1        |36  |
|11|       PX PARTITION ITERATOR     |        |1        |36  |
|12|        TABLE GET                |b       |1        |36  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([a.c1]), filter(nil), limit(1), offset(nil)
  4 - output([a.c1]), filter(nil)
  5 - output([a.c1]), filter(nil), dop=1
  6 - output([a.c1]), filter(nil), limit(1), offset(nil)
  7 - output([a.c1]), filter(nil), 
      conds(nil), nl_params_([a.c1])
  8 - output([a.c1], [PARTITION_ID]), filter(nil)
  9 - (#keys=1, [a.c1]), output([a.c1], [PARTITION_ID]), filter(nil), is_single, dop=1
  10 - output([a.c1]), filter(nil), 
      access([a.c1]), partitions(p1)
  11 - output([1]), filter(nil)
  12 - output([1]), filter(nil), 
      access([b.c1]), partitions(p[0-4])

update t5 set c2 = (select /*+NO_REWRITE*/ a.c1 from t10 partition(p1) a left join t7 b on a.c1=b.c1 limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;

EXPLAIN select * from t8 a full join t5 b on a.c2=b.c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |90  |
|1 | TABLE SCAN     |b   |6        |37  |
|2 | SORT           |    |6        |48  |
|3 |  TABLE SCAN    |a   |6        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  1 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)
  2 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  3 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)

select * from t8 a full join t5 b on a.c2=b.c1;
+------+----+------+----+------+------+
| c1   | c2 | c3   | c1 | c2   | c3   |
+------+----+------+----+------+------+
|    1 |  1 | a    |  1 |    1 | a    |
|    1 |  2 | b    |  2 |    5 | b    |
|    3 |  3 | c    |  3 |    5 | c    |
|    3 |  3 | d    |  3 |    5 | c    |
| NULL |  4 | e    |  4 |    6 | d    |
| NULL |  4 | f    |  4 |    6 | d    |
| NULL | NULL | NULL |  5 |    7 | e    |
| NULL | NULL | NULL |  6 |    8 | f    |
+------+----+------+----+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t8 a full join t5 b on a.c2=b.c1;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |MERGE FULL OUTER JOIN|    |6        |90  |
|1 | SORT                |    |6        |48  |
|2 |  TABLE SCAN         |a   |6        |38  |
|3 | TABLE SCAN          |b   |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  2 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  3 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

select /*+NO_REWRITE*/* from t8 a full join t5 b on a.c2=b.c1;
+------+----+------+----+------+------+
| c1   | c2 | c3   | c1 | c2   | c3   |
+------+----+------+----+------+------+
|    1 |  1 | a    |  1 |    1 | a    |
|    1 |  2 | b    |  2 |    5 | b    |
|    3 |  3 | c    |  3 |    5 | c    |
|    3 |  3 | d    |  3 |    5 | c    |
| NULL |  4 | e    |  4 |    6 | d    |
| NULL |  4 | f    |  4 |    6 | d    |
| NULL | NULL | NULL |  5 |    7 | e    |
| NULL | NULL | NULL |  6 |    8 | f    |
+------+----+------+----+------+------+
EXPLAIN insert into t16_temp (select * from t8 a full join t5 b on a.c2=b.c1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |92  |
|1 | SUBPLAN SCAN     |VIEW1|6        |91  |
|2 |  MERGE OUTER JOIN|     |6        |90  |
|3 |   TABLE SCAN     |b    |6        |37  |
|4 |   SORT           |     |6        |48  |
|5 |    TABLE SCAN    |a    |6        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t16_temp: ({t16_temp: (t16_temp.__pk_increment, t16_temp.a, t16_temp.b, t16_temp.c, t16_temp.d, t16_temp.e, t16_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  3 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)
  4 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  5 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)

insert into t16_temp (select * from t8 a full join t5 b on a.c2=b.c1);
rollback;
EXPLAIN insert into t16_temp (select /*+NO_REWRITE*/ * from t8 a full join t5 b on a.c2=b.c1);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |6        |92  |
|1 | SUBPLAN SCAN          |VIEW1|6        |91  |
|2 |  MERGE FULL OUTER JOIN|     |6        |90  |
|3 |   SORT                |     |6        |48  |
|4 |    TABLE SCAN         |a    |6        |38  |
|5 |   TABLE SCAN          |b    |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t16_temp: ({t16_temp: (t16_temp.__pk_increment, t16_temp.a, t16_temp.b, t16_temp.c, t16_temp.d, t16_temp.e, t16_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  3 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  4 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  5 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

insert into t16_temp (select /*+NO_REWRITE*/ * from t8 a full join t5 b on a.c2=b.c1);
rollback;
EXPLAIN update t5 set c2 = (select a.c1 from t8 a full join t5 b on a.c2=b.c1 limit 1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |UPDATE            |     |6        |121 |
|1 | SUBPLAN FILTER   |     |6        |115 |
|2 |  TABLE SCAN      |t5   |6        |37  |
|3 |  LIMIT           |     |1        |77  |
|4 |   HASH OUTER JOIN|     |1        |77  |
|5 |    SUBPLAN SCAN  |VIEW1|1        |37  |
|6 |     TABLE SCAN   |b    |1        |36  |
|7 |    TABLE SCAN    |a    |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([a.c1]), filter(nil), limit(1), offset(nil)
  4 - output([a.c1]), filter(nil), 
      equal_conds([a.c2 = VIEW1.b.c1]), other_conds(nil)
  5 - output([VIEW1.b.c1]), filter(nil), 
      access([VIEW1.b.c1])
  6 - output([b.c1]), filter(nil), 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)
  7 - output([a.c2], [a.c1]), filter(nil), 
      access([a.c2], [a.c1]), partitions(p0)

update t5 set c2 = (select a.c1 from t8 a full join t5 b on a.c2=b.c1 limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t5 set c2 = (select /*+NO_REWRITE*/ a.c1 from t8 a full join t5 b on a.c2=b.c1 limit 1);
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |UPDATE                 |    |6        |125 |
|1 | SUBPLAN FILTER        |    |6        |119 |
|2 |  TABLE SCAN           |t5  |6        |37  |
|3 |  LIMIT                |    |1        |81  |
|4 |   HASH FULL OUTER JOIN|    |1        |81  |
|5 |    TABLE SCAN         |b   |6        |37  |
|6 |    TABLE SCAN         |a   |1        |36  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([a.c1]), filter(nil), limit(1), offset(nil)
  4 - output([a.c1]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  5 - output([b.c1]), filter(nil), 
      access([b.c1]), partitions(p0)
  6 - output([a.c2], [a.c1]), filter(nil), 
      access([a.c2], [a.c1]), partitions(p0)

update t5 set c2 = (select /*+NO_REWRITE*/ a.c1 from t8 a full join t5 b on a.c2=b.c1 limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;

EXPLAIN select * from t5 b right join t8 a on a.c2=b.c1;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |6        |90  |
|1 | SORT       |    |6        |48  |
|2 |  TABLE SCAN|a   |6        |38  |
|3 | TABLE SCAN |b   |6        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([b.c1], [b.c2], [b.c3], [a.c1], [a.c2], [a.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  2 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  3 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

select * from t5 b right join t8 a on a.c2=b.c1;
+----+------+------+------+----+------+
| c1 | c2   | c3   | c1   | c2 | c3   |
+----+------+------+------+----+------+
|  1 |    1 | a    |    1 |  1 | a    |
|  2 |    5 | b    |    1 |  2 | b    |
|  3 |    5 | c    |    3 |  3 | c    |
|  3 |    5 | c    |    3 |  3 | d    |
|  4 |    6 | d    | NULL |  4 | e    |
|  4 |    6 | d    | NULL |  4 | f    |
+----+------+------+------+----+------+
EXPLAIN select /*+NO_REWRITE*/* from t5 b right join t8 a on a.c2=b.c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |6        |90  |
|1 | SORT           |    |6        |48  |
|2 |  TABLE SCAN    |a   |6        |38  |
|3 | TABLE SCAN     |b   |6        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([b.c1], [b.c2], [b.c3], [a.c1], [a.c2], [a.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  2 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  3 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

select /*+NO_REWRITE*/* from t5 b right join t8 a on a.c2=b.c1;
+----+------+------+------+----+------+
| c1 | c2   | c3   | c1   | c2 | c3   |
+----+------+------+------+----+------+
|  1 |    1 | a    |    1 |  1 | a    |
|  2 |    5 | b    |    1 |  2 | b    |
|  3 |    5 | c    |    3 |  3 | c    |
|  3 |    5 | c    |    3 |  3 | d    |
|  4 |    6 | d    | NULL |  4 | e    |
|  4 |    6 | d    | NULL |  4 | f    |
+----+------+------+------+----+------+
EXPLAIN insert into t16_temp (select * from t5 b right join t8 a on a.c2=b.c1);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |92  |
|1 | SUBPLAN SCAN |VIEW1|6        |91  |
|2 |  MERGE JOIN  |     |6        |90  |
|3 |   SORT       |     |6        |48  |
|4 |    TABLE SCAN|a    |6        |38  |
|5 |   TABLE SCAN |b    |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t16_temp: ({t16_temp: (t16_temp.__pk_increment, t16_temp.a, t16_temp.b, t16_temp.c, t16_temp.d, t16_temp.e, t16_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([b.c1], [b.c2], [b.c3], [a.c1], [a.c2], [a.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  3 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  4 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  5 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

insert into t16_temp (select * from t5 b right join t8 a on a.c2=b.c1);

rollback;
EXPLAIN insert into t16_temp (select /*+NO_REWRITE*/ * from t5 b right join t8 a on a.c2=b.c1);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT            |     |6        |92  |
|1 | SUBPLAN SCAN     |VIEW1|6        |91  |
|2 |  MERGE OUTER JOIN|     |6        |90  |
|3 |   SORT           |     |6        |48  |
|4 |    TABLE SCAN    |a    |6        |38  |
|5 |   TABLE SCAN     |b    |6        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t16_temp: ({t16_temp: (t16_temp.__pk_increment, t16_temp.a, t16_temp.b, t16_temp.c, t16_temp.d, t16_temp.e, t16_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([b.c1], [b.c2], [b.c3], [a.c1], [a.c2], [a.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  3 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  4 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  5 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

insert into t16_temp (select /*+NO_REWRITE*/ * from t5 b right join t8 a on a.c2=b.c1);
rollback;
EXPLAIN update t5 set c2 = (select a.c1 from t5 b right join t8 a on a.c2=b.c1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |80  |
|1 | SUBPLAN FILTER|    |6        |74  |
|2 |  TABLE SCAN   |t5  |6        |37  |
|3 |  TABLE SCAN   |a   |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([a.c1]), filter(nil), 
      access([a.c1]), partitions(p0), 
      limit(1), offset(nil)

update t5 set c2 = (select a.c1 from t5 b right join t8 a on a.c2=b.c1 limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t5 set c2 = (select /*+NO_REWRITE*/ a.c1 from t5 b right join t8 a on a.c2=b.c1 limit 1);
Query Plan
==================================================
|ID|OPERATOR                 |NAME|EST. ROWS|COST|
--------------------------------------------------
|0 |UPDATE                   |    |6        |117 |
|1 | SUBPLAN FILTER          |    |6        |111 |
|2 |  TABLE SCAN             |t5  |6        |37  |
|3 |  LIMIT                  |    |1        |73  |
|4 |   NESTED-LOOP OUTER JOIN|    |1        |73  |
|5 |    TABLE SCAN           |a   |1        |36  |
|6 |    TABLE GET            |b   |1        |36  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([a.c1]), filter(nil), limit(1), offset(nil)
  4 - output([a.c1]), filter(nil), 
      conds(nil), nl_params_([a.c2])
  5 - output([a.c2], [a.c1]), filter(nil), 
      access([a.c2], [a.c1]), partitions(p0)
  6 - output([1]), filter(nil), 
      access([b.c1]), partitions(p0)

update t5 set c2 = (select /*+NO_REWRITE*/ a.c1 from t5 b right join t8 a on a.c2=b.c1 limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;

EXPLAIN select * from t8 a full join t5 b on a.c2=b.c1 where a.c1 is not null;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |6        |91  |
|1 | TABLE SCAN |b   |6        |37  |
|2 | SORT       |    |6        |48  |
|3 |  TABLE SCAN|a   |6        |38  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  1 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)
  2 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  3 - output([a.c2], [a.c1], [a.c3]), filter([(T_OP_IS_NOT, a.c1, NULL, 0)]), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)

select * from t8 a full join t5 b on a.c2=b.c1 where a.c1 is not null;
+------+----+------+----+------+------+
| c1   | c2 | c3   | c1 | c2   | c3   |
+------+----+------+----+------+------+
|    1 |  1 | a    |  1 |    1 | a    |
|    1 |  2 | b    |  2 |    5 | b    |
|    3 |  3 | c    |  3 |    5 | c    |
|    3 |  3 | d    |  3 |    5 | c    |
+------+----+------+----+------+------+
EXPLAIN select /*+NO_REWRITE*/* from t8 a full join t5 b on a.c2=b.c1 where a.c1 is not null;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |MERGE FULL OUTER JOIN|    |6        |90  |
|1 | SORT                |    |6        |48  |
|2 |  TABLE SCAN         |a   |6        |38  |
|3 | TABLE SCAN          |b   |6        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter([(T_OP_IS_NOT, a.c1, NULL, 0)]), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  2 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  3 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

select /*+NO_REWRITE*/* from t8 a full join t5 b on a.c2=b.c1 where a.c1 is not null;
+------+----+------+----+------+------+
| c1   | c2 | c3   | c1 | c2   | c3   |
+------+----+------+----+------+------+
|    1 |  1 | a    |  1 |    1 | a    |
|    1 |  2 | b    |  2 |    5 | b    |
|    3 |  3 | c    |  3 |    5 | c    |
|    3 |  3 | d    |  3 |    5 | c    |
+------+----+------+----+------+------+
EXPLAIN insert into t16_temp (select * from t8 a full join t5 b on a.c2=b.c1 where a.c1 is not null);
Query Plan
========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST|
----------------------------------------
|0 |INSERT        |     |6        |92  |
|1 | SUBPLAN SCAN |VIEW1|6        |91  |
|2 |  MERGE JOIN  |     |6        |91  |
|3 |   TABLE SCAN |b    |6        |37  |
|4 |   SORT       |     |6        |48  |
|5 |    TABLE SCAN|a    |6        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t16_temp: ({t16_temp: (t16_temp.__pk_increment, t16_temp.a, t16_temp.b, t16_temp.c, t16_temp.d, t16_temp.e, t16_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter(nil), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  3 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)
  4 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  5 - output([a.c2], [a.c1], [a.c3]), filter([(T_OP_IS_NOT, a.c1, NULL, 0)]), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)

insert into t16_temp (select * from t8 a full join t5 b on a.c2=b.c1 where a.c1 is not null);

rollback;
EXPLAIN insert into t16_temp (select /*+NO_REWRITE*/ * from t8 a full join t5 b on a.c2=b.c1 where a.c1 is not null);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT                 |     |6        |92  |
|1 | SUBPLAN SCAN          |VIEW1|6        |91  |
|2 |  MERGE FULL OUTER JOIN|     |6        |90  |
|3 |   SORT                |     |6        |48  |
|4 |    TABLE SCAN         |a    |6        |38  |
|5 |   TABLE SCAN          |b    |6        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(VARCHAR,utf8mb4_general_ci,length:32,NULL,VIEW1.c3)]), filter(nil), 
      columns([{t16_temp: ({t16_temp: (t16_temp.__pk_increment, t16_temp.a, t16_temp.b, t16_temp.c, t16_temp.d, t16_temp.e, t16_temp.f)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c3], [VIEW1.c1], [VIEW1.c2], [VIEW1.c3])
  2 - output([a.c1], [a.c2], [a.c3], [b.c1], [b.c2], [b.c3]), filter([(T_OP_IS_NOT, a.c1, NULL, 0)]), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  3 - output([a.c1], [a.c2], [a.c3]), filter(nil), sort_keys([a.c2, ASC])
  4 - output([a.c2], [a.c1], [a.c3]), filter(nil), 
      access([a.c2], [a.c1], [a.c3]), partitions(p0)
  5 - output([b.c1], [b.c2], [b.c3]), filter(nil), 
      access([b.c1], [b.c2], [b.c3]), partitions(p0)

insert into t16_temp (select /*+NO_REWRITE*/ * from t8 a full join t5 b on a.c2=b.c1 where a.c1 is not null);
rollback;
EXPLAIN update t5 set c2 = (select a.c1 from t8 a full join t5 b on a.c2=b.c1 where a.c1 is not null limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |6        |80  |
|1 | SUBPLAN FILTER|    |6        |74  |
|2 |  TABLE SCAN   |t5  |6        |37  |
|3 |  TABLE SCAN   |a   |1        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([a.c1]), filter([(T_OP_IS_NOT, a.c1, NULL, 0)]), 
      access([a.c1]), partitions(p0), 
      limit(1), offset(nil)

update t5 set c2 = (select a.c1 from t8 a full join t5 b on a.c2=b.c1 where a.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t5 set c2 = (select /*+NO_REWRITE*/ a.c1 from t8 a full join t5 b on a.c2=b.c1 where a.c1 is not null limit 1);
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |UPDATE                 |    |6        |125 |
|1 | SUBPLAN FILTER        |    |6        |119 |
|2 |  TABLE SCAN           |t5  |6        |37  |
|3 |  LIMIT                |    |1        |81  |
|4 |   HASH FULL OUTER JOIN|    |1        |81  |
|5 |    TABLE SCAN         |b   |6        |37  |
|6 |    TABLE SCAN         |a   |1        |36  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([a.c1]), filter(nil), limit(1), offset(nil)
  4 - output([a.c1]), filter([(T_OP_IS_NOT, a.c1, NULL, 0)]), 
      equal_conds([a.c2 = b.c1]), other_conds(nil)
  5 - output([b.c1]), filter(nil), 
      access([b.c1]), partitions(p0)
  6 - output([a.c2], [a.c1]), filter(nil), 
      access([a.c2], [a.c1]), partitions(p0)

update t5 set c2 = (select /*+NO_REWRITE*/ a.c1 from t8 a full join t5 b on a.c2=b.c1 where a.c1 is not null limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;

EXPLAIN select * from (select t5.c2 from t8 left join t5 on t5.c1=t8.c2) a full join (select t8.c2 from t8 left join t5 on t8.c1=t5.c1 where t5.c2 is not null) b on a.c2 = b.c2;
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |HASH FULL OUTER JOIN|    |6        |182 |
|1 | SUBPLAN SCAN       |b   |6        |86  |
|2 |  MERGE JOIN        |    |6        |86  |
|3 |   SORT             |    |6        |43  |
|4 |    TABLE SCAN      |t8  |6        |37  |
|5 |   TABLE SCAN       |t5  |6        |38  |
|6 | MERGE JOIN         |    |6        |84  |
|7 |  SORT              |    |6        |42  |
|8 |   TABLE SCAN       |t8  |6        |37  |
|9 |  TABLE SCAN        |t5  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c2], [b.c2]), filter(nil), 
      equal_conds([t5.c2 = b.c2]), other_conds(nil)
  1 - output([b.c2]), filter(nil), 
      access([b.c2])
  2 - output([t8.c2]), filter(nil), 
      equal_conds([t8.c1 = t5.c1]), other_conds(nil)
  3 - output([t8.c2], [t8.c1]), filter(nil), sort_keys([t8.c1, ASC])
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0)
  5 - output([t5.c1]), filter([(T_OP_IS_NOT, t5.c2, NULL, 0)]), 
      access([t5.c1], [t5.c2]), partitions(p0)
  6 - output([t5.c2]), filter(nil), 
      equal_conds([t5.c1 = t8.c2]), other_conds(nil)
  7 - output([t8.c2]), filter(nil), sort_keys([t8.c2, ASC])
  8 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0)
  9 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)

select * from (select t5.c2 from t8 left join t5 on t5.c1=t8.c2) a full join (select t8.c2 from t8 left join t5 on t8.c1=t5.c1 where t5.c2 is not null) b on a.c2 = b.c2;
+------+----+
| c2   | c2 |
+------+----+
|    1 |  1 |
|    5 | NULL |
|    5 | NULL |
|    5 | NULL |
|    6 | NULL |
|    6 | NULL |
| NULL |  2 |
| NULL |  3 |
| NULL |  3 |
+------+----+
EXPLAIN select /*+NO_REWRITE*/* from (select /*+NO_REWRITE*/t5.c2 from t8 left join t5 on t5.c1=t8.c2) a full join (select /*+NO_REWRITE*/t8.c2 from t8 left join t5 on t8.c1=t5.c1 where t5.c2 is not null) b on a.c2 = b.c2;
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |HASH FULL OUTER JOIN|    |6        |182 |
|1 | SUBPLAN SCAN       |a   |6        |85  |
|2 |  MERGE OUTER JOIN  |    |6        |84  |
|3 |   SORT             |    |6        |42  |
|4 |    TABLE SCAN      |t8  |6        |37  |
|5 |   TABLE SCAN       |t5  |6        |37  |
|6 | SUBPLAN SCAN       |b   |6        |86  |
|7 |  MERGE OUTER JOIN  |    |6        |85  |
|8 |   SORT             |    |6        |43  |
|9 |    TABLE SCAN      |t8  |6        |37  |
|10|   TABLE SCAN       |t5  |6        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c2], [b.c2]), filter(nil), 
      equal_conds([a.c2 = b.c2]), other_conds(nil)
  1 - output([a.c2]), filter(nil), 
      access([a.c2])
  2 - output([t5.c2]), filter(nil), 
      equal_conds([t5.c1 = t8.c2]), other_conds(nil)
  3 - output([t8.c2]), filter(nil), sort_keys([t8.c2, ASC])
  4 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0)
  5 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  6 - output([b.c2]), filter(nil), 
      access([b.c2])
  7 - output([t8.c2]), filter([(T_OP_IS_NOT, t5.c2, NULL, 0)]), 
      equal_conds([t8.c1 = t5.c1]), other_conds(nil)
  8 - output([t8.c2], [t8.c1]), filter(nil), sort_keys([t8.c1, ASC])
  9 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0)
  10 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)

select /*+NO_REWRITE*/* from (select /*+NO_REWRITE*/t5.c2 from t8 left join t5 on t5.c1=t8.c2) a full join (select /*+NO_REWRITE*/t8.c2 from t8 left join t5 on t8.c1=t5.c1 where t5.c2 is not null) b on a.c2 = b.c2;
+------+----+
| c2   | c2 |
+------+----+
|    1 |  1 |
|    5 | NULL |
|    5 | NULL |
|    5 | NULL |
|    6 | NULL |
|    6 | NULL |
| NULL |  2 |
| NULL |  3 |
| NULL |  3 |
+------+----+
EXPLAIN insert into t11_temp (select * from (select t5.c2 from t8 left join t5 on t5.c1=t8.c2) a full join (select t8.c2 from t8 left join t5 on t8.c1=t5.c1 where t5.c2 is not null) b on a.c2 = b.c2);
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |INSERT                |     |6        |184 |
|1 | SUBPLAN SCAN         |VIEW1|6        |183 |
|2 |  HASH FULL OUTER JOIN|     |6        |182 |
|3 |   SUBPLAN SCAN       |b    |6        |86  |
|4 |    MERGE JOIN        |     |6        |86  |
|5 |     SORT             |     |6        |43  |
|6 |      TABLE SCAN      |t8   |6        |37  |
|7 |     TABLE SCAN       |t5   |6        |38  |
|8 |   MERGE JOIN         |     |6        |84  |
|9 |    SORT              |     |6        |42  |
|10|     TABLE SCAN       |t8   |6        |37  |
|11|    TABLE SCAN        |t5   |6        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.c2], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c2], [VIEW1.c2])
  2 - output([t5.c2], [b.c2]), filter(nil), 
      equal_conds([t5.c2 = b.c2]), other_conds(nil)
  3 - output([b.c2]), filter(nil), 
      access([b.c2])
  4 - output([t8.c2]), filter(nil), 
      equal_conds([t8.c1 = t5.c1]), other_conds(nil)
  5 - output([t8.c2], [t8.c1]), filter(nil), sort_keys([t8.c1, ASC])
  6 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0)
  7 - output([t5.c1]), filter([(T_OP_IS_NOT, t5.c2, NULL, 0)]), 
      access([t5.c1], [t5.c2]), partitions(p0)
  8 - output([t5.c2]), filter(nil), 
      equal_conds([t5.c1 = t8.c2]), other_conds(nil)
  9 - output([t8.c2]), filter(nil), sort_keys([t8.c2, ASC])
  10 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0)
  11 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)

insert into t11_temp (select * from (select t5.c2 from t8 left join t5 on t5.c1=t8.c2) a full join (select t8.c2 from t8 left join t5 on t8.c1=t5.c1 where t5.c2 is not null) b on a.c2 = b.c2);
rollback;
EXPLAIN insert into t11_temp (select /*+NO_REWRITE*/ * from (select /*+NO_REWRITE*/t5.c2 from t8 left join t5 on t5.c1=t8.c2) a full join (select /*+NO_REWRITE*/t8.c2 from t8 left join t5 on t8.c1=t5.c1 where t5.c2 is not null) b on a.c2 = b.c2);
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |INSERT                |     |6        |184 |
|1 | SUBPLAN SCAN         |VIEW1|6        |183 |
|2 |  HASH FULL OUTER JOIN|     |6        |182 |
|3 |   SUBPLAN SCAN       |a    |6        |85  |
|4 |    MERGE OUTER JOIN  |     |6        |84  |
|5 |     SORT             |     |6        |42  |
|6 |      TABLE SCAN      |t8   |6        |37  |
|7 |     TABLE SCAN       |t5   |6        |37  |
|8 |   SUBPLAN SCAN       |b    |6        |86  |
|9 |    MERGE OUTER JOIN  |     |6        |85  |
|10|     SORT             |     |6        |43  |
|11|      TABLE SCAN      |t8   |6        |37  |
|12|     TABLE SCAN       |t5   |6        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t11_temp: ({t11_temp: (t11_temp.__pk_increment, t11_temp.a, t11_temp.b)})}]), partitions(p0)
  1 - output([VIEW1.c2], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c2], [VIEW1.c2])
  2 - output([a.c2], [b.c2]), filter(nil), 
      equal_conds([a.c2 = b.c2]), other_conds(nil)
  3 - output([a.c2]), filter(nil), 
      access([a.c2])
  4 - output([t5.c2]), filter(nil), 
      equal_conds([t5.c1 = t8.c2]), other_conds(nil)
  5 - output([t8.c2]), filter(nil), sort_keys([t8.c2, ASC])
  6 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0)
  7 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  8 - output([b.c2]), filter(nil), 
      access([b.c2])
  9 - output([t8.c2]), filter([(T_OP_IS_NOT, t5.c2, NULL, 0)]), 
      equal_conds([t8.c1 = t5.c1]), other_conds(nil)
  10 - output([t8.c2], [t8.c1]), filter(nil), sort_keys([t8.c1, ASC])
  11 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0)
  12 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)

insert into t11_temp (select /*+NO_REWRITE*/ * from (select /*+NO_REWRITE*/t5.c2 from t8 left join t5 on t5.c1=t8.c2) a full join (select /*+NO_REWRITE*/t8.c2 from t8 left join t5 on t8.c1=t5.c1 where t5.c2 is not null) b on a.c2 = b.c2);
rollback;
EXPLAIN update t5 set c2 = (select a.c2 from (select t5.c2 from t8 left join t5 on t5.c1=t8.c2) a full join (select t8.c2 from t8 left join t5 on t8.c1=t5.c1 where t5.c2 is not null) b on a.c2 = b.c2 limit 1);
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |UPDATE                 |    |6        |217 |
|1 | SUBPLAN FILTER        |    |6        |211 |
|2 |  TABLE SCAN           |t5  |6        |37  |
|3 |  LIMIT                |    |1        |173 |
|4 |   HASH FULL OUTER JOIN|    |1        |173 |
|5 |    SUBPLAN SCAN       |b   |6        |86  |
|6 |     MERGE JOIN        |    |6        |86  |
|7 |      SORT             |    |6        |43  |
|8 |       TABLE SCAN      |t8  |6        |37  |
|9 |      TABLE SCAN       |t5  |6        |38  |
|10|    MERGE JOIN         |    |1        |79  |
|11|     SORT              |    |3        |42  |
|12|      TABLE SCAN       |t8  |6        |37  |
|13|     TABLE SCAN        |t5  |3        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([t5.c2]), filter(nil), limit(1), offset(nil)
  4 - output([t5.c2]), filter(nil), 
      equal_conds([t5.c2 = b.c2]), other_conds(nil)
  5 - output([b.c2]), filter(nil), 
      access([b.c2])
  6 - output([t8.c2]), filter(nil), 
      equal_conds([t8.c1 = t5.c1]), other_conds(nil)
  7 - output([t8.c2], [t8.c1]), filter(nil), sort_keys([t8.c1, ASC])
  8 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0)
  9 - output([t5.c1]), filter([(T_OP_IS_NOT, t5.c2, NULL, 0)]), 
      access([t5.c1], [t5.c2]), partitions(p0)
  10 - output([t5.c2]), filter(nil), 
      equal_conds([t5.c1 = t8.c2]), other_conds(nil)
  11 - output([t8.c2]), filter(nil), sort_keys([t8.c2, ASC])
  12 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0)
  13 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)

update t5 set c2 = (select a.c2 from (select t5.c2 from t8 left join t5 on t5.c1=t8.c2) a full join (select t8.c2 from t8 left join t5 on t8.c1=t5.c1 where t5.c2 is not null) b on a.c2 = b.c2 limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;
EXPLAIN update t5 set c2 = (select /*+NO_REWRITE*/ a.c2 from (select /*+NO_REWRITE*/t5.c2 from t8 left join t5 on t5.c1=t8.c2) a full join (select /*+NO_REWRITE*/t8.c2 from t8 left join t5 on t8.c1=t5.c1 where t5.c2 is not null) b on a.c2 = b.c2 limit 1);
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |UPDATE                 |    |6        |216 |
|1 | SUBPLAN FILTER        |    |6        |210 |
|2 |  TABLE SCAN           |t5  |6        |37  |
|3 |  LIMIT                |    |1        |172 |
|4 |   HASH FULL OUTER JOIN|    |1        |172 |
|5 |    SUBPLAN SCAN       |a   |6        |85  |
|6 |     MERGE OUTER JOIN  |    |6        |84  |
|7 |      SORT             |    |6        |42  |
|8 |       TABLE SCAN      |t8  |6        |37  |
|9 |      TABLE SCAN       |t5  |6        |37  |
|10|    SUBPLAN SCAN       |b   |1        |81  |
|11|     MERGE OUTER JOIN  |    |1        |81  |
|12|      SORT             |    |3        |43  |
|13|       TABLE SCAN      |t8  |6        |37  |
|14|      TABLE SCAN       |t5  |3        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t5: ({t5: (t5.c1, t5.c2, t5.c3)})}]),
      update([t5.c2=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  3 - output([a.c2]), filter(nil), limit(1), offset(nil)
  4 - output([a.c2]), filter(nil), 
      equal_conds([a.c2 = b.c2]), other_conds(nil)
  5 - output([a.c2]), filter(nil), 
      access([a.c2])
  6 - output([t5.c2]), filter(nil), 
      equal_conds([t5.c1 = t8.c2]), other_conds(nil)
  7 - output([t8.c2]), filter(nil), sort_keys([t8.c2, ASC])
  8 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0)
  9 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  10 - output([b.c2]), filter(nil), 
      access([b.c2])
  11 - output([t8.c2]), filter([(T_OP_IS_NOT, t5.c2, NULL, 0)]), 
      equal_conds([t8.c1 = t5.c1]), other_conds(nil)
  12 - output([t8.c2], [t8.c1]), filter(nil), sort_keys([t8.c1, ASC])
  13 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0)
  14 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)

update t5 set c2 = (select /*+NO_REWRITE*/ a.c2 from (select /*+NO_REWRITE*/t5.c2 from t8 left join t5 on t5.c1=t8.c2) a full join (select /*+NO_REWRITE*/t8.c2 from t8 left join t5 on t8.c1=t5.c1 where t5.c2 is not null) b on a.c2 = b.c2 limit 1);
EXPLAIN select stddev(c2) from t5;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t5  |6        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t5.c2 * t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2 * t5.c2), DECIMAL(20, 0)) - cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) * cast(T_FUN_SUM(t5.c2), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t5.c2) * T_FUN_COUNT(t5.c2), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c2)], [T_FUN_SUM(t5.c2 * t5.c2)], [T_FUN_COUNT(t5.c2)], [T_FUN_COUNT(t5.c2 * t5.c2)])
  1 - output([t5.c2], [t5.c2 * t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p0)

select stddev(c2) from t5;
+------------+
| stddev(c2) |
+------------+
|          0 |
+------------+
rollback;

set autocommit=1;

drop table if exists t11, t10, t9, t8, t7, t6, t5;
EXPLAIN insert into t4_temp(select * from t1 left join t2 on t1.c1=t2.c1);
Query Plan
===========================================
|ID|OPERATOR         |NAME |EST. ROWS|COST|
-------------------------------------------
|0 |INSERT           |     |8        |96  |
|1 | SUBPLAN SCAN    |VIEW1|8        |95  |
|2 |  HASH OUTER JOIN|     |8        |93  |
|3 |   TABLE SCAN    |t1   |8        |38  |
|4 |   TABLE SCAN    |t2   |9        |38  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2], [VIEW1.c1], [VIEW1.c2])
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

insert into t4_temp(select * from t1 left join t2 on t1.c1=t2.c1);
delete from t4_temp where a = (select t1.c1, t1.c2 from t1 left join t2 on t1.c1=t2.c1 limit 1);
ERROR 21000: Operand should contain 1 column(s)
EXPLAIN delete from t4_temp where a = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 limit 1);
Query Plan
==============================================
|ID|OPERATOR          |NAME   |EST. ROWS|COST|
----------------------------------------------
|0 |DELETE            |       |1        |119 |
|1 | SUBPLAN FILTER   |       |1        |118 |
|2 |  TABLE SCAN      |t4_temp|1        |39  |
|3 |  LIMIT           |       |1        |79  |
|4 |   HASH OUTER JOIN|       |1        |79  |
|5 |    SUBPLAN SCAN  |VIEW1  |1        |37  |
|6 |     TABLE SCAN   |t1     |1        |36  |
|7 |    TABLE SCAN    |t2     |9        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}])
  1 - output([t4_temp.__pk_increment], [t4_temp.a], [t4_temp.b], [t4_temp.c], [t4_temp.d]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t4_temp.__pk_increment], [t4_temp.a], [t4_temp.b], [t4_temp.c], [t4_temp.d]), filter([t4_temp.a = ?]), 
      access([t4_temp.__pk_increment], [t4_temp.a], [t4_temp.b], [t4_temp.c], [t4_temp.d]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t2.c1]), other_conds(nil)
  5 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t4_temp where a = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 limit 1);
EXPLAIN delete from t4_temp where (a, b) = (select t1.c1, t1.c2 from t1 left join t2 on t1.c1=t2.c1 limit 1);
Query Plan
==============================================
|ID|OPERATOR          |NAME   |EST. ROWS|COST|
----------------------------------------------
|0 |DELETE            |       |4        |124 |
|1 | SUBPLAN FILTER   |       |4        |120 |
|2 |  TABLE SCAN      |t4_temp|7        |38  |
|3 |  LIMIT           |       |1        |79  |
|4 |   HASH OUTER JOIN|       |1        |79  |
|5 |    SUBPLAN SCAN  |VIEW1  |1        |37  |
|6 |     TABLE SCAN   |t1     |1        |36  |
|7 |    TABLE SCAN    |t2     |9        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}])
  1 - output([t4_temp.__pk_increment], [t4_temp.a], [t4_temp.b], [t4_temp.c], [t4_temp.d]), filter([(t4_temp.a, t4_temp.b) = subquery(1)]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  2 - output([t4_temp.__pk_increment], [t4_temp.a], [t4_temp.b], [t4_temp.c], [t4_temp.d]), filter(nil), 
      access([t4_temp.__pk_increment], [t4_temp.a], [t4_temp.b], [t4_temp.c], [t4_temp.d]), partitions(p0)
  3 - output([VIEW1.t1.c1], [VIEW1.t1.c2]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1], [VIEW1.t1.c2]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t2.c1]), other_conds(nil)
  5 - output([VIEW1.t1.c1], [VIEW1.t1.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t1.c2])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      limit(1), offset(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

delete from t4_temp where (a, b) = (select t1.c1, t1.c2 from t1 left join t2 on t1.c1=t2.c1 limit 1);
delete from t4_temp where (a, b) = (select t1.c1, t1.c2, t2.c1 from t1 left join t2 on t1.c1=t2.c1 limit 1);
ERROR 21000: Operand should contain 2 column(s)
EXPLAIN select stddev(a) from t4_temp;
Query Plan
===========================================
|ID|OPERATOR       |NAME   |EST. ROWS|COST|
-------------------------------------------
|0 |SCALAR GROUP BY|       |1        |40  |
|1 | TABLE SCAN    |t4_temp|7        |38  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t4_temp.a * t4_temp.a), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t4_temp.a * t4_temp.a), DECIMAL(20, 0)) - cast(T_FUN_SUM(t4_temp.a), DECIMAL(65, 30)) * cast(T_FUN_SUM(t4_temp.a), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t4_temp.a) * T_FUN_COUNT(t4_temp.a), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t4_temp.a)], [T_FUN_SUM(t4_temp.a * t4_temp.a)], [T_FUN_COUNT(t4_temp.a)], [T_FUN_COUNT(t4_temp.a * t4_temp.a)])
  1 - output([t4_temp.a], [t4_temp.a * t4_temp.a]), filter(nil), 
      access([t4_temp.a]), partitions(p0)

select stddev(a) from t4_temp;
+--------------------+
| stddev(a)          |
+--------------------+
| 2.7856776554368237 |
+--------------------+
update t4_temp set a = (select t1.c1, t1.c2 from t1 left join t2 on t1.c1=t2.c1 limit 1);
ERROR 21000: Operand should contain 1 column(s)
EXPLAIN update t4_temp set a = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 limit 1);
Query Plan
==============================================
|ID|OPERATOR          |NAME   |EST. ROWS|COST|
----------------------------------------------
|0 |UPDATE            |       |7        |125 |
|1 | SUBPLAN FILTER   |       |7        |118 |
|2 |  TABLE SCAN      |t4_temp|7        |38  |
|3 |  LIMIT           |       |1        |79  |
|4 |   HASH OUTER JOIN|       |1        |79  |
|5 |    SUBPLAN SCAN  |VIEW1  |1        |37  |
|6 |     TABLE SCAN   |t1     |1        |36  |
|7 |    TABLE SCAN    |t2     |9        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t4_temp: ({t4_temp: (t4_temp.__pk_increment, t4_temp.a, t4_temp.b, t4_temp.c, t4_temp.d)})}]),
      update([t4_temp.a=column_conv(INT,PS:(11,0),NULL,?)])
  1 - output([t4_temp.__pk_increment], [t4_temp.a], [t4_temp.b], [t4_temp.c], [t4_temp.d], [column_conv(INT,PS:(11,0),NULL,?)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t4_temp.a], [t4_temp.__pk_increment], [t4_temp.b], [t4_temp.c], [t4_temp.d]), filter(nil), 
      access([t4_temp.a], [t4_temp.__pk_increment], [t4_temp.b], [t4_temp.c], [t4_temp.d]), partitions(p0)
  3 - output([VIEW1.t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t2.c1]), other_conds(nil)
  5 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

update t4_temp set a = (select t1.c1 from t1 left join t2 on t1.c1=t2.c1 limit 1);
EXPLAIN select stddev(a) from t4_temp;
Query Plan
===========================================
|ID|OPERATOR       |NAME   |EST. ROWS|COST|
-------------------------------------------
|0 |SCALAR GROUP BY|       |1        |40  |
|1 | TABLE SCAN    |t4_temp|7        |38  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([sqrt(cast(cast(T_FUN_SUM(t4_temp.a * t4_temp.a), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t4_temp.a * t4_temp.a), DECIMAL(20, 0)) - cast(T_FUN_SUM(t4_temp.a), DECIMAL(65, 30)) * cast(T_FUN_SUM(t4_temp.a), DECIMAL(65, 30)) / cast(T_FUN_COUNT(t4_temp.a) * T_FUN_COUNT(t4_temp.a), DECIMAL(40, 0)), DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t4_temp.a)], [T_FUN_SUM(t4_temp.a * t4_temp.a)], [T_FUN_COUNT(t4_temp.a)], [T_FUN_COUNT(t4_temp.a * t4_temp.a)])
  1 - output([t4_temp.a], [t4_temp.a * t4_temp.a]), filter(nil), 
      access([t4_temp.a]), partitions(p0)

select stddev(a) from t4_temp;
+-----------+
| stddev(a) |
+-----------+
|         0 |
+-----------+

drop table if exists t1_temp, t2_temp, t3_temp, t4_temp, t5_temp, t6_temp, t7_temp, t8_temp, t9_temp, t10_temp, t11_temp, t12_temp, t13_temp, t14_temp, t15_temp, t16_temp;
drop database transformer;
